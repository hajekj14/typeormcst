{"version":3,"sources":["../../src/metadata/EntityMetadata.ts"],"names":[],"mappings":"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","file":"EntityMetadata.js","sourcesContent":["import {ColumnMetadata} from \"./ColumnMetadata\";\r\nimport {RelationMetadata} from \"./RelationMetadata\";\r\nimport {IndexMetadata} from \"./IndexMetadata\";\r\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\r\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {LazyRelationsWrapper} from \"../lazy-loading/LazyRelationsWrapper\";\r\nimport {RelationIdMetadata} from \"./RelationIdMetadata\";\r\nimport {RelationCountMetadata} from \"./RelationCountMetadata\";\r\nimport {TableType} from \"./types/TableTypes\";\r\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {EntityListenerMetadata} from \"./EntityListenerMetadata\";\r\nimport {PropertyTypeFactory} from \"./types/PropertyTypeInFunction\";\r\n\r\n/**\r\n * Contains all entity metadata.\r\n */\r\nexport class EntityMetadata {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Used to wrap lazy relations.\r\n     */\r\n    lazyRelationsWrapper: LazyRelationsWrapper;\r\n\r\n    /**\r\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\r\n     */\r\n    closureJunctionTable: EntityMetadata;\r\n\r\n    /**\r\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\r\n     */\r\n    parentClosureEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Parent's entity metadata. Used in inheritance patterns.\r\n     */\r\n    parentEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Children entity metadatas. Used in inheritance patterns.\r\n     */\r\n    childEntityMetadatas: EntityMetadata[] = [];\r\n\r\n    /**\r\n     * Table type. Tables can be abstract, closure, junction, embedded, etc.\r\n     */\r\n    tableType: TableType = \"regular\";\r\n\r\n    /**\r\n     * Target class to which this entity metadata is bind.\r\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\r\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\r\n     */\r\n    target: Function|string;\r\n\r\n    /**\r\n     * Indicates if this entity metadata of a junction table, or not.\r\n     * Junction table is a table created by many-to-many relationship.\r\n     *\r\n     * Its also possible to understand if entity is junction via tableType.\r\n     */\r\n    isJunction: boolean = false;\r\n\r\n    /**\r\n     * Entity's name.\r\n     * Equal to entity target class's name if target is set to table.\r\n     * If target class is not then then it equals to table name.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Gets the name of the target.\r\n     */\r\n    targetName: string;\r\n\r\n    /**\r\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\r\n     * If user haven't specified a table name this property will be undefined.\r\n     */\r\n    givenTableName?: string;\r\n\r\n    /**\r\n     * Entity table name in the database.\r\n     * This is final table name of the entity.\r\n     * This name already passed naming strategy, and generated based on\r\n     * multiple criteria, including user table name and global table prefix.\r\n     */\r\n    tableName: string;\r\n\r\n    /**\r\n     * Gets the table name without global table prefix.\r\n     * When querying table you need a table name with prefix, but in some scenarios,\r\n     * for example when you want to name a junction table that contains names of two other tables,\r\n     * you may want a table name without prefix.\r\n     */\r\n    tableNameWithoutPrefix: string;\r\n\r\n    /**\r\n     * Indicates if schema sync is skipped for this entity.\r\n     */\r\n    skipSchemaSync: boolean;\r\n\r\n    /**\r\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\r\n     */\r\n    engine?: string;\r\n\r\n    /**\r\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\r\n     */\r\n    orderBy?: OrderByCondition;\r\n\r\n    /**\r\n     * Entity's column metadatas defined by user.\r\n     */\r\n    ownColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's relation metadatas.\r\n     */\r\n    ownRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\r\n     */\r\n    relations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\r\n     */\r\n    columns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationIds: RelationIdMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationCounts: RelationCountMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's index metadatas.\r\n     */\r\n    indices: IndexMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's foreign key metadatas.\r\n     */\r\n    foreignKeys: ForeignKeyMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's embedded metadatas.\r\n     */\r\n    embeddeds: EmbeddedMetadata[] = [];\r\n\r\n    /**\r\n     * Entity listener metadatas.\r\n     */\r\n    listeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * If this entity metadata's table using one of the inheritance patterns,\r\n     * then this will contain what pattern it uses.\r\n     */\r\n    inheritanceType?: \"single-table\"|\"class-table\";\r\n\r\n    /**\r\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\r\n     * Used to store a value in a discriminator column.\r\n     */\r\n    discriminatorValue?: string;\r\n\r\n    /**\r\n     * Checks if entity's table has multiple primary columns.\r\n     */\r\n    hasMultiplePrimaryKeys: boolean;\r\n\r\n    /**\r\n     * Gets the column with generated flag.\r\n     */\r\n    generatedColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets the object id column used with mongodb database.\r\n     */\r\n    objectIdColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains a create date value.\r\n     */\r\n    createDateColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains an update date value.\r\n     */\r\n    updateDateColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains an entity version.\r\n     */\r\n    versionColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\r\n     */\r\n    discriminatorColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Special column that stores tree level in tree entities.\r\n     */\r\n    treeLevelColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets the primary columns.\r\n     */\r\n    primaryColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Id columns in the parent table (used in table inheritance).\r\n     */\r\n    parentIdColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only one-to-one relations of the entity.\r\n     */\r\n    oneToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner one-to-one relations of the entity.\r\n     */\r\n    ownerOneToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only one-to-many relations of the entity.\r\n     */\r\n    oneToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only many-to-one relations of the entity.\r\n     */\r\n    manyToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only many-to-many relations of the entity.\r\n     */\r\n    manyToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner many-to-many relations of the entity.\r\n     */\r\n    ownerManyToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner one-to-one and many-to-one relations.\r\n     */\r\n    relationsWithJoinColumns: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Tree parent relation. Used only in tree-tables.\r\n     */\r\n    treeParentRelation?: RelationMetadata;\r\n\r\n    /**\r\n     * Tree children relation. Used only in tree-tables.\r\n     */\r\n    treeChildrenRelation?: RelationMetadata;\r\n\r\n    /**\r\n     * Checks if there any non-nullable column exist in this entity.\r\n     */\r\n    hasNonNullableRelations: boolean;\r\n\r\n    /**\r\n     * Checks if this table is regular.\r\n     * All non-specific tables are just regular tables. Its a default table type.\r\n     */\r\n    isRegular: boolean;\r\n\r\n    /**\r\n     * Checks if this table is abstract.\r\n     * This type is for the tables that does not exist in the database,\r\n     * but provide columns and relations for the tables of the child classes who inherit them.\r\n     */\r\n    isAbstract: boolean;\r\n\r\n    /**\r\n     * Checks if this table is a closure table.\r\n     * Closure table is one of the tree-specific tables that supports closure database pattern.\r\n     */\r\n    isClosure: boolean;\r\n\r\n    /**\r\n     * Checks if this table is a junction table of the closure table.\r\n     * This type is for tables that contain junction metadata of the closure tables.\r\n     */\r\n    isClosureJunction: boolean;\r\n\r\n    /**\r\n     * Checks if this table is an embeddable table.\r\n     * Embeddable tables are not stored in the database as separate tables.\r\n     * Instead their columns are embed into tables who owns them.\r\n     */\r\n    isEmbeddable: boolean;\r\n\r\n    /**\r\n     * Checks if this table is a single table child.\r\n     * Special table type for tables that are mapped into single table using Single Table Inheritance pattern.\r\n     */\r\n    isSingleTableChild: boolean;\r\n\r\n    /**\r\n     * Checks if this table is a class table child.\r\n     * Special table type for tables that are mapped into multiple tables using Class Table Inheritance pattern.\r\n     */\r\n    isClassTableChild: boolean;\r\n\r\n    /**\r\n     * Map of columns and relations of the entity.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    propertiesMap: ObjectLiteral;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(options: {\r\n        connection: Connection,\r\n        parentClosureEntityMetadata?: EntityMetadata,\r\n        args: TableMetadataArgs\r\n    }) {\r\n        const namingStrategy = options.connection.driver.namingStrategy;\r\n        const tablesPrefix = options.connection.driver.options.tablesPrefix;\r\n        this.lazyRelationsWrapper = options.connection.driver.lazyRelationsWrapper;\r\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!;\r\n        this.target = options.args.target;\r\n        this.tableType = options.args.type;\r\n        this.engine = options.args.engine;\r\n        this.givenTableName = options.args.name;\r\n        this.skipSchemaSync = options.args.skipSchemaSync || false;\r\n        this.targetName = options.args.target instanceof Function ? (options.args.target as any).name : options.args.target;\r\n        this.tableNameWithoutPrefix = this.tableType === \"closure-junction\" ? namingStrategy.closureJunctionTableName(this.givenTableName!) : namingStrategy.tableName(this.targetName, this.givenTableName);\r\n        this.tableName = tablesPrefix ? namingStrategy.prefixTableName(tablesPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\r\n        this.target = this.target ? this.target : this.tableName;\r\n        this.name = this.targetName ? this.targetName : this.tableName;\r\n\r\n        this.isClassTableChild = this.tableType === \"class-table-child\";\r\n        this.isSingleTableChild = this.tableType === \"single-table-child\";\r\n        this.isEmbeddable = this.tableType === \"embeddable\";\r\n        this.isJunction = this.tableType === \"closure-junction\" || this.tableType === \"junction\";\r\n        this.isClosureJunction = this.tableType === \"closure-junction\";\r\n        this.isClosure = this.tableType === \"closure\";\r\n        this.isAbstract = this.tableType === \"abstract\";\r\n        this.isRegular = this.tableType === \"regular\";\r\n        this.orderBy = (options.args.orderBy instanceof Function) ? options.args.orderBy(this.propertiesMap) : options.args.orderBy;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a new entity.\r\n     */\r\n    create(): any {\r\n\r\n        // if target is set to a function (e.g. class) that can be created then create it\r\n        if (this.target instanceof Function)\r\n            return new (<any> this.target)();\r\n\r\n        // otherwise simply return a new empty object\r\n        const newObject = {};\r\n        this.relations\r\n            .filter(relation => relation.isLazy)\r\n            .forEach(relation => this.lazyRelationsWrapper.wrap(newObject, relation));\r\n\r\n        return newObject;\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity has an id.\r\n     */\r\n    hasId(entity: ObjectLiteral): boolean {\r\n        if (!entity)\r\n            return false;\r\n\r\n        return this.primaryColumns.every(primaryColumn => { /// todo: this.metadata.parentEntityMetadata ?\r\n            const value = primaryColumn.getEntityValue(entity);\r\n            return value !== null && value !== undefined && value !== \"\";\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compares ids of the two entities.\r\n     * Returns true if they match, false otherwise.\r\n     */\r\n    compareIds(firstId: ObjectLiteral|undefined, secondId: ObjectLiteral|undefined): boolean {\r\n        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)\r\n            return false;\r\n\r\n        return OrmUtils.deepCompare(firstId, secondId);\r\n    }\r\n\r\n    /**\r\n     * Compares two different entity instances by their ids.\r\n     * Returns true if they match, false otherwise.\r\n     */\r\n    compareEntities(firstEntity: ObjectLiteral, secondEntity: ObjectLiteral): boolean {\r\n\r\n        // if any entity ids are empty then they aren't equal\r\n        const isFirstEntityEmpty = this.isEntityMapEmpty(firstEntity);\r\n        const isSecondEntityEmpty = this.isEntityMapEmpty(secondEntity);\r\n        if (isFirstEntityEmpty || isSecondEntityEmpty)\r\n            return false;\r\n\r\n        const firstEntityIds = this.getEntityIdMap(firstEntity);\r\n        const secondEntityIds = this.getEntityIdMap(secondEntity);\r\n        return this.compareIds(firstEntityIds, secondEntityIds);\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given name.\r\n     */\r\n    findRelationWithDbName(dbName: string): RelationMetadata|undefined {\r\n        return this.relationsWithJoinColumns.find(relation => {\r\n            return !!relation.joinColumns.find(column => column.databaseName === dbName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given property path.\r\n     */\r\n    findRelationWithPropertyPath(propertyPath: string): RelationMetadata|undefined {\r\n        return this.relations.find(relation => relation.propertyPath === propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Computes property name of the entity using given PropertyTypeInFunction.\r\n     */\r\n    computePropertyPath(nameOrFn: PropertyTypeFactory<any>) {\r\n        return typeof nameOrFn === \"string\" ? nameOrFn : nameOrFn(this.propertiesMap);\r\n    }\r\n\r\n    /**\r\n     * Creates entity id map from the given entity ids array.\r\n     */\r\n    createEntityIdMap(ids: any[]) {\r\n        const primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;\r\n        return primaryColumns.reduce((map, column, index) => Object.assign(map, column.createValueMap(ids[index])), {});\r\n    }\r\n\r\n    /**\r\n     * Checks each id in the given entity id map if they all aren't empty.\r\n     * If they all aren't empty it returns true.\r\n     * If at least one id in the given map is empty it returns false.\r\n     */\r\n    isEntityMapEmpty(entity: ObjectLiteral): boolean {\r\n        const primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;\r\n        return !primaryColumns.every(column => {\r\n            const value = column.getEntityValue(entity);\r\n            return value !== null && value !== undefined;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets primary keys of the entity and returns them in a literal object.\r\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\r\n     * For multiple primary keys it returns multiple keys in object.\r\n     * For primary keys inside embeds it returns complex object literal with keys in them.\r\n     */\r\n    getEntityIdMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\r\n        if (!entity) // todo: shall it accept an empty entity? try to remove this\r\n            return undefined;\r\n\r\n        const primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;\r\n        const map = primaryColumns.reduce((map, column) => {\r\n            if (column.isObjectId)\r\n                return Object.assign(map, column.getEntityValueMap(entity));\r\n\r\n            return OrmUtils.mergeDeep(map, column.getEntityValueMap(entity));\r\n        }, {});\r\n        return Object.keys(map).length > 0 ? map : undefined;\r\n    }\r\n\r\n    /**\r\n     * Same as getEntityIdMap, but instead of id column property names it returns database column names.\r\n     */\r\n    getDatabaseEntityIdMap(entity: ObjectLiteral): ObjectLiteral|undefined {\r\n        const map: ObjectLiteral = {};\r\n        const primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;\r\n        primaryColumns.forEach(column => {\r\n            const entityValue = column.getEntityValue(entity);\r\n            if (entityValue === null || entityValue === undefined)\r\n                return;\r\n\r\n            map[column.databaseName] = entityValue;\r\n        });\r\n        const hasAllIds = Object.keys(map).every(key => {\r\n            return map[key] !== undefined && map[key] !== null;\r\n        });\r\n        return hasAllIds ? map : undefined;\r\n    }\r\n\r\n    /**\r\n     * Creates a \"mixed id map\".\r\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\r\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\r\n     * This is called mixed id map.\r\n     */\r\n    getEntityIdMixedMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\r\n        if (!entity) // todo: undefined entities should not go there??\r\n            return undefined;\r\n\r\n        const idMap = this.getEntityIdMap(entity);\r\n        if (this.hasMultiplePrimaryKeys) {\r\n            return idMap;\r\n        } else if (idMap) {\r\n            return idMap[this.primaryColumns[0].propertyName]; // todo: what about parent primary column?\r\n        }\r\n\r\n        return idMap;\r\n    }\r\n\r\n    /**\r\n     * Checks if given object contains ALL primary keys entity must have.\r\n     * Returns true if it contains all of them, false if at least one of them is not defined.\r\n     */\r\n    checkIfObjectContainsAllPrimaryKeys(object: ObjectLiteral) {\r\n        return this.primaryColumns.every(primaryColumn => {\r\n            return object.hasOwnProperty(primaryColumn.propertyName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Iterates throw entity and finds and extracts all values from relations in the entity.\r\n     * If relation value is an array its being flattened.\r\n     */\r\n    extractRelationValuesFromEntity(entity: ObjectLiteral, relations: RelationMetadata[]): [RelationMetadata, any, EntityMetadata][] {\r\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = [];\r\n        relations.forEach(relation => {\r\n            const value = relation.getEntityValue(entity);\r\n            if (value instanceof Array) {\r\n                value.forEach(subValue => relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]));\r\n            } else if (value) {\r\n                relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);\r\n            }\r\n        });\r\n        return relationsAndValues;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Builder Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Registers a new column in the entity and recomputes all depend properties.\r\n     */\r\n    registerColumn(column: ColumnMetadata) {\r\n        this.ownColumns.push(column);\r\n        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\r\n        this.parentIdColumns = this.columns.filter(column => column.isParentId);\r\n        this.primaryColumns = this.columns.filter(column => column.isPrimary);\r\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\r\n        this.propertiesMap = this.createPropertiesMap();\r\n    }\r\n\r\n    /**\r\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\r\n     * in a special format - { propertyName: propertyName }.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    createPropertiesMap(): { [name: string]: string|any } {\r\n        const map: { [name: string]: string|any } = {};\r\n        this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\r\n        this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\r\n        return map;\r\n    }\r\n\r\n}"],"sourceRoot":".."}