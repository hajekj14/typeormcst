{"version":3,"sources":["../../src/metadata/EntityMetadata.ts"],"names":[],"mappings":";;AAIA,uDAAoD;AAQpD,uKAAuK;AAEvK;;GAEG;AACH;IAuFI,4EAA4E;IAC5E,cAAc;IACd,4EAA4E;IAE5E,wBAAY,IAAwB,EAChB,oBAA0C;QAD9D,iBA6BC;QA5BmB,yBAAoB,GAApB,oBAAoB,CAAsB;QAzC9D;;WAEG;QACM,gBAAW,GAAyB,EAAE,CAAC;QAuC5C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC;QAChC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC;QAC3C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC;QAC9C,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,cAAc,IAAI,EAAE,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,mBAAmB,IAAI,EAAE,CAAC;QAClD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB,IAAI,EAAE,CAAC;QAC9C,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,CAAC;QAClD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC;QAE5C,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC;QACjC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,cAAc,GAAG,KAAI,EAA5B,CAA4B,CAAC,CAAC;QAC9D,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,cAAc,GAAG,KAAI,EAA9B,CAA8B,CAAC,CAAC;QACnE,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,UAAA,UAAU,IAAI,OAAA,UAAU,CAAC,cAAc,GAAG,KAAI,EAAhC,CAAgC,CAAC,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,cAAc,GAAG,KAAI,EAA3B,CAA2B,CAAC,CAAC;QAE3D,IAAM,oCAAoC,GAAG,UAAC,SAA6B;YACvE,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;gBACtB,QAAQ,CAAC,cAAc,GAAG,KAAI,CAAC;gBAC/B,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,cAAc,GAAG,KAAI,EAA5B,CAA4B,CAAC,CAAC;gBACjE,oCAAoC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;YAC7D,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QACF,oCAAoC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACzD,CAAC;IASD,sBAAI,gCAAI;QAPR,4EAA4E;QAC5E,YAAY;QACZ,4EAA4E;QAE5E;;WAEG;aACH;YACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,6CAA6C,CAAC,CAAC;YAEnE,MAAM,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAC/D,CAAC;;;OAAA;IAMD,sBAAI,mCAAO;QAJX;;;WAGG;aACH;YACI,IAAI,UAAU,GAAsB,EAAuB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClF,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;gBAC3B,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YACrD,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,UAAU,CAAC;QACtB,CAAC;;;OAAA;IAKD,sBAAI,mDAAuB;QAH3B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;;;OAAA;IAMD,sBAAI,sCAAU;QAJd;;;WAGG;aACH;YACI,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC3B,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC;gBAC1B,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;YAEhE,MAAM,CAAC,OAAO,CAAC;QACnB,CAAC;;;OAAA;IAKD,sBAAI,wCAAY;QAHhB;;WAEG;aACH;YACI,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;YAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC;gBAC1B,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;YAEtE,MAAM,CAAC,SAAS,CAAC;QACrB,CAAC;;;OAAA;IAKD,sBAAI,sCAAU;QAHd;;WAEG;aACH;YACI,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,MAAM,KAAK,QAAQ,CAAC;gBAChC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAEvB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,YAAY,QAAQ,CAAC;gBAChC,MAAM,CAAQ,IAAI,CAAC,MAAO,CAAC,IAAI,CAAC;YAEpC,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;;;OAAA;IAKD,sBAAI,kDAAsB;QAH1B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;QAC1C,CAAC;;;OAAA;IAOD,sBAAI,yCAAa;QALjB;;;;WAIG;aACH;YACI,IAAM,UAAU,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBACZ,MAAM,IAAI,KAAK,CAAC,oCAAkC,IAAI,CAAC,IAAI,aAAU,CAAC,CAAC;YAE3E,MAAM,CAAC,UAAU,CAAC;QACtB,CAAC;;;OAAA;IAKD,sBAAI,8CAAkB;QAHtB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC;QACzC,CAAC;;;OAAA;IAKD,sBAAI,2CAAe;QAHnB;;WAEG;aACH;YACI,IAAM,eAAe,GAAG,IAAI,CAAC,sBAAsB,CAAC;YACpD,EAAE,CAAC,CAAC,CAAC,eAAe,CAAC;gBACjB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;YAEtD,MAAM,CAAC,eAAe,CAAC;QAC3B,CAAC;;;OAAA;IAKD,sBAAI,kDAAsB;QAH1B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,WAAW,EAAlB,CAAkB,CAAC,CAAC;QAC5D,CAAC;;;OAAA;IAMD,sBAAI,8CAAkB;QAJtB;;;WAGG;aACH;YACI,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC;gBAC5B,MAAM,IAAI,KAAK,CAAC,YAAU,IAAI,CAAC,IAAI,uGAAoG,CAAC,CAAC;YAE7I,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;QAClC,CAAC;;;OAAA;IAKD,sBAAI,0CAAc;QAHlB;;WAEG;aACH;YACI,mFAAmF;YACnF,0FAA0F;YAC1F,oEAAoE;YACpE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,SAAS,EAAhB,CAAgB,CAAC,CAAC;YACxD,mFAAmF;YACnF,gHAAgH;YAChH,oEAAoE;QACxE,CAAC;;;OAAA;IAED,sBAAI,6DAAiC;aAArC;YACI,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAC5D,CAAC;;;OAAA;IAKD,sBAAI,6CAAiB;QAHrB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;QACjE,CAAC;;;OAAA;IAMD,sBAAI,gDAAoB;QAJxB;;;WAGG;aACH;YACI,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,cAAc,CAAC;YAEpD,MAAM,CAAC,EAAE,CAAC;QACd,CAAC;;;OAAA;IAKD,sBAAI,4CAAgB;QAHpB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,SAAS,EAAhB,CAAgB,CAAC,CAAC;QAC5D,CAAC;;;OAAA;IAKD,sBAAI,+CAAmB;QAHvB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,YAAY,EAA5B,CAA4B,CAAC,CAAC;QACxE,CAAC;;;OAAA;IAKD,sBAAI,4CAAgB;QAHpB;;WAEG;aACH;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,YAAY,EAA5B,CAA4B,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,8CAA4C,IAAI,CAAC,IAAM,CAAC,CAAC;YAE7E,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,+CAAmB;QAHvB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,YAAY,EAA5B,CAA4B,CAAC,CAAC;QACxE,CAAC;;;OAAA;IAKD,sBAAI,4CAAgB;QAHpB;;WAEG;aACH;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,YAAY,EAA5B,CAA4B,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,8CAA4C,IAAI,CAAC,IAAM,CAAC,CAAC;YAE7E,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,4CAAgB;QAHpB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,SAAS,EAAzB,CAAyB,CAAC,CAAC;QACrE,CAAC;;;OAAA;IAKD,sBAAI,yCAAa;QAHjB;;WAEG;aACH;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,SAAS,EAAzB,CAAyB,CAAC,CAAC;YACvE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,2CAAyC,IAAI,CAAC,IAAM,CAAC,CAAC;YAE1E,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,kDAAsB;QAH1B;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,eAAe,EAA/B,CAA+B,CAAC,CAAC;QAC3E,CAAC;;;OAAA;IAKD,sBAAI,+CAAmB;QAHvB;;WAEG;aACH;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,eAAe,EAA/B,CAA+B,CAAC,CAAC;YAC7E,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,iDAA+C,IAAI,CAAC,IAAM,CAAC,CAAC;YAEhF,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,8CAAkB;QAHtB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,WAAW,EAA3B,CAA2B,CAAC,CAAC;QACvE,CAAC;;;OAAA;IAED,sBAAI,2CAAe;aAAnB;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,WAAW,EAA3B,CAA2B,CAAC,CAAC;YACzE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,6CAA2C,IAAI,CAAC,IAAM,CAAC,CAAC;YAE5E,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,6CAAiB;QAHrB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,CAAC;QACtE,CAAC;;;OAAA;IAED,sBAAI,0CAAc;aAAlB;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,CAAC;YACxE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,8CAA4C,IAAI,CAAC,IAAM,CAAC,CAAC;YAE7E,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAED,sBAAI,2CAAe;aAAnB;YACI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,CAAC;QACtE,CAAC;;;OAAA;IAKD,sBAAI,6CAAiB;QAHrB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,CAAC;QACtE,CAAC;;;OAAA;IAKD,sBAAI,0CAAc;QAHlB;;WAEG;aACH;YACI,IAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,IAAI,KAAK,UAAU,EAA1B,CAA0B,CAAC,CAAC;YACxE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBACR,MAAM,IAAI,KAAK,CAAC,sCAAoC,IAAI,CAAC,IAAM,CAAC,CAAC;YAErE,MAAM,CAAC,MAAM,CAAC;QAClB,CAAC;;;OAAA;IAKD,sBAAI,gDAAoB;QAHxB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;gBACjC,MAAM,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;YACrH,CAAC,CAAC,CAAC;QACP,CAAC;;;OAAA;IAKD,sBAAI,+CAAmB;QAHvB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;gBACjC,MAAM,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;YACrH,CAAC,CAAC,CAAC;QACP,CAAC;;;OAAA;IAKD,sBAAI,6CAAiB;QAHrB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,EAAlD,CAAkD,CAAC,CAAC;QACjG,CAAC;;;OAAA;IAKD,sBAAI,kDAAsB;QAH1B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,IAAI,QAAQ,CAAC,QAAQ,EAAvE,CAAuE,CAAC,CAAC;QACtH,CAAC;;;OAAA;IAKD,sBAAI,8CAAkB;QAHtB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,EAAnD,CAAmD,CAAC,CAAC;QAClG,CAAC;;;OAAA;IAKD,sBAAI,8CAAkB;QAHtB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,EAAnD,CAAmD,CAAC,CAAC;QAClG,CAAC;;;OAAA;IAKD,sBAAI,+CAAmB;QAHvB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,YAAY,EAApD,CAAoD,CAAC,CAAC;QACnG,CAAC;;;OAAA;IAKD,sBAAI,oDAAwB;QAH5B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,YAAY,IAAI,QAAQ,CAAC,QAAQ,EAAzE,CAAyE,CAAC,CAAC;QACxH,CAAC;;;OAAA;IAKD,sBAAI,oDAAwB;QAH5B;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;QACvE,CAAC;;;OAAA;IAKD,sBAAI,iDAAqB;QAHzB;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,EAArB,CAAqB,CAAC,CAAC;QACpE,CAAC;;;OAAA;IAKD,sBAAI,8CAAkB;QAHtB;;WAEG;aACH;YACI,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,EAArB,CAAqB,CAAC,CAAC;YACxE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,iDAA+C,IAAI,CAAC,IAAM,CAAC,CAAC;YAEhF,MAAM,CAAC,QAAQ,CAAC;QACpB,CAAC;;;OAAA;IAKD,sBAAI,mDAAuB;QAH3B;;WAEG;aACH;YACI,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,cAAc,EAAvB,CAAuB,CAAC,CAAC;QACtE,CAAC;;;OAAA;IAKD,sBAAI,gDAAoB;QAHxB;;WAEG;aACH;YACI,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,cAAc,EAAvB,CAAuB,CAAC,CAAC;YAC1E,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;gBACV,MAAM,IAAI,KAAK,CAAC,iDAA+C,IAAI,CAAC,IAAM,CAAC,CAAC;YAEhF,MAAM,CAAC,QAAQ,CAAC;QACpB,CAAC;;;OAAA;IAED,4EAA4E;IAC5E,iBAAiB;IACjB,4EAA4E;IAE5E;;OAEG;IACH,+BAAM,GAAN;QAAA,iBAaC;QAXG,iFAAiF;QACjF,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,YAAY,QAAQ,CAAC;YAChC,MAAM,CAAC,IAAW,IAAI,CAAC,MAAO,EAAE,CAAC;QAErC,6CAA6C;QAC7C,IAAM,SAAS,GAAG,EAAE,CAAC;QACrB,IAAI,CAAC,SAAS;aACT,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,MAAM,EAAf,CAAe,CAAC;aACnC,OAAO,CAAC,UAAA,QAAQ,IAAI,OAAA,KAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAnD,CAAmD,CAAC,CAAC;QAE9E,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;IAED;;OAEG;IACH,4CAAmB,GAAnB;QACI,IAAM,MAAM,GAAmC,EAAE,CAAC;QAClD,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,YAAY,EAAjD,CAAiD,CAAC,CAAC;QACnF,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ,IAAI,OAAA,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,QAAQ,CAAC,YAAY,EAArD,CAAqD,CAAC,CAAC;QAC1F,MAAM,CAAC,MAAM,CAAC;IAClB,CAAC;IAED;;OAEG;IACH,4CAAmB,GAAnB,UAAoB,QAAqC;QACrD,MAAM,CAAC,OAAO,QAAQ,KAAK,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC,CAAC;IAC1F,CAAC;IAED;;OAEG;IACH,uCAAc,GAAd,UAAe,MAAW;QAA1B,iBA0CC;QAzCG,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;YACR,MAAM,CAAC,SAAS,CAAC;QAErB,IAAM,GAAG,GAAkB,EAAE,CAAC;QAC9B,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,iCAAiC,CAAC,OAAO,CAAC,UAAA,MAAM;gBACjD,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,CAAC;oBAClD,MAAM,CAAC;gBAEX,gFAAgF;gBAChF,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,MAAM,CAAC,YAAY,EAA7C,CAA6C,CAAC,CAAC;gBAEtG,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC9C,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBACpG,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrE,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBACpH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC;gBAC3C,CAAC;YACL,CAAC,CAAC,CAAC;QAEP,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,UAAA,MAAM;gBAC9B,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,CAAC;oBAClD,MAAM,CAAC;gBAEX,gFAAgF;gBAChF,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,MAAM,CAAC,YAAY,EAA7C,CAA6C,CAAC,CAAC;gBAEtG,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC9C,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBACpG,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrE,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBACpH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,GAAG,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,WAAW,CAAC;gBAC3C,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;QACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,SAAS,CAAC;IACzD,CAAC;IAED;;OAEG;IACH,+CAAsB,GAAtB,UAAuB,MAAqB;QAA5C,iBA0CC;QAzCG,IAAM,GAAG,GAAkB,EAAE,CAAC;QAC9B,EAAE,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,iCAAiC,CAAC,OAAO,CAAC,UAAA,MAAM;gBACjD,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,CAAC;oBAClD,MAAM,CAAC;gBAEX,gFAAgF;gBAChF,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,MAAM,CAAC,YAAY,EAA7C,CAA6C,CAAC,CAAC;gBAEtG,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC9C,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAChG,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrE,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAChH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC;gBACvC,CAAC;YACL,CAAC,CAAC,CAAC;QAEP,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,UAAA,MAAM;gBAC9B,IAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,SAAS,CAAC;oBAClD,MAAM,CAAC;gBAEX,gFAAgF;gBAChF,IAAM,cAAc,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,MAAM,CAAC,YAAY,EAA7C,CAA6C,CAAC,CAAC;gBAEtG,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC9C,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAChG,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC,CAAC;oBACrE,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAChH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAC;gBACvC,CAAC;YACL,CAAC,CAAC,CAAC;QACP,CAAC;QACD,IAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,UAAA,GAAG;YACxC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC;QACvD,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,SAAS,GAAG,GAAG,GAAG,SAAS,CAAC;IACvC,CAAC;IAED;;;;;;;;;;;;;;;QAeI;IAEJ;;;;;;;;;;;;;;;;OAgBG;IAEH;;;OAGG;IACH,4CAAmB,GAAnB,UAAoB,MAAW;QAC3B,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;YACR,MAAM,CAAC,SAAS,CAAC;QAErB,IAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;QAC1C,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAC9B,MAAM,CAAC,KAAK,CAAC;QAEjB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC,CAAC,0CAA0C;QAClG,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACjB,CAAC;IAED;;OAEG;IACH,6CAAoB,GAApB,UAAqB,MAAW;QAC5B,MAAM,CAAC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;IACzE,CAAC;IAED,oDAA2B,GAA3B,UAA4B,KAA8B;QAA1D,iBAYC;QAXG,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACT,MAAM,CAAC,KAAK,CAAC;QACjB,CAAC;QACD,IAAM,GAAG,GAAkB,EAAE,CAAC;QAC9B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,UAAA,YAAY;YACnC,IAAM,MAAM,GAAG,KAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,CAAC;YAC1D,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,YAAY,CAAC,CAAC;YAC/C,CAAC;QACL,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,GAAG,CAAC;IACf,CAAC;IAED,gDAAuB,GAAvB,UAAwB,YAAoB;QACxC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,YAAY,KAAK,YAAY,EAApC,CAAoC,CAAC,CAAC;IAC9E,CAAC;IAED;;OAEG;IACH,kDAAyB,GAAzB,UAA0B,YAAoB;QAC1C,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,YAAY,KAAK,YAAY,EAApC,CAAoC,CAAC,CAAC;IAChF,CAAC;IAED;;OAEG;IACH,4CAAmB,GAAnB,UAAoB,IAAY;QAC5B,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,QAAQ,KAAK,IAAI,EAAxB,CAAwB,CAAC,CAAC;IACpE,CAAC;IAED;;OAEG;IACH,oDAA2B,GAA3B,UAA4B,YAAoB;QAC5C,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,YAAY,EAAtC,CAAsC,CAAC,CAAC;IACrF,CAAC;IAED;;OAEG;IACH,qDAA4B,GAA5B,UAA6B,YAAoB;QAC7C,IAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,KAAK,YAAY,EAAtC,CAAsC,CAAC,CAAC;QACzF,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;YACV,MAAM,IAAI,KAAK,CAAC,iCAA+B,YAAY,YAAO,IAAI,CAAC,IAAI,2BAAwB,CAAC,CAAC;QAEzG,MAAM,CAAC,QAAQ,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,8CAAqB,GAArB,UAAsB,MAAc;QAChC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,IAAI,KAAK,MAAM,EAAxB,CAAwB,CAAC,CAAC;IACtF,CAAC;IAED;;OAEG;IACH,+CAAsB,GAAtB,UAAuB,IAAY;QAC/B,IAAM,QAAQ,GAAG,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,IAAI,KAAK,IAAI,EAAtB,CAAsB,CAAC,CAAC;QACxF,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC;YACV,MAAM,IAAI,KAAK,CAAC,wBAAsB,IAAI,YAAO,IAAI,CAAC,IAAI,2BAAwB,CAAC,CAAC;QAExF,MAAM,CAAC,QAAQ,CAAC;IACpB,CAAC;IAED,kCAAS,GAAT,UAAU,MAAsB;QAC5B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3B,MAAM,CAAC,cAAc,GAAG,IAAI,CAAC;IACjC,CAAC;IAED,+CAAsB,GAAtB,UAAuB,MAAqB;QACxC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,EAA7B,CAA6B,CAAC,CAAC;IACxE,CAAC;IAED,4DAAmC,GAAnC,UAAoC,MAAqB;QACrD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;YACjC,MAAM,CAAC,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;mBAC3G,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;IACP,CAAC;IAED,2DAAkC,GAAlC,UAAmC,MAAqB;QACpD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;YACjC,MAAM,CAAC,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,YAAY,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;mBAC7G,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;IACP,CAAC;IAED,yDAAgC,GAAhC,UAAiC,MAAqB;QAClD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;YACjC,MAAM,CAAC,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,UAAU,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;mBAC3G,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACP,CAAC;IAED,wDAA+B,GAA/B,UAAgC,MAAqB;QACjD,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAA,QAAQ;YACjC,MAAM,CAAC,CAAC,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,YAAY,IAAI,QAAQ,CAAC,YAAY,KAAK,6BAAa,CAAC,WAAW,CAAC;mBAC7G,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QACxD,CAAC,CAAC,CAAC;IACP,CAAC;IAED,4DAAmC,GAAnC,UAAoC,MAAqB;QACrD,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,UAAA,aAAa;YAC1C,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;IACP,CAAC;IAED,wCAAe,GAAf,UAAgB,WAAgB,EAAE,YAAiB;QAC/C,IAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QACxD,IAAM,eAAe,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;QAC1D,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,eAAe,CAAC,CAAC;IAC5D,CAAC;IAED,mCAAU,GAAV,UAAW,OAAgC,EAAE,QAAiC;QAC1E,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,IAAI,OAAO,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,CAAC;YACzF,MAAM,CAAC,KAAK,CAAC;QAEjB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,UAAA,GAAG;YACjC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY,MAAM,IAAI,QAAQ,CAAC,GAAG,CAAC,YAAY,MAAM,CAAC;gBAClE,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;YAE9C,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;OAGG;IACH,8CAAqB,GAArB,UAAsB,OAAY,EAAE,QAAa;QAC7C,EAAE,CAAC,CAAC,OAAO,KAAK,SAAS,IAAI,OAAO,KAAK,IAAI,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,CAAC;YACzF,MAAM,CAAC,KAAK,CAAC;QAEjB,EAAE,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAC9B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,UAAA,GAAG;gBACjC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC1C,CAAC,CAAC,CAAC;QACP,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,MAAM,CAAC,OAAO,KAAK,QAAQ,CAAC;QAChC,CAAC;IACL,CAAC;IAED;;;OAGG;IACH,wDAA+B,GAA/B,UAAgC,MAAqB,EAAE,SAA6B;QAChF,IAAM,kBAAkB,GAA8C,EAAE,CAAC;QACzE,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;YACtB,IAAM,KAAK,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YAC9C,EAAE,CAAC,CAAC,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC;gBACzB,KAAK,CAAC,OAAO,CAAC,UAAA,QAAQ,IAAI,OAAA,kBAAkB,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,qBAAqB,CAAC,CAAC,EAA7E,CAA6E,CAAC,CAAC;YAC7G,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACf,kBAAkB,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,qBAAqB,CAAC,CAAC,CAAC;YAC/E,CAAC;QACL,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,kBAAkB,CAAC;IAC9B,CAAC;IAED;;OAEG;IACH,8BAAK,GAAL,UAAM,MAAqB;QAEvB,4CAA4C;QAC5C,0FAA0F;QAC1F,0DAA0D;QAC1D,6BAA6B;QAC7B,mDAAmD;QACnD,6CAA6C;QAC7C,kDAAkD;QAClD,yCAAyC;QACzC,UAAU;QAEV,WAAW;QACX,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,UAAA,aAAa;YAC1C,IAAM,UAAU,GAAG,aAAa,CAAC,YAAY,CAAC;YAC9C,MAAM,CAAC,CAAC,CAAC,MAAM;gBACX,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC;gBACjC,MAAM,CAAC,UAAU,CAAC,KAAK,IAAI;gBAC3B,MAAM,CAAC,UAAU,CAAC,KAAK,SAAS;gBAChC,MAAM,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QAClC,CAAC,CAAC,CAAC;QACH,IAAI;IACR,CAAC;IAKD,sBAAI,iDAAqB;QAHzB;;WAEG;aACH;YACI,MAAM,CAAC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAA,QAAQ,IAAI,OAAA,CAAC,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,SAAS,EAA1C,CAA0C,CAAC,CAAC;YAClG,oGAAoG;QACxG,CAAC;;;OAAA;IAEL,qBAAC;AAAD,CA54BA,AA44BC,IAAA;AA54BY,wCAAc","file":"EntityMetadata.js","sourcesContent":["import {TableMetadata} from \"./TableMetadata\";\r\nimport {ColumnMetadata} from \"./ColumnMetadata\";\r\nimport {RelationMetadata, PropertyTypeInFunction} from \"./RelationMetadata\";\r\nimport {IndexMetadata} from \"./IndexMetadata\";\r\nimport {RelationTypes} from \"./types/RelationTypes\";\r\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\r\nimport {NamingStrategyInterface} from \"../naming-strategy/NamingStrategyInterface\";\r\nimport {EntityMetadataArgs} from \"../metadata-args/EntityMetadataArgs\";\r\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {LazyRelationsWrapper} from \"../lazy-loading/LazyRelationsWrapper\";\r\n\r\n// todo: IDEA. store all entity metadata in the EntityMetadata too? (this will open more features for metadata objects + no need to access connection in lot of places)\r\n\r\n/**\r\n * Contains all entity metadata.\r\n */\r\nexport class EntityMetadata {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\r\n     */\r\n    closureJunctionTable: EntityMetadata;\r\n\r\n    /**\r\n     * Parent's entity metadata. Used in inheritance patterns.\r\n     */\r\n    parentEntityMetadata: EntityMetadata;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Readonly Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Naming strategy used to generate and normalize names.\r\n     */\r\n    readonly namingStrategy: NamingStrategyInterface;\r\n\r\n    /**\r\n     * Target class to which this entity metadata is bind.\r\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\r\n     */\r\n    readonly target: Function|string;\r\n\r\n    /**\r\n     * Indicates if this entity metadata of a junction table, or not.\r\n     */\r\n    readonly junction: boolean;\r\n\r\n    /**\r\n     * Entity's table metadata.\r\n     */\r\n    readonly table: TableMetadata;\r\n\r\n    /**\r\n     * Entity's relation metadatas.\r\n     */\r\n    readonly relations: RelationMetadata[];\r\n\r\n    /**\r\n     * Entity's index metadatas.\r\n     */\r\n    readonly indices: IndexMetadata[];\r\n\r\n    /**\r\n     * Entity's foreign key metadatas.\r\n     */\r\n    readonly foreignKeys: ForeignKeyMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's embedded metadatas.\r\n     */\r\n    readonly embeddeds: EmbeddedMetadata[];\r\n\r\n    /**\r\n     * If this entity metadata's table using one of the inheritance patterns,\r\n     * then this will contain what pattern it uses.\r\n     */\r\n    readonly inheritanceType?: \"single-table\"|\"class-table\";\r\n\r\n    /**\r\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\r\n     * Used to store a value in a discriminator column.\r\n     */\r\n    readonly discriminatorValue?: string;\r\n\r\n    /**\r\n     * Global tables prefix. Customer can set a global table prefix for all tables in the database.\r\n     */\r\n    readonly tablesPrefix?: string;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Entity's column metadatas.\r\n     */\r\n    private readonly _columns: ColumnMetadata[];\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(args: EntityMetadataArgs,\r\n                private lazyRelationsWrapper: LazyRelationsWrapper) {\r\n        this.target = args.target;\r\n        this.junction = args.junction;\r\n        this.tablesPrefix = args.tablesPrefix;\r\n        this.namingStrategy = args.namingStrategy;\r\n        this.table = args.tableMetadata;\r\n        this._columns = args.columnMetadatas || [];\r\n        this.relations = args.relationMetadatas || [];\r\n        this.indices = args.indexMetadatas || [];\r\n        this.foreignKeys = args.foreignKeyMetadatas || [];\r\n        this.embeddeds = args.embeddedMetadatas || [];\r\n        this.discriminatorValue = args.discriminatorValue;\r\n        this.inheritanceType = args.inheritanceType;\r\n\r\n        this.table.entityMetadata = this;\r\n        this._columns.forEach(column => column.entityMetadata = this);\r\n        this.relations.forEach(relation => relation.entityMetadata = this);\r\n        this.foreignKeys.forEach(foreignKey => foreignKey.entityMetadata = this);\r\n        this.indices.forEach(index => index.entityMetadata = this);\r\n\r\n        const setEmbeddedEntityMetadataRecursively = (embeddeds: EmbeddedMetadata[]) => {\r\n            embeddeds.forEach(embedded => {\r\n                embedded.entityMetadata = this;\r\n                embedded.columns.forEach(column => column.entityMetadata = this);\r\n                setEmbeddedEntityMetadataRecursively(embedded.embeddeds);\r\n            });\r\n        };\r\n        setEmbeddedEntityMetadataRecursively(this.embeddeds);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Accessors\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Entity's name. Equal to entity target class's name if target is set to table, or equals to table name if its set.\r\n     */\r\n    get name(): string {\r\n        if (!this.table)\r\n            throw new Error(\"No table target set to the entity metadata.\");\r\n\r\n        return this.targetName ? this.targetName : this.table.name;\r\n    }\r\n\r\n    /**\r\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\r\n     * @deprecated\r\n     */\r\n    get columns(): ColumnMetadata[] {\r\n        let allColumns: ColumnMetadata[] = ([] as ColumnMetadata[]).concat(this._columns);\r\n        this.embeddeds.forEach(embedded => {\r\n            allColumns = allColumns.concat(embedded.columns);\r\n        });\r\n        return allColumns;\r\n    }\r\n\r\n    /**\r\n     * Gets columns without embedded columns.\r\n     */\r\n    get columnsWithoutEmbeddeds(): ColumnMetadata[] {\r\n        return this._columns;\r\n    }\r\n\r\n    /**\r\n     * All columns of the entity, including columns that are coming from the embeddeds of this entity,\r\n     * and including columns from the parent entities.\r\n     */\r\n    get allColumns(): ColumnMetadata[] {\r\n        let columns = this.columns;\r\n        if (this.parentEntityMetadata)\r\n            columns = columns.concat(this.parentEntityMetadata.columns);\r\n\r\n        return columns;\r\n    }\r\n\r\n    /**\r\n     * All relations of the entity, including relations from the parent entities.\r\n     */\r\n    get allRelations(): RelationMetadata[] {\r\n        let relations = this.relations;\r\n        if (this.parentEntityMetadata)\r\n            relations = relations.concat(this.parentEntityMetadata.relations);\r\n\r\n        return relations;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the target.\r\n     */\r\n    get targetName(): string {\r\n        if (typeof this.target === \"string\")\r\n            return this.target;\r\n\r\n        if (this.target instanceof Function)\r\n            return (<any> this.target).name;\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Checks if entity's table has multiple primary columns.\r\n     */\r\n    get hasMultiplePrimaryKeys() {\r\n        return this.primaryColumns.length > 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the primary column.\r\n     *\r\n     * @deprecated\r\n     */\r\n    get primaryColumn(): ColumnMetadata {\r\n        const primaryKey = this.primaryColumns[0];\r\n        if (!primaryKey)\r\n            throw new Error(`Primary key is not set for the ${this.name} entity.`);\r\n\r\n        return primaryKey;\r\n    }\r\n\r\n    /**\r\n     * Checks if table has generated column.\r\n     */\r\n    get hasGeneratedColumn(): boolean {\r\n        return !!this.generatedColumnIfExist;\r\n    }\r\n\r\n    /**\r\n     * Gets the column with generated flag.\r\n     */\r\n    get generatedColumn(): ColumnMetadata {\r\n        const generatedColumn = this.generatedColumnIfExist;\r\n        if (!generatedColumn)\r\n            throw new Error(`Generated column was not found`);\r\n\r\n        return generatedColumn;\r\n    }\r\n\r\n    /**\r\n     * Gets the generated column if it exists, or returns undefined if it does not.\r\n     */\r\n    get generatedColumnIfExist(): ColumnMetadata|undefined {\r\n        return this._columns.find(column => column.isGenerated);\r\n    }\r\n\r\n    /**\r\n     * Gets first primary column. In the case if table contains multiple primary columns it\r\n     * throws error.\r\n     */\r\n    get firstPrimaryColumn(): ColumnMetadata {\r\n        if (this.hasMultiplePrimaryKeys)\r\n            throw new Error(`Entity ${this.name} has multiple primary keys. This operation is not supported on entities with multiple primary keys`);\r\n\r\n        return this.primaryColumns[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the primary columns.\r\n     */\r\n    get primaryColumns(): ColumnMetadata[] {\r\n        // const originalPrimaryColumns = this._columns.filter(column => column.isPrimary);\r\n        // const parentEntityPrimaryColumns = this.hasParentIdColumn ? [this.parentIdColumn] : [];\r\n        // return originalPrimaryColumns.concat(parentEntityPrimaryColumns);\r\n        return this._columns.filter(column => column.isPrimary);\r\n        // const originalPrimaryColumns = this._columns.filter(column => column.isPrimary);\r\n        // const parentEntityPrimaryColumns = this.parentEntityMetadata ? this.parentEntityMetadata.primaryColumns : [];\r\n        // return originalPrimaryColumns.concat(parentEntityPrimaryColumns);\r\n    }\r\n\r\n    get primaryColumnsWithParentIdColumns(): ColumnMetadata[] {\r\n        return this.primaryColumns.concat(this.parentIdColumns);\r\n    }\r\n\r\n    /**\r\n     * Gets all primary columns including columns from the parent entities.\r\n     */\r\n    get allPrimaryColumns(): ColumnMetadata[] {\r\n        return this.primaryColumns.concat(this.parentPrimaryColumns);\r\n    }\r\n\r\n    /**\r\n     * Gets the primary columns of the parent entity metadata.\r\n     * If parent entity metadata does not exist then it simply returns empty array.\r\n     */\r\n    get parentPrimaryColumns(): ColumnMetadata[] {\r\n        if (this.parentEntityMetadata)\r\n            return this.parentEntityMetadata.primaryColumns;\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Gets only primary columns owned by this entity.\r\n     */\r\n    get ownPimaryColumns(): ColumnMetadata[] {\r\n        return this._columns.filter(column => column.isPrimary);\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has a create date column.\r\n     */\r\n    get hasCreateDateColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"createDate\");\r\n    }\r\n\r\n    /**\r\n     * Gets entity column which contains a create date value.\r\n     */\r\n    get createDateColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"createDate\");\r\n        if (!column)\r\n            throw new Error(`CreateDateColumn was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has an update date column.\r\n     */\r\n    get hasUpdateDateColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"updateDate\");\r\n    }\r\n\r\n    /**\r\n     * Gets entity column which contains an update date value.\r\n     */\r\n    get updateDateColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"updateDate\");\r\n        if (!column)\r\n            throw new Error(`UpdateDateColumn was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has a version column.\r\n     */\r\n    get hasVersionColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"version\");\r\n    }\r\n\r\n    /**\r\n     * Gets entity column which contains an entity version.\r\n     */\r\n    get versionColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"version\");\r\n        if (!column)\r\n            throw new Error(`VersionColumn was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has a discriminator column.\r\n     */\r\n    get hasDiscriminatorColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"discriminator\");\r\n    }\r\n\r\n    /**\r\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\r\n     */\r\n    get discriminatorColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"discriminator\");\r\n        if (!column)\r\n            throw new Error(`DiscriminatorColumn was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has a tree level column.\r\n     */\r\n    get hasTreeLevelColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"treeLevel\");\r\n    }\r\n\r\n    get treeLevelColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"treeLevel\");\r\n        if (!column)\r\n            throw new Error(`TreeLevelColumn was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has a tree level column.\r\n     */\r\n    get hasParentIdColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"parentId\");\r\n    }\r\n\r\n    get parentIdColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"parentId\");\r\n        if (!column)\r\n            throw new Error(`Parent id column was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    get parentIdColumns(): ColumnMetadata[] {\r\n        return this._columns.filter(column => column.mode === \"parentId\");\r\n    }\r\n\r\n    /**\r\n     * Checks if entity has an object id column.\r\n     */\r\n    get hasObjectIdColumn(): boolean {\r\n        return !!this._columns.find(column => column.mode === \"objectId\");\r\n    }\r\n\r\n    /**\r\n     * Gets the object id column used with mongodb database.\r\n     */\r\n    get objectIdColumn(): ColumnMetadata {\r\n        const column = this._columns.find(column => column.mode === \"objectId\");\r\n        if (!column)\r\n            throw new Error(`ObjectId was not found in entity ${this.name}`);\r\n\r\n        return column;\r\n    }\r\n\r\n    /**\r\n     * Gets single (values of which does not contain arrays) relations.\r\n     */\r\n    get singleValueRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return relation.relationType === RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes.ONE_TO_MANY;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets single (values of which does not contain arrays) relations.\r\n     */\r\n    get multiValueRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return relation.relationType === RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes.ONE_TO_MANY;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets only one-to-one relations of the entity.\r\n     */\r\n    get oneToOneRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.ONE_TO_ONE);\r\n    }\r\n\r\n    /**\r\n     * Gets only owner one-to-one relations of the entity.\r\n     */\r\n    get ownerOneToOneRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.ONE_TO_ONE && relation.isOwning);\r\n    }\r\n\r\n    /**\r\n     * Gets only one-to-many relations of the entity.\r\n     */\r\n    get oneToManyRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.ONE_TO_MANY);\r\n    }\r\n\r\n    /**\r\n     * Gets only many-to-one relations of the entity.\r\n     */\r\n    get manyToOneRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.MANY_TO_ONE);\r\n    }\r\n\r\n    /**\r\n     * Gets only many-to-many relations of the entity.\r\n     */\r\n    get manyToManyRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.MANY_TO_MANY);\r\n    }\r\n\r\n    /**\r\n     * Gets only owner many-to-many relations of the entity.\r\n     */\r\n    get ownerManyToManyRelations(): RelationMetadata[] {\r\n        return this.relations.filter(relation => relation.relationType === RelationTypes.MANY_TO_MANY && relation.isOwning);\r\n    }\r\n\r\n    /**\r\n     * Gets only owner one-to-one and many-to-one relations.\r\n     */\r\n    get relationsWithJoinColumns() {\r\n        return this.ownerOneToOneRelations.concat(this.manyToOneRelations);\r\n    }\r\n\r\n    /**\r\n     * Checks if there is a tree parent relation. Used only in tree-tables.\r\n     */\r\n    get hasTreeParentRelation() {\r\n        return !!this.relations.find(relation => relation.isTreeParent);\r\n    }\r\n\r\n    /**\r\n     * Tree parent relation. Used only in tree-tables.\r\n     */\r\n    get treeParentRelation() {\r\n        const relation = this.relations.find(relation => relation.isTreeParent);\r\n        if (!relation)\r\n            throw new Error(`TreeParent relation was not found in entity ${this.name}`);\r\n\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Checks if there is a tree children relation. Used only in tree-tables.\r\n     */\r\n    get hasTreeChildrenRelation() {\r\n        return !!this.relations.find(relation => relation.isTreeChildren);\r\n    }\r\n\r\n    /**\r\n     * Tree children relation. Used only in tree-tables.\r\n     */\r\n    get treeChildrenRelation() {\r\n        const relation = this.relations.find(relation => relation.isTreeChildren);\r\n        if (!relation)\r\n            throw new Error(`TreeParent relation was not found in entity ${this.name}`);\r\n\r\n        return relation;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a new entity.\r\n     */\r\n    create(): any {\r\n\r\n        // if target is set to a function (e.g. class) that can be created then create it\r\n        if (this.target instanceof Function)\r\n            return new (<any> this.target)();\r\n\r\n        // otherwise simply return a new empty object\r\n        const newObject = {};\r\n        this.relations\r\n            .filter(relation => relation.isLazy)\r\n            .forEach(relation => this.lazyRelationsWrapper.wrap(newObject, relation));\r\n\r\n        return newObject;\r\n    }\r\n\r\n    /**\r\n     * Creates an object - map of columns and relations of the entity.\r\n     */\r\n    createPropertiesMap(): { [name: string]: string|any } {\r\n        const entity: { [name: string]: string|any } = {};\r\n        this._columns.forEach(column => entity[column.propertyName] = column.propertyName);\r\n        this.relations.forEach(relation => entity[relation.propertyName] = relation.propertyName);\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Computes property name of the entity using given PropertyTypeInFunction.\r\n     */\r\n    computePropertyName(nameOrFn: PropertyTypeInFunction<any>) {\r\n        return typeof nameOrFn === \"string\" ? nameOrFn : nameOrFn(this.createPropertiesMap());\r\n    }\r\n\r\n    /**\r\n     * todo: undefined entities should not go there\r\n     */\r\n    getEntityIdMap(entity: any): ObjectLiteral|undefined {\r\n        if (!entity)\r\n            return undefined;\r\n\r\n        const map: ObjectLiteral = {};\r\n        if (this.parentEntityMetadata) {\r\n            this.primaryColumnsWithParentIdColumns.forEach(column => {\r\n                const entityValue = entity[column.propertyName];\r\n                if (entityValue === null || entityValue === undefined)\r\n                    return;\r\n\r\n                // if entity id is a relation, then extract referenced column from that relation\r\n                const columnRelation = this.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                if (columnRelation && columnRelation.joinColumn) {\r\n                    map[column.propertyName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\r\n                } else if (columnRelation && columnRelation.inverseRelation.joinColumn) {\r\n                    map[column.propertyName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];\r\n                } else {\r\n                    map[column.propertyName] = entityValue;\r\n                }\r\n            });\r\n\r\n        } else {\r\n            this.primaryColumns.forEach(column => {\r\n                const entityValue = entity[column.propertyName];\r\n                if (entityValue === null || entityValue === undefined)\r\n                    return;\r\n\r\n                // if entity id is a relation, then extract referenced column from that relation\r\n                const columnRelation = this.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                if (columnRelation && columnRelation.joinColumn) {\r\n                    map[column.propertyName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\r\n                } else if (columnRelation && columnRelation.inverseRelation.joinColumn) {\r\n                    map[column.propertyName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];\r\n                } else {\r\n                    map[column.propertyName] = entityValue;\r\n                }\r\n            });\r\n        }\r\n        return Object.keys(map).length > 0 ? map : undefined;\r\n    }\r\n\r\n    /**\r\n     * Same as getEntityIdMap, but instead of id column property names it returns database column names.\r\n     */\r\n    getDatabaseEntityIdMap(entity: ObjectLiteral): ObjectLiteral|undefined {\r\n        const map: ObjectLiteral = {};\r\n        if (this.parentEntityMetadata) {\r\n            this.primaryColumnsWithParentIdColumns.forEach(column => {\r\n                const entityValue = entity[column.propertyName];\r\n                if (entityValue === null || entityValue === undefined)\r\n                    return;\r\n\r\n                // if entity id is a relation, then extract referenced column from that relation\r\n                const columnRelation = this.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                if (columnRelation && columnRelation.joinColumn) {\r\n                    map[column.fullName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\r\n                } else if (columnRelation && columnRelation.inverseRelation.joinColumn) {\r\n                    map[column.fullName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];\r\n                } else {\r\n                    map[column.fullName] = entityValue;\r\n                }\r\n            });\r\n\r\n        } else {\r\n            this.primaryColumns.forEach(column => {\r\n                const entityValue = entity[column.propertyName];\r\n                if (entityValue === null || entityValue === undefined)\r\n                    return;\r\n\r\n                // if entity id is a relation, then extract referenced column from that relation\r\n                const columnRelation = this.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                if (columnRelation && columnRelation.joinColumn) {\r\n                    map[column.fullName] = entityValue[columnRelation.joinColumn.referencedColumn.propertyName];\r\n                } else if (columnRelation && columnRelation.inverseRelation.joinColumn) {\r\n                    map[column.fullName] = entityValue[columnRelation.inverseRelation.joinColumn.referencedColumn.propertyName];\r\n                } else {\r\n                    map[column.fullName] = entityValue;\r\n                }\r\n            });\r\n        }\r\n        const hasAllIds = Object.keys(map).every(key => {\r\n            return map[key] !== undefined && map[key] !== null;\r\n        });\r\n        return hasAllIds ? map : undefined;\r\n    }\r\n\r\n    /**\r\n\r\n    createSimpleIdMap(id: any): ObjectLiteral {\r\n        const map: ObjectLiteral = {};\r\n        if (this.parentEntityMetadata) {\r\n            this.primaryColumnsWithParentIdColumns.forEach(column => {\r\n                map[column.propertyName] = id;\r\n            });\r\n\r\n        } else {\r\n            this.primaryColumns.forEach(column => {\r\n                map[column.propertyName] = id;\r\n            });\r\n        }\r\n        return map;\r\n    } */\r\n\r\n    /**\r\n     * Same as createSimpleIdMap, but instead of id column property names it returns database column names.\r\n\r\n    createSimpleDatabaseIdMap(id: any): ObjectLiteral {\r\n        const map: ObjectLiteral = {};\r\n        if (this.parentEntityMetadata) {\r\n            this.primaryColumnsWithParentIdColumns.forEach(column => {\r\n                map[column.name] = id;\r\n            });\r\n\r\n        } else {\r\n            this.primaryColumns.forEach(column => {\r\n                map[column.name] = id;\r\n            });\r\n        }\r\n        return map;\r\n    }*/\r\n\r\n    /**\r\n     * todo: undefined entities should not go there??\r\n     * todo: shouldnt be entity ObjectLiteral here?\r\n     */\r\n    getEntityIdMixedMap(entity: any): any {\r\n        if (!entity)\r\n            return undefined;\r\n\r\n        const idMap = this.getEntityIdMap(entity);\r\n        if (this.hasMultiplePrimaryKeys) {\r\n            return idMap;\r\n\r\n        } else if (idMap) {\r\n            return idMap[this.firstPrimaryColumn.propertyName]; // todo: what about parent primary column?\r\n        }\r\n\r\n        return idMap;\r\n    }\r\n\r\n    /**\r\n     * Same as `getEntityIdMap` but the key of the map will be the column names instead of the property names.\r\n     */\r\n    getEntityIdColumnMap(entity: any): ObjectLiteral|undefined {\r\n        return this.transformIdMapToColumnNames(this.getEntityIdMap(entity));\r\n    }\r\n\r\n    transformIdMapToColumnNames(idMap: ObjectLiteral|undefined) {\r\n        if (!idMap) {\r\n            return idMap;\r\n        }\r\n        const map: ObjectLiteral = {};\r\n        Object.keys(idMap).forEach(propertyName => {\r\n            const column = this.getColumnByPropertyName(propertyName);\r\n            if (column) {\r\n                map[column.fullName] = idMap[propertyName];\r\n            }\r\n        });\r\n        return map;\r\n    }\r\n\r\n    getColumnByPropertyName(propertyName: string) {\r\n        return this._columns.find(column => column.propertyName === propertyName);\r\n    }\r\n\r\n    /**\r\n     * Checks if column with the given property name exist.\r\n     */\r\n    hasColumnWithPropertyName(propertyName: string): boolean {\r\n        return !!this._columns.find(column => column.propertyName === propertyName);\r\n    }\r\n\r\n    /**\r\n     * Checks if column with the given database name exist.\r\n     */\r\n    hasColumnWithDbName(name: string): boolean {\r\n        return !!this._columns.find(column => column.fullName === name);\r\n    }\r\n\r\n    /**\r\n     * Checks if relation with the given property name exist.\r\n     */\r\n    hasRelationWithPropertyName(propertyName: string): boolean {\r\n        return !!this.relations.find(relation => relation.propertyName === propertyName);\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given property name.\r\n     */\r\n    findRelationWithPropertyName(propertyName: string): RelationMetadata {\r\n        const relation = this.relations.find(relation => relation.propertyName === propertyName);\r\n        if (!relation)\r\n            throw new Error(`Relation with property name ${propertyName} in ${this.name} entity was not found.`);\r\n\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Checks if relation with the given name exist.\r\n     */\r\n    hasRelationWithDbName(dbName: string): boolean {\r\n        return !!this.relationsWithJoinColumns.find(relation => relation.name === dbName);\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given name.\r\n     */\r\n    findRelationWithDbName(name: string): RelationMetadata {\r\n        const relation = this.relationsWithJoinColumns.find(relation => relation.name === name);\r\n        if (!relation)\r\n            throw new Error(`Relation with name ${name} in ${this.name} entity was not found.`);\r\n\r\n        return relation;\r\n    }\r\n\r\n    addColumn(column: ColumnMetadata) {\r\n        this._columns.push(column);\r\n        column.entityMetadata = this;\r\n    }\r\n\r\n    extractNonEmptyColumns(object: ObjectLiteral): ColumnMetadata[] {\r\n        return this.columns.filter(column => !!object[column.propertyName]);\r\n    }\r\n\r\n    extractNonEmptySingleValueRelations(object: ObjectLiteral): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return (relation.relationType === RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes.MANY_TO_ONE)\r\n                && !!object[relation.propertyName];\r\n        });\r\n    }\r\n\r\n    extractNonEmptyMultiValueRelations(object: ObjectLiteral): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return (relation.relationType === RelationTypes.MANY_TO_MANY || relation.relationType === RelationTypes.ONE_TO_MANY)\r\n                && !!object[relation.propertyName];\r\n        });\r\n    }\r\n\r\n    extractExistSingleValueRelations(object: ObjectLiteral): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return (relation.relationType === RelationTypes.ONE_TO_ONE || relation.relationType === RelationTypes.MANY_TO_ONE)\r\n                && object.hasOwnProperty(relation.propertyName);\r\n        });\r\n    }\r\n\r\n    extractExistMultiValueRelations(object: ObjectLiteral): RelationMetadata[] {\r\n        return this.relations.filter(relation => {\r\n            return (relation.relationType === RelationTypes.MANY_TO_MANY || relation.relationType === RelationTypes.ONE_TO_MANY)\r\n                && object.hasOwnProperty(relation.propertyName);\r\n        });\r\n    }\r\n\r\n    checkIfObjectContainsAllPrimaryKeys(object: ObjectLiteral) {\r\n        return this.primaryColumns.every(primaryColumn => {\r\n            return object.hasOwnProperty(primaryColumn.propertyName);\r\n        });\r\n    }\r\n\r\n    compareEntities(firstEntity: any, secondEntity: any) {\r\n        const firstEntityIds = this.getEntityIdMap(firstEntity);\r\n        const secondEntityIds = this.getEntityIdMap(secondEntity);\r\n        return this.compareIds(firstEntityIds, secondEntityIds);\r\n    }\r\n\r\n    compareIds(firstId: ObjectLiteral|undefined, secondId: ObjectLiteral|undefined): boolean {\r\n        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)\r\n            return false;\r\n\r\n        return Object.keys(firstId).every(key => {\r\n            if (firstId[key] instanceof Object && secondId[key] instanceof Object)\r\n                return firstId[key].equals(secondId[key]);\r\n\r\n            return firstId[key] === secondId[key];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compares two entity ids.\r\n     * If any of the given value is empty then it will return false.\r\n     */\r\n    compareEntityMixedIds(firstId: any, secondId: any): boolean {\r\n        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)\r\n            return false;\r\n\r\n        if (this.hasMultiplePrimaryKeys) {\r\n            return Object.keys(firstId).every(key => {\r\n                return firstId[key] === secondId[key];\r\n            });\r\n        } else {\r\n            return firstId === secondId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterates throw entity and finds and extracts all values from relations in the entity.\r\n     * If relation value is an array its being flattened.\r\n     */\r\n    extractRelationValuesFromEntity(entity: ObjectLiteral, relations: RelationMetadata[]): [RelationMetadata, any, EntityMetadata][] {\r\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = [];\r\n        relations.forEach(relation => {\r\n            const value = relation.getEntityValue(entity);\r\n            if (value instanceof Array) {\r\n                value.forEach(subValue => relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]));\r\n            } else if (value) {\r\n                relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);\r\n            }\r\n        });\r\n        return relationsAndValues;\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity has an id.\r\n     */\r\n    hasId(entity: ObjectLiteral): boolean {\r\n\r\n        // if (this.metadata.parentEntityMetadata) {\r\n        //     return this.metadata.parentEntityMetadata.parentIdColumns.every(parentIdColumn => {\r\n        //         const columnName = parentIdColumn.propertyName;\r\n        //         return !!entity &&\r\n        //             entity.hasOwnProperty(columnName) &&\r\n        //             entity[columnName] !== null &&\r\n        //             entity[columnName] !== undefined &&\r\n        //             entity[columnName] !== \"\";\r\n        //     });\r\n\r\n        // } else {\r\n        return this.primaryColumns.every(primaryColumn => {\r\n            const columnName = primaryColumn.propertyName;\r\n            return !!entity &&\r\n                entity.hasOwnProperty(columnName) &&\r\n                entity[columnName] !== null &&\r\n                entity[columnName] !== undefined &&\r\n                entity[columnName] !== \"\";\r\n        });\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Checks if there any non-nullable column exist in this entity.\r\n     */\r\n    get hasNonNullableColumns(): boolean {\r\n        return this.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\r\n        // return this.relationsWithJoinColumns.some(relation => relation.isNullable || relation.isPrimary);\r\n    }\r\n\r\n}"],"sourceRoot":".."}