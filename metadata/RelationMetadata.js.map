{"version":3,"sources":["../../src/metadata/RelationMetadata.ts"],"names":[],"mappings":"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","file":"RelationMetadata.js","sourcesContent":["import {RelationTypes, RelationType} from \"./types/RelationTypes\";\r\nimport {EntityMetadata} from \"./EntityMetadata\";\r\nimport {OnDeleteType} from \"./ForeignKeyMetadata\";\r\nimport {JoinTableMetadata} from \"./JoinTableMetadata\";\r\nimport {JoinColumnMetadata} from \"./JoinColumnMetadata\";\r\nimport {RelationMetadataArgs} from \"../metadata-args/RelationMetadataArgs\";\r\nimport {ColumnMetadata} from \"./ColumnMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\n\r\n/**\r\n * Function that returns a type of the field. Returned value must be a class used on the relation.\r\n */\r\nexport type RelationTypeInFunction = ((type?: any) => Function)|Function|string; // todo: |string ?\r\n\r\n\r\n/**\r\n * Contains the name of the property of the object, or the function that returns this name.\r\n */\r\nexport type PropertyTypeInFunction<T> = string|((t: T) => string|any);\r\n\r\n\r\n/**\r\n * Contains all information about some entity's relation.\r\n */\r\nexport class RelationMetadata {\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Its own entity metadata.\r\n     */\r\n    entityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Related entity metadata.\r\n     */\r\n    inverseEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Junction entity metadata.\r\n     */\r\n    junctionEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Join table metadata.\r\n     */\r\n    joinTable: JoinTableMetadata;\r\n\r\n    /**\r\n     * Join column metadata.\r\n     */\r\n    joinColumn: JoinColumnMetadata;\r\n\r\n    /**\r\n     * The name of the field that will contain id or ids of this relation. This is used in the case if user\r\n     * wants to save relation without having to load related object, or in the cases if user wants to have id\r\n     * of the object it relates with, but don't want to load that object because of it. Also its used in the\r\n     * cases when user wants to add / remove / load in the many-to-many junction tables.\r\n     */\r\n    idField: string|undefined;\r\n\r\n    /**\r\n     * The name of the field that will contain count of the rows of the relation.\r\n     */\r\n    countField: string|undefined;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Readonly Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Target class to which metadata is applied.\r\n     */\r\n    readonly target: Function|string;\r\n\r\n    /**\r\n     * Target's property name to which this metadata is applied.\r\n     */\r\n    readonly propertyName: string;\r\n\r\n    /**\r\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\r\n     */\r\n    readonly isTreeParent: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\r\n     */\r\n    readonly isTreeChildren: boolean = false;\r\n\r\n    /**\r\n     * Relation type.\r\n     */\r\n    readonly relationType: RelationType;\r\n\r\n    /**\r\n     * Indicates if this relation will be a primary key.\r\n     * Can be used only for many-to-one and owner one-to-one relations.\r\n     */\r\n    readonly isPrimary: boolean;\r\n\r\n    /**\r\n     * Indicates if this relation will be lazily loaded.\r\n     */\r\n    readonly isLazy: boolean;\r\n\r\n    /**\r\n     * If set to true then it means that related object can be allowed to be inserted to the db.\r\n     */\r\n    readonly isCascadeInsert: boolean;\r\n\r\n    /**\r\n     * If set to true then it means that related object can be allowed to be updated in the db.\r\n     */\r\n    readonly isCascadeUpdate: boolean;\r\n\r\n    /**\r\n     * If set to true then it means that related object can be allowed to be remove from the db.\r\n     */\r\n    readonly isCascadeRemove: boolean;\r\n\r\n    /**\r\n     * Indicates if relation column value can be nullable or not.\r\n     */\r\n    readonly isNullable: boolean = true;\r\n\r\n    /**\r\n     * What to do with a relation on deletion of the row containing a foreign key.\r\n     */\r\n    readonly onDelete: OnDeleteType;\r\n\r\n    /**\r\n     * The real reflected property type.\r\n     */\r\n    // readonly propertyType: any;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Private Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * The type of the field.\r\n     */\r\n    private _type: RelationTypeInFunction;\r\n\r\n    /**\r\n     * Inverse side of the relation.\r\n     */\r\n    private _inverseSideProperty: PropertyTypeInFunction<any>;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(args: RelationMetadataArgs) {\r\n        this.target = args.target;\r\n        this.propertyName = args.propertyName;\r\n        this.relationType = args.relationType;\r\n\r\n        if (args.inverseSideProperty)\r\n            this._inverseSideProperty = args.inverseSideProperty;\r\n        // if (args.propertyType)\r\n        //     this.propertyType = args.propertyType;\r\n        if (args.isLazy !== undefined)\r\n            this.isLazy = args.isLazy;\r\n        if (args.options.cascadeInsert || args.options.cascadeAll)\r\n            this.isCascadeInsert = true;\r\n        if (args.options.cascadeUpdate || args.options.cascadeAll)\r\n            this.isCascadeUpdate = true;\r\n        if (args.options.cascadeRemove || args.options.cascadeAll)\r\n            this.isCascadeRemove = true;\r\n        if (args.options.nullable !== undefined)\r\n            this.isNullable = args.options.nullable;\r\n        if (args.options.onDelete)\r\n            this.onDelete = args.options.onDelete;\r\n        if (args.options.primary !== undefined)\r\n            this.isPrimary = args.options.primary;\r\n        if (args.isTreeParent)\r\n            this.isTreeParent = true;\r\n        if (args.isTreeChildren)\r\n            this.isTreeChildren = true;\r\n\r\n        if (!this._type)\r\n            this._type = args.type;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Accessors\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets relation's entity target.\r\n     * Original target returns target of the class where relation is.\r\n     * This class can be an abstract class, but relation even is from that class,\r\n     * but its more related to a specific entity. That's why we need this field.\r\n     */\r\n    get entityTarget(): Function|string {\r\n        return this.entityMetadata.target;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of column in the database.\r\n     * //Cannot be used with many-to-many relations since they don't have a column in the database.\r\n     * //Also only owning sides of the relations have this property.\r\n     */\r\n    get name(): string {\r\n        // if (!this.isOwning || this.isManyToMany)\r\n\r\n        if (this.isOwning) {\r\n            if (this.joinTable) {\r\n                return this.joinTable.joinColumnName;\r\n            } else if (this.joinColumn) {\r\n                return this.joinColumn.name;\r\n            }\r\n\r\n        } else if (this.hasInverseSide) {\r\n            if (this.inverseRelation.joinTable) {\r\n                return this.inverseRelation.joinTable.inverseJoinColumnName;\r\n            } else if (this.inverseRelation.joinColumn && this.inverseRelation.joinColumn.referencedColumn) {\r\n                return this.inverseRelation.joinColumn.referencedColumn.fullName;\r\n            }\r\n        }\r\n\r\n        throw new Error(`Relation name cannot be retrieved.`);\r\n    }\r\n\r\n    /**\r\n     * Gets the name of column to which this relation is referenced.\r\n     * //Cannot be used with many-to-many relations since all referenced are in the junction table.\r\n     * //Also only owning sides of the relations have this property.\r\n     */\r\n    get referencedColumnName(): string {\r\n        // if (!this.isOwning)\r\n        //     throw new Error(`Only owning side of the relations can have information about referenced column names.`);\r\n\r\n        // for many-to-one and owner one-to-one relations we get referenced column from join column\r\n        /*if (this.joinColumn && this.joinColumn.referencedColumn && this.joinColumn.referencedColumn.name)\r\n            return this.joinColumn.referencedColumn.name;\r\n\r\n        // for many-to-many relation we give referenced column depend of owner side\r\n        if (this.joinTable) { // need to check if this algorithm works correctly\r\n            if (this.isOwning) {\r\n                return this.joinTable.referencedColumn.name;\r\n            } else {\r\n                return this.joinTable.inverseReferencedColumn.name;\r\n            }\r\n        }*/\r\n\r\n        if (this.isOwning) {\r\n            if (this.joinTable) {\r\n                return this.joinTable.referencedColumn.fullName;\r\n\r\n            } else if (this.joinColumn) {\r\n                return this.joinColumn.referencedColumn.fullName;\r\n            }\r\n\r\n        } else if (this.hasInverseSide) {\r\n            if (this.inverseRelation.joinTable) {\r\n                return this.inverseRelation.joinTable.inverseReferencedColumn.fullName;\r\n            } else if (this.inverseRelation.joinColumn) {\r\n                return this.inverseRelation.joinColumn.name; // todo: didn't get this logic here\r\n            }\r\n        }\r\n\r\n        // this should not be possible, but anyway throw error\r\n        throw new Error(`Cannot get referenced column name of the relation ${this.entityMetadata.name}#${this.name}`);\r\n    }\r\n\r\n    /**\r\n     * Gets the column to which this relation is referenced.\r\n     */\r\n    get referencedColumn(): ColumnMetadata {\r\n        if (this.isOwning) {\r\n            if (this.joinTable) {\r\n                return this.joinTable.referencedColumn;\r\n\r\n            } else if (this.joinColumn) {\r\n                return this.joinColumn.referencedColumn;\r\n            }\r\n\r\n        } else if (this.hasInverseSide) {\r\n            if (this.inverseRelation.joinTable) {\r\n                return this.inverseRelation.joinTable.inverseReferencedColumn;\r\n            } else if (this.inverseRelation.joinColumn) {\r\n                return this.inverseRelation.joinColumn.referencedColumn;\r\n            }\r\n        }\r\n\r\n        // this should not be possible, but anyway throw error\r\n        throw new Error(`Cannot get referenced column of the relation ${this.entityMetadata.name}#${this.name}`);\r\n    }\r\n\r\n    /**\r\n     * Gets the property's type to which this relation is applied.\r\n     */\r\n    get type(): Function|string { // todo: when this can be a string?\r\n        return this._type instanceof Function ? (this._type as () => any)() : this._type;\r\n    }\r\n\r\n    /**\r\n     * Indicates if this side is an owner of this relation.\r\n     */\r\n    get isOwning() {\r\n        return  !!(this.isManyToOne ||\r\n                (this.isManyToMany && this.joinTable) ||\r\n                (this.isOneToOne && this.joinColumn));\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"one-to-one\".\r\n     */\r\n    get isOneToOne(): boolean {\r\n        return this.relationType === RelationTypes.ONE_TO_ONE;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\r\n     * Owner side means this side of relation has a join column in the table.\r\n     */\r\n    get isOneToOneOwner(): boolean {\r\n        return this.isOneToOne && this.isOwning;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\r\n     * NOT owner side means this side of relation does not have a join column in the table.\r\n     */\r\n    get isOneToOneNotOwner(): boolean {\r\n        return this.isOneToOne && !this.isOwning;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"one-to-many\".\r\n     */\r\n    get isOneToMany(): boolean {\r\n        return this.relationType === RelationTypes.ONE_TO_MANY;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-one\".\r\n     */\r\n    get isManyToOne(): boolean {\r\n        return this.relationType === RelationTypes.MANY_TO_ONE;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\".\r\n     */\r\n    get isManyToMany(): boolean {\r\n        return this.relationType === RelationTypes.MANY_TO_MANY;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\r\n     * Owner side means this side of relation has a join table.\r\n     */\r\n    get isManyToManyOwner(): boolean {\r\n        return this.isManyToMany && this.isOwning;\r\n    }\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\r\n     * Not owner side means this side of relation does not have a join table.\r\n     */\r\n    get isManyToManyNotOwner(): boolean {\r\n        return this.isManyToMany && !this.isOwning;\r\n    }\r\n\r\n    /**\r\n     * Checks if inverse side is specified by a relation.\r\n     */\r\n    get hasInverseSide(): boolean {\r\n        return this.inverseEntityMetadata && this.inverseEntityMetadata.hasRelationWithPropertyName(this.inverseSideProperty);\r\n    }\r\n\r\n    /**\r\n     * Gets the property name of the inverse side of the relation.\r\n     */\r\n    get inverseSideProperty(): string { // todo: should be called inverseSidePropertyName ?\r\n\r\n        if (this._inverseSideProperty) {\r\n            return this.computeInverseSide(this._inverseSideProperty);\r\n\r\n        } else if (this.isTreeParent && this.entityMetadata.hasTreeChildrenRelation) {\r\n            return this.entityMetadata.treeChildrenRelation.propertyName;\r\n\r\n        } else if (this.isTreeChildren && this.entityMetadata.hasTreeParentRelation) {\r\n            return this.entityMetadata.treeParentRelation.propertyName;\r\n\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Gets the relation metadata of the inverse side of this relation.\r\n     */\r\n    get inverseRelation(): RelationMetadata {\r\n        const relation = this.inverseEntityMetadata.findRelationWithPropertyName(this.inverseSideProperty);\r\n        if (!relation)\r\n            throw new Error(`Inverse side was not found in the relation ${this.entityMetadata.name}#${this.inverseSideProperty}`);\r\n\r\n        return relation;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets given entity's relation's value.\r\n     * Using of this method helps to access value of the lazy loaded relation.\r\n     */\r\n    getEntityValue(entity: ObjectLiteral): any {\r\n        return this.isLazy ? entity[\"__\" + this.propertyName + \"__\"] : entity[this.propertyName];\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity has a value in a relation.\r\n     */\r\n    hasEntityValue(entity: ObjectLiteral): boolean {\r\n        return this.isLazy ? entity[\"__\" + this.propertyName + \"__\"] : entity[this.propertyName];\r\n    }\r\n\r\n    /**\r\n     * todo: lazy relations are not supported here? implement logic?\r\n     *\r\n     * examples:\r\n     *\r\n     * - isOneToOneNotOwner or isOneToMany:\r\n     *  Post has a Category.\r\n     *  Post is owner side.\r\n     *  Category is inverse side.\r\n     *  Post.category is mapped to Category.id\r\n     *\r\n     *  if from Post relation we are passing Category here,\r\n     *  it should return a post.category\r\n     */\r\n    getOwnEntityRelationId(ownEntity: ObjectLiteral): any {\r\n        if (this.isManyToManyOwner) {\r\n            return ownEntity[this.joinTable.referencedColumn.propertyName];\r\n\r\n        } else if (this.isManyToManyNotOwner) {\r\n            return ownEntity[this.inverseRelation.joinTable.inverseReferencedColumn.propertyName];\r\n\r\n        } else if (this.isOneToOneOwner || this.isManyToOne) {\r\n            return ownEntity[this.joinColumn.propertyName];\r\n\r\n        } else if (this.isOneToOneNotOwner || this.isOneToMany) {\r\n            return ownEntity[this.inverseRelation.joinColumn.referencedColumn.propertyName];\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * examples:\r\n     *\r\n     * - isOneToOneNotOwner or isOneToMany:\r\n     *  Post has a Category.\r\n     *  Post is owner side.\r\n     *  Category is inverse side.\r\n     *  Post.category is mapped to Category.id\r\n     *\r\n     *  if from Post relation we are passing Category here,\r\n     *  it should return a category.id\r\n     *\r\n     *  @deprecated Looks like this method does not make sence and does same as getOwnEntityRelationId ?\r\n     */\r\n    getInverseEntityRelationId(inverseEntity: ObjectLiteral): any {\r\n        if (this.isManyToManyOwner) {\r\n            return inverseEntity[this.joinTable.inverseReferencedColumn.propertyName];\r\n\r\n        } else if (this.isManyToManyNotOwner) {\r\n            return inverseEntity[this.inverseRelation.joinTable.referencedColumn.propertyName];\r\n\r\n        } else if (this.isOneToOneOwner || this.isManyToOne) {\r\n            return inverseEntity[this.joinColumn.referencedColumn.propertyName];\r\n\r\n        } else if (this.isOneToOneNotOwner || this.isOneToMany) {\r\n            return inverseEntity[this.inverseRelation.joinColumn.propertyName];\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Private Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\r\n     * either can be a function that accepts a map of properties with the object and returns one of them.\r\n     * Second approach is used to achieve type-safety.\r\n     */\r\n    private computeInverseSide(inverseSide: PropertyTypeInFunction<any>): string {\r\n        const ownerEntityPropertiesMap = this.inverseEntityMetadata.createPropertiesMap();\r\n        if (typeof inverseSide === \"function\")\r\n            return (<Function> inverseSide)(ownerEntityPropertiesMap);\r\n        if (typeof inverseSide === \"string\")\r\n            return <string> inverseSide;\r\n\r\n        // throw new Error(\"Cannot compute inverse side of the relation\");\r\n        return \"\";\r\n    }\r\n}"],"sourceRoot":".."}