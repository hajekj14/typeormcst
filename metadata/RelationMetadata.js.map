{"version":3,"sources":["../../src/metadata/RelationMetadata.ts"],"names":[],"mappings":"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","file":"RelationMetadata.js","sourcesContent":["import {RelationType} from \"./types/RelationTypes\";\r\nimport {EntityMetadata} from \"./EntityMetadata\";\r\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {ColumnMetadata} from \"./ColumnMetadata\";\r\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\r\nimport {NamingStrategyInterface} from \"../naming-strategy/NamingStrategyInterface\";\r\nimport {RelationMetadataArgs} from \"../metadata-args/RelationMetadataArgs\";\r\nimport {OnDeleteType} from \"./types/OnDeleteType\";\r\nimport {PropertyTypeFactory} from \"./types/PropertyTypeInFunction\";\r\n\r\n/**\r\n * Contains all information about some entity's relation.\r\n */\r\nexport class RelationMetadata {\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Entity metadata of the entity where this relation is placed.\r\n     *\r\n     * For example for @ManyToMany(type => Category) in Post, entityMetadata will be metadata of Post entity.\r\n     */\r\n    entityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Entity metadata of the entity that is targeted by this relation.\r\n     *\r\n     * For example for @ManyToMany(type => Category) in Post, inverseEntityMetadata will be metadata of Category entity.\r\n     */\r\n    inverseEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Entity metadata of the junction table.\r\n     * Junction tables have their own entity metadata objects.\r\n     * Defined only for many-to-many relations.\r\n     */\r\n    junctionEntityMetadata?: EntityMetadata;\r\n\r\n    /**\r\n     * Embedded metadata where this relation is.\r\n     * If this relation is not in embed then this property value is undefined.\r\n     */\r\n    embeddedMetadata?: EmbeddedMetadata;\r\n\r\n    /**\r\n     * Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many.\r\n     */\r\n    relationType: RelationType;\r\n\r\n    /**\r\n     * Target entity to which this relation is applied.\r\n     * Target IS NOT equal to entityMetadata.target, because relation\r\n     *\r\n     * For example for @ManyToMany(type => Category) in Post, target will be Post.\r\n     * If @ManyToMany(type => Category) is in Counters which is embedded into Post, target will be Counters.\r\n     * If @ManyToMany(type => Category) is in abstract class BaseUser which Post extends, target will be BaseUser.\r\n     * Target can be string if its defined in entity schema instead of class.\r\n     */\r\n    target: Function|string;\r\n\r\n    /**\r\n     * Target's property name to which relation decorator is applied.\r\n     */\r\n    propertyName: string;\r\n\r\n    /**\r\n     * Gets full path to this column property (including relation name).\r\n     * Full path is relevant when column is used in embeds (one or multiple nested).\r\n     * For example it will return \"counters.subcounters.likes\".\r\n     * If property is not in embeds then it returns just property name of the column.\r\n     */\r\n    propertyPath: string;\r\n\r\n    /**\r\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\r\n     */\r\n    isTreeParent: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\r\n     */\r\n    isTreeChildren: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this relation's column is a primary key.\r\n     * Can be used only for many-to-one and owner one-to-one relations.\r\n     */\r\n    isPrimary: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this relation is lazily loaded.\r\n     */\r\n    isLazy: boolean = false;\r\n\r\n    /**\r\n     * If set to true then related objects are allowed to be inserted to the database.\r\n     */\r\n    isCascadeInsert: boolean = false;\r\n\r\n    /**\r\n     * If set to true then related objects are allowed to be updated in the database.\r\n     */\r\n    isCascadeUpdate: boolean = false;\r\n\r\n    /**\r\n     * If set to true then related objects are allowed to be remove from the database.\r\n     */\r\n    isCascadeRemove: boolean = false;\r\n\r\n    /**\r\n     * Indicates if relation column value can be nullable or not.\r\n     */\r\n    isNullable: boolean = true;\r\n\r\n    /**\r\n     * What to do with a relation on deletion of the row containing a foreign key.\r\n     */\r\n    onDelete?: OnDeleteType;\r\n\r\n    /**\r\n     * Gets the property's type to which this relation is applied.\r\n     *\r\n     * For example for @ManyToMany(type => Category) in Post, target will be Category.\r\n     */\r\n    type: Function|string;\r\n\r\n    /**\r\n     * Indicates if this side is an owner of this relation.\r\n     */\r\n    isOwning: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"one-to-one\".\r\n     */\r\n    isOneToOne: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\r\n     * Owner side means this side of relation has a join column in the table.\r\n     */\r\n    isOneToOneOwner: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\r\n     */\r\n    isWithJoinColumn: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\r\n     * NOT owner side means this side of relation does not have a join column in the table.\r\n     */\r\n    isOneToOneNotOwner: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"one-to-many\".\r\n     */\r\n    isOneToMany: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-one\".\r\n     */\r\n    isManyToOne: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\".\r\n     */\r\n    isManyToMany: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\r\n     * Owner side means this side of relation has a join table.\r\n     */\r\n    isManyToManyOwner: boolean = false;\r\n\r\n    /**\r\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\r\n     * Not owner side means this side of relation does not have a join table.\r\n     */\r\n    isManyToManyNotOwner: boolean = false;\r\n\r\n    /**\r\n     * Gets the property path of the inverse side of the relation.\r\n     */\r\n    inverseSidePropertyPath: string;\r\n\r\n    /**\r\n     * Inverse side of the relation set by user.\r\n     *\r\n     * Inverse side set in the relation can be either string - property name of the column on inverse side,\r\n     * either can be a function that accepts a map of properties with the object and returns one of them.\r\n     * Second approach is used to achieve type-safety.\r\n     */\r\n    givenInverseSidePropertyFactory: PropertyTypeFactory<any>;\r\n\r\n    /**\r\n     * Gets the relation metadata of the inverse side of this relation.\r\n     */\r\n    inverseRelation?: RelationMetadata;\r\n\r\n    /**\r\n     * Join table name.\r\n     */\r\n    joinTableName: string;\r\n\r\n    /**\r\n     * Foreign keys created for this relation.\r\n     */\r\n    foreignKeys: ForeignKeyMetadata[] = [];\r\n\r\n    /**\r\n     * Join table columns.\r\n     * Join columns can be obtained only from owner side of the relation.\r\n     * From non-owner side of the relation join columns will be empty.\r\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\r\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\r\n     */\r\n    joinColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Inverse join table columns.\r\n     * Inverse join columns are supported only for many-to-many relations\r\n     * and can be obtained only from owner side of the relation.\r\n     * From non-owner side of the relation join columns will be undefined.\r\n     */\r\n    inverseJoinColumns: ColumnMetadata[] = [];\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(options: {\r\n        entityMetadata: EntityMetadata,\r\n        embeddedMetadata?: EmbeddedMetadata,\r\n        args: RelationMetadataArgs\r\n    }) {\r\n        this.entityMetadata = options.entityMetadata;\r\n        this.embeddedMetadata = options.embeddedMetadata!;\r\n        const args = options.args;\r\n        this.target = args.target;\r\n        this.propertyName = args.propertyName;\r\n        this.relationType = args.relationType;\r\n\r\n        if (args.inverseSideProperty)\r\n            this.givenInverseSidePropertyFactory = args.inverseSideProperty;\r\n\r\n        this.isLazy = args.isLazy || false;\r\n        this.isCascadeInsert = args.options.cascadeInsert || args.options.cascadeAll || false;\r\n        this.isCascadeUpdate = args.options.cascadeUpdate || args.options.cascadeAll || false;\r\n        this.isCascadeRemove = args.options.cascadeRemove || args.options.cascadeAll || false;\r\n        this.isNullable = args.options.nullable !== false;\r\n        this.onDelete = args.options.onDelete;\r\n        this.isPrimary = args.options.primary || false;\r\n        this.isTreeParent = args.isTreeParent || false;\r\n        this.isTreeChildren = args.isTreeChildren || false;\r\n        this.type = args.type instanceof Function ? (args.type as () => any)() : args.type;\r\n\r\n        this.isOneToOne = this.relationType === \"one-to-one\";\r\n        this.isOneToMany = this.relationType === \"one-to-many\";\r\n        this.isManyToOne = this.relationType === \"many-to-one\";\r\n        this.isManyToMany = this.relationType === \"many-to-many\";\r\n        this.isOneToOneNotOwner = this.isOneToOne ? true : false;\r\n        this.isManyToManyNotOwner = this.isManyToMany ? true : false;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Extracts column value from the given entity.\r\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\r\n     */\r\n    getEntityValue(entity: ObjectLiteral): any|undefined {\r\n\r\n        // extract column value from embeddeds of entity if column is in embedded\r\n        if (this.embeddedMetadata) {\r\n\r\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\r\n            // we need to get value of \"id\" column from the post real entity object\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\r\n\r\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\r\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\r\n            const extractEmbeddedColumnValue = (propertyNames: string[], value: ObjectLiteral): any => {\r\n                const propertyName = propertyNames.shift();\r\n                return propertyName ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\r\n            };\r\n\r\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\r\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\r\n            return embeddedObject ? embeddedObject[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName] : undefined;\r\n\r\n        } else { // no embeds - no problems. Simply return column name by property name of the entity\r\n            return entity[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets given entity's relation's value.\r\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\r\n     */\r\n    setEntityValue(entity: ObjectLiteral, value: any): void {\r\n        const propertyName = this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName;\r\n\r\n        if (this.embeddedMetadata) {\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const extractEmbeddedColumnValue = (embeddedMetadatas: EmbeddedMetadata[], map: ObjectLiteral): any => {\r\n                // if (!object[embeddedMetadata.propertyName])\r\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\r\n\r\n                const embeddedMetadata = embeddedMetadatas.shift();\r\n                if (embeddedMetadata) {\r\n                    if (!map[embeddedMetadata.propertyName])\r\n                        map[embeddedMetadata.propertyName] = embeddedMetadata.create();\r\n\r\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\r\n                    return map;\r\n                }\r\n                map[propertyName] = value;\r\n                return map;\r\n            };\r\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\r\n\r\n        } else {\r\n            entity[propertyName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates entity id map from the given entity ids array.\r\n     */\r\n    createValueMap(value: any) {\r\n\r\n        // extract column value from embeds of entity if column is in embedded\r\n        if (this.embeddedMetadata) {\r\n\r\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\r\n            // we need to get value of \"id\" column from the post real entity object and return it in a\r\n            // { data: { information: { counters: { id: ... } } } } format\r\n\r\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\r\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\r\n\r\n            // now need to access post[data][information][counters] to get column value from the counters\r\n            // and on each step we need to create complex literal object, e.g. first { data },\r\n            // then { data: { information } }, then { data: { information: { counters } } },\r\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\r\n            // this recursive function helps doing that\r\n            const extractEmbeddedColumnValue = (propertyNames: string[], map: ObjectLiteral): any => {\r\n                const propertyName = propertyNames.shift();\r\n                if (propertyName) {\r\n                    map[propertyName] = {};\r\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\r\n                    return map;\r\n                }\r\n                map[this.propertyName] = value;\r\n                return map;\r\n            };\r\n            return extractEmbeddedColumnValue(propertyNames, {});\r\n\r\n        } else { // no embeds - no problems. Simply return column property name and its value of the entity\r\n            return { [this.propertyName]: value };\r\n        }\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Builder Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds some depend relation metadata properties.\r\n     * This builder method should be used only after embedded metadata tree was build.\r\n     */\r\n    build() {\r\n        this.propertyPath = this.buildPropertyPath();\r\n    }\r\n\r\n    /**\r\n     * Registers given foreign keys in the relation.\r\n     * This builder method should be used to register foreign key in the relation.\r\n     */\r\n    registerForeignKeys(...foreignKeys: ForeignKeyMetadata[]) {\r\n        this.foreignKeys.push(...foreignKeys);\r\n        this.joinColumns = this.foreignKeys[0] ? this.foreignKeys[0].columns : [];\r\n        this.inverseJoinColumns = this.foreignKeys[1] ? this.foreignKeys[1].columns : [];\r\n        this.isOwning = this.isManyToOne || ((this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0);\r\n        this.isOneToOneOwner = this.isOneToOne && this.isOwning;\r\n        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\r\n        this.isManyToManyOwner = this.isManyToMany && this.isOwning;\r\n        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\r\n        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\r\n    }\r\n\r\n    /**\r\n     * Registers a given junction entity metadata.\r\n     * This builder method can be called after junction entity metadata for the many-to-many relation was created.\r\n     */\r\n    registerJunctionEntityMetadata(junctionEntityMetadata: EntityMetadata) {\r\n        this.junctionEntityMetadata = junctionEntityMetadata;\r\n        this.joinTableName = junctionEntityMetadata.tableName;\r\n        if (this.inverseRelation) {\r\n            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\r\n            this.joinTableName = junctionEntityMetadata.tableName;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds inverse side property path based on given inverse side property factory.\r\n     * This builder method should be used only after properties map of the inverse entity metadata was build.\r\n     */\r\n    buildInverseSidePropertyPath(): string {\r\n\r\n        if (this.givenInverseSidePropertyFactory) {\r\n            const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\r\n            if (typeof this.givenInverseSidePropertyFactory === \"function\")\r\n                return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\r\n\r\n            if (typeof this.givenInverseSidePropertyFactory === \"string\")\r\n                return this.givenInverseSidePropertyFactory;\r\n\r\n        } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {\r\n            return this.entityMetadata.treeChildrenRelation.propertyName;\r\n\r\n        } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {\r\n            return this.entityMetadata.treeParentRelation.propertyName;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Builds relation's property path based on its embedded tree.\r\n     */\r\n    buildPropertyPath(): string {\r\n        if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length)\r\n            return this.propertyName;\r\n\r\n        return this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\" + this.propertyName;\r\n    }\r\n\r\n}"],"sourceRoot":".."}