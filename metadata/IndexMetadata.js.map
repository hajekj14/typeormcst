{"version":3,"sources":["../../src/metadata/IndexMetadata.ts"],"names":[],"mappings":"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","file":"IndexMetadata.js","sourcesContent":["import {EntityMetadata} from \"./EntityMetadata\";\r\nimport {IndexMetadataArgs} from \"../metadata-args/IndexMetadataArgs\";\r\n\r\n/**\r\n * Index metadata contains all information about table's index.\r\n */\r\nexport class IndexMetadata {\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Entity metadata of the class to which this index is applied.\r\n     */\r\n    entityMetadata: EntityMetadata;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Readonly Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Indicates if this index must be unique.\r\n     */\r\n    readonly isUnique: boolean;\r\n\r\n    /**\r\n     * Target class to which metadata is applied.\r\n     */\r\n    readonly target?: Function|string;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Private Properties\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Composite index name.\r\n     */\r\n    private readonly _name: string|undefined;\r\n\r\n    /**\r\n     * Columns combination to be used as index.\r\n     */\r\n    private readonly _columns: ((object?: any) => (any[]|{ [key: string]: number }))|string[];\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(args: IndexMetadataArgs) {\r\n        this.target = args.target;\r\n        this._columns = args.columns;\r\n        this._name = args.name;\r\n        this.isUnique = args.unique;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Accessors\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets index's name.\r\n     */\r\n    get name() {\r\n        return this.entityMetadata.namingStrategy.indexName(this._name, this.entityMetadata.table.name, this.columns);\r\n    }\r\n\r\n    /**\r\n     * Gets the table name on which index is applied.\r\n     */\r\n    get tableName() {\r\n        return this.entityMetadata.table.name;\r\n    }\r\n\r\n    /**\r\n     * Gets the column names which are in this index.\r\n     */\r\n    get columns(): string[] {\r\n\r\n        // if columns already an array of string then simply return it\r\n        let columnPropertyNames: string[] = [];\r\n        if (this._columns instanceof Array) {\r\n            columnPropertyNames = this._columns;\r\n        } else {\r\n            // if columns is a function that returns array of field names then execute it and get columns names from it\r\n            const propertiesMap = this.entityMetadata.createPropertiesMap();\r\n            const columnsFnResult = this._columns(propertiesMap);\r\n            const columnsNamesFromFnResult = columnsFnResult instanceof Array ? columnsFnResult : Object.keys(columnsFnResult);\r\n            columnPropertyNames = columnsNamesFromFnResult.map((i: any) => String(i));\r\n        }\r\n\r\n        const columns = this.entityMetadata.columns.filter(column => columnPropertyNames.indexOf(column.propertyName) !== -1);\r\n        const missingColumnNames = columnPropertyNames.filter(columnPropertyName => !this.entityMetadata.columns.find(column => column.propertyName === columnPropertyName));\r\n        if (missingColumnNames.length > 0) { // todo: better to extract all validation into single place is possible\r\n            // console.log(this.entityMetadata.columns);\r\n            throw new Error(`Index ${this._name ? \"\\\"\" + this._name + \"\\\" \" : \"\"}contains columns that are missing in the entity: ` + missingColumnNames.join(\", \"));\r\n        }\r\n\r\n        return columns.map(column => column.fullName);\r\n    }\r\n\r\n    /**\r\n     * Builds columns as a map of values where column name is key of object and value is a value provided by\r\n     * function or default value given to this function.\r\n     */\r\n    buildColumnsAsMap(defaultValue = 0): { [key: string]: number } {\r\n\r\n        const map: { [key: string]: number } = {};\r\n\r\n        // if columns already an array of string then simply create a map from it\r\n        if (this._columns instanceof Array) {\r\n            this._columns.forEach(columnName => map[columnName] = defaultValue);\r\n\r\n        } else {\r\n            // if columns is a function that returns array of field names then execute it and get columns names from it\r\n            const propertiesMap = this.entityMetadata.createPropertiesMap();\r\n            const columnsFnResult = this._columns(propertiesMap);\r\n            if (columnsFnResult instanceof Array) {\r\n                columnsFnResult.forEach(columnName => map[columnName] = defaultValue);\r\n            } else {\r\n                Object.keys(columnsFnResult).forEach(columnName => map[columnName] = columnsFnResult[columnName]);\r\n            }\r\n        }\r\n\r\n        // replace each propertyNames with column names\r\n        return Object.keys(map).reduce((updatedMap, key) => {\r\n            const column = this.entityMetadata.columns.find(column => column.propertyName === key);\r\n            if (!column)\r\n                throw new Error(`Index ${this._name ? \"\\\"\" + this._name + \"\\\" \" : \"\"}contains columns that are missing in the entity: ${key}`);\r\n\r\n            updatedMap[column.name] = map[key];\r\n            return updatedMap;\r\n        }, {} as { [key: string]: number });\r\n    }\r\n\r\n}"],"sourceRoot":".."}