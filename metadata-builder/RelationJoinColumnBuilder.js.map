{"version":3,"sources":["../../src/metadata-builder/RelationJoinColumnBuilder.ts"],"names":[],"mappings":"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","file":"RelationJoinColumnBuilder.js","sourcesContent":["import {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {ForeignKeyMetadata} from \"../metadata/ForeignKeyMetadata\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {JoinColumnMetadataArgs} from \"../metadata-args/JoinColumnMetadataArgs\";\r\nimport {Connection} from \"../connection/Connection\";\r\n\r\n/**\r\n * Builds join column for the many-to-one and one-to-one owner relations.\r\n *\r\n * Cases it should cover:\r\n * 1. when join column is set with custom name and without referenced column name\r\n * we need automatically set referenced column name - primary ids by default\r\n * @JoinColumn({ name: \"custom_name\" })\r\n *\r\n * 2. when join column is set with only referenced column name\r\n * we need automatically set join column name - relation name + referenced column name\r\n * @JoinColumn({ referencedColumnName: \"title\" })\r\n *\r\n * 3. when join column is set without both referenced column name and join column name\r\n * we need to automatically set both of them\r\n * @JoinColumn()\r\n *\r\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\r\n * we need to create join column for it with proper referenced column name and join column name\r\n *\r\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\r\n * both options are required\r\n * @JoinColumn([\r\n *      { name: \"category_title\", referencedColumnName: \"type\" },\r\n *      { name: \"category_title\", referencedColumnName: \"name\" },\r\n * ])\r\n *\r\n * Since for many-to-one relations having JoinColumn decorator is not required,\r\n * we need to go thought each many-to-one relation without join column decorator set\r\n * and create join column metadata args for them.\r\n */\r\nexport class RelationJoinColumnBuilder {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private connection: Connection) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\r\n     */\r\n    build(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): ForeignKeyMetadata|undefined {\r\n        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\r\n        if (!referencedColumns.length)\r\n            return undefined; // this case is possible only for one-to-one non owning side\r\n\r\n        const columns = this.collectColumns(joinColumns, relation, referencedColumns);\r\n        return new ForeignKeyMetadata({\r\n            entityMetadata: relation.entityMetadata,\r\n            referencedEntityMetadata: relation.inverseEntityMetadata,\r\n            namingStrategy: this.connection.driver.namingStrategy,\r\n            columns: columns,\r\n            referencedColumns: referencedColumns,\r\n            onDelete: relation.onDelete,\r\n        });\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Collects referenced columns from the given join column args.\r\n     */\r\n    protected collectReferencedColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): ColumnMetadata[] {\r\n        const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\r\n        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\r\n        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\r\n\r\n        if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) { // covers case3 and case1\r\n            return relation.inverseEntityMetadata.primaryColumns;\r\n\r\n        } else { // cases with referenced columns defined\r\n            return joinColumns.map(joinColumn => {\r\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\r\n                if (!referencedColumn)\r\n                    throw new Error(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\r\n\r\n                return referencedColumn;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects columns from the given join column args.\r\n     */\r\n    private collectColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata, referencedColumns: ColumnMetadata[]): ColumnMetadata[] {\r\n        return referencedColumns.map(referencedColumn => {\r\n\r\n            // in the case if relation has join column with only name set we need this check\r\n            const joinColumnMetadataArg = joinColumns.find(joinColumn => {\r\n                return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) &&\r\n                    !!joinColumn.name;\r\n            });\r\n            const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.driver.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\r\n\r\n            let relationalColumn = relation.entityMetadata.ownColumns.find(column => column.databaseName === joinColumnName);\r\n            if (!relationalColumn) {\r\n                relationalColumn = new ColumnMetadata({\r\n                    entityMetadata: relation.entityMetadata,\r\n                    args: {\r\n                        target: \"\",\r\n                        mode: \"virtual\",\r\n                        propertyName: relation.propertyName,\r\n                        options: {\r\n                            name: joinColumnName,\r\n                            type: referencedColumn.type,\r\n                            primary: relation.isPrimary,\r\n                            nullable: relation.isNullable,\r\n                        }\r\n                    }\r\n                });\r\n                relation.entityMetadata.registerColumn(relationalColumn);\r\n            }\r\n            relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\r\n            relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\r\n            relationalColumn.relationMetadata = relation;\r\n            relationalColumn.build(this.connection.driver.namingStrategy);\r\n            return relationalColumn;\r\n        });\r\n    }\r\n}"],"sourceRoot":".."}