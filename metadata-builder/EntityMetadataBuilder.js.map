{"version":3,"sources":["../../src/metadata-builder/EntityMetadataBuilder.ts"],"names":[],"mappings":"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","file":"EntityMetadataBuilder.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {IndexMetadata} from \"../metadata/IndexMetadata\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {EmbeddedMetadata} from \"../metadata/EmbeddedMetadata\";\r\nimport {MetadataArgsStorage} from \"../metadata-args/MetadataArgsStorage\";\r\nimport {EmbeddedMetadataArgs} from \"../metadata-args/EmbeddedMetadataArgs\";\r\nimport {RelationIdMetadata} from \"../metadata/RelationIdMetadata\";\r\nimport {RelationCountMetadata} from \"../metadata/RelationCountMetadata\";\r\nimport {MetadataUtils} from \"./MetadataUtils\";\r\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\r\nimport {JunctionEntityMetadataBuilder} from \"./JunctionEntityMetadataBuilder\";\r\nimport {ClosureJunctionEntityMetadataBuilder} from \"./ClosureJunctionEntityMetadataBuilder\";\r\nimport {RelationJoinColumnBuilder} from \"./RelationJoinColumnBuilder\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {EntityListenerMetadata} from \"../metadata/EntityListenerMetadata\";\r\n\r\n/**\r\n * Builds EntityMetadata objects and all its sub-metadatas.\r\n */\r\nexport class EntityMetadataBuilder {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Used to build entity metadatas of the junction entities.\r\n     */\r\n    protected junctionEntityMetadataBuilder: JunctionEntityMetadataBuilder;\r\n\r\n    /**\r\n     * Used to build entity metadatas of the closure junction entities.\r\n     */\r\n    protected closureJunctionEntityMetadataBuilder: ClosureJunctionEntityMetadataBuilder;\r\n\r\n    /**\r\n     * Used to build join columns of the relations.\r\n     */\r\n    protected relationJoinColumnBuilder: RelationJoinColumnBuilder;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private connection: Connection, private metadataArgsStorage: MetadataArgsStorage) {\r\n        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\r\n        this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\r\n        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a complete entity metadatas for the given entity classes.\r\n     */\r\n    build(entityClasses?: Function[]): EntityMetadata[] {\r\n\r\n        // if entity classes to filter entities by are given then do filtering, otherwise use all\r\n        const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;\r\n\r\n        // filter out table metadata args for those we really create entity metadatas and tables in the db\r\n        const realTables = allTables.filter(table => table.type === \"regular\" || table.type === \"closure\" || table.type === \"class-table-child\" || table.type === \"single-table-child\");\r\n\r\n        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\r\n        const entityMetadatas = realTables.map(tableArgs => this.createEntityMetadata(tableArgs));\r\n\r\n        // calculate entity metadata computed properties and all its sub-metadatas\r\n        entityMetadatas.forEach(entityMetadata => this.computeEntityMetadata(entityMetadata));\r\n\r\n        // calculate entity metadata's inverse properties\r\n        entityMetadatas.forEach(entityMetadata => this.computeInverseProperties(entityMetadata, entityMetadatas));\r\n\r\n        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\r\n        entityMetadatas\r\n            .filter(entityMetadata => entityMetadata.tableType !== \"single-table-child\")\r\n            .forEach(entityMetadata => {\r\n\r\n                // create entity's relations join columns (for many-to-one and one-to-one owner)\r\n                entityMetadata.relations.filter(relation => relation.isOneToOne || relation.isManyToOne).forEach(relation => {\r\n                    const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\r\n                    const foreignKey = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\r\n                    if (foreignKey) {\r\n                        relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\r\n                        entityMetadata.foreignKeys.push(foreignKey);\r\n                    }\r\n                });\r\n\r\n                // create junction entity metadatas for entity many-to-many relations\r\n                entityMetadata.relations.filter(relation => relation.isManyToMany).forEach(relation => {\r\n                    const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\r\n                    if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\r\n\r\n                    // here we create a junction entity metadata for a new junction table of many-to-many relation\r\n                    const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\r\n                    relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\r\n                    relation.registerJunctionEntityMetadata(junctionEntityMetadata);\r\n\r\n                    // compute new entity metadata properties and push it to entity metadatas pool\r\n                    this.computeEntityMetadata(junctionEntityMetadata);\r\n                    this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\r\n                    entityMetadatas.push(junctionEntityMetadata);\r\n                });\r\n\r\n                // update entity metadata depend properties\r\n                entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(relation => relation.isWithJoinColumn);\r\n                entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\r\n        });\r\n\r\n        // generate closure junction tables for all closure tables\r\n        entityMetadatas\r\n            .filter(metadata => metadata.isClosure)\r\n            .forEach(entityMetadata => {\r\n                const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\r\n                entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\r\n                this.computeEntityMetadata(closureJunctionEntityMetadata);\r\n                this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\r\n                entityMetadatas.push(closureJunctionEntityMetadata);\r\n            });\r\n\r\n        // after all metadatas created we set parent entity metadata for class-table inheritance\r\n        entityMetadatas\r\n            .filter(metadata => metadata.tableType === \"single-table-child\")\r\n            .forEach(entityMetadata => {\r\n                const inheritanceTree: any[] = entityMetadata.target instanceof Function\r\n                    ? MetadataUtils.getInheritanceTree(entityMetadata.target)\r\n                    : [entityMetadata.target];\r\n\r\n                const parentMetadata = entityMetadatas.find(metadata => {\r\n                    return inheritanceTree.find(inheritance => inheritance === metadata.target) && metadata.inheritanceType === \"single-table\";\r\n                });\r\n\r\n                if (parentMetadata) {\r\n                    entityMetadata.parentEntityMetadata = parentMetadata;\r\n                    entityMetadata.tableName = parentMetadata.tableName;\r\n                }\r\n            });\r\n\r\n        // after all metadatas created we set child entity metadatas for class-table inheritance\r\n        entityMetadatas.forEach(metadata => {\r\n            metadata.childEntityMetadatas = entityMetadatas.filter(childMetadata => {\r\n                return metadata.target instanceof Function\r\n                    && childMetadata.target instanceof Function\r\n                    && MetadataUtils.isInherited(childMetadata.target, metadata.target);\r\n            });\r\n        });\r\n\r\n        // generate keys for tables with single-table inheritance\r\n        entityMetadatas\r\n            .filter(metadata => metadata.inheritanceType === \"single-table\" && metadata.discriminatorColumn)\r\n            .forEach(entityMetadata => this.createKeysForTableInheritance(entityMetadata));\r\n\r\n        // build all indices (need to do it after relations and their join columns are built)\r\n        entityMetadatas.forEach(entityMetadata => {\r\n            entityMetadata.indices.forEach(index => index.build(this.connection.driver.namingStrategy));\r\n        });\r\n\r\n        // add lazy initializer for entity relations\r\n        entityMetadatas\r\n            .filter(metadata => metadata.target instanceof Function)\r\n            .forEach(entityMetadata => {\r\n                entityMetadata.relations\r\n                    .filter(relation => relation.isLazy)\r\n                    .forEach(relation => {\r\n                        this.connection.driver.lazyRelationsWrapper.wrap((entityMetadata.target as Function).prototype, relation);\r\n                    });\r\n            });\r\n\r\n        return entityMetadatas;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates entity metadata from the given table args.\r\n     * Creates column, relation, etc. metadatas for everything this entity metadata owns.\r\n     */\r\n    protected createEntityMetadata(tableArgs: TableMetadataArgs): EntityMetadata {\r\n\r\n        // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\r\n        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\r\n        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\r\n        const inheritanceTree: any[] = tableArgs.target instanceof Function\r\n            ? MetadataUtils.getInheritanceTree(tableArgs.target)\r\n            : [tableArgs.target]; // todo: implement later here inheritance for string-targets\r\n\r\n        // if single table inheritance used, we need to copy all children columns in to parent table\r\n        const singleTableChildrenTargets: any[] = this.metadataArgsStorage\r\n            .filterSingleTableChildren(tableArgs.target)\r\n            .map(args => args.target)\r\n            .filter(target => target instanceof Function);\r\n\r\n        inheritanceTree.push(...singleTableChildrenTargets);\r\n\r\n        const entityMetadata = new EntityMetadata({ connection: this.connection, args: tableArgs });\r\n\r\n        const inheritanceType = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\r\n        entityMetadata.inheritanceType = inheritanceType ? inheritanceType.type : undefined;\r\n\r\n        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(tableArgs.target);\r\n        entityMetadata.discriminatorValue = discriminatorValue ? discriminatorValue.value : (tableArgs.target as any).name; // todo: pass this to naming strategy to generate a name\r\n\r\n        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(inheritanceTree));\r\n        entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(inheritanceTree).map(args => {\r\n            const column = new ColumnMetadata({ entityMetadata, args });\r\n            // if single table inheritance used, we need to mark all inherit table columns as nullable\r\n            if (singleTableChildrenTargets.indexOf(args.target) !== -1)\r\n                column.isNullable = true;\r\n            return column;\r\n        });\r\n\r\n        entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(inheritanceTree).map(args => {\r\n            return new RelationMetadata({ entityMetadata, args });\r\n        });\r\n        entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(inheritanceTree).map(args => {\r\n            return new RelationIdMetadata({ entityMetadata, args });\r\n        });\r\n        entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(inheritanceTree).map(args => {\r\n            return new RelationCountMetadata({ entityMetadata, args });\r\n        });\r\n        entityMetadata.indices = this.metadataArgsStorage.filterIndices(inheritanceTree).map(args => {\r\n            return new IndexMetadata({ entityMetadata, args });\r\n        });\r\n        entityMetadata.listeners = this.metadataArgsStorage.filterListeners(inheritanceTree).map(args => {\r\n            return new EntityListenerMetadata(args);\r\n        });\r\n        return entityMetadata;\r\n    }\r\n\r\n    /**\r\n     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\r\n     * and does the same for all its sub-embeddeds (goes recursively).\r\n     */\r\n    protected createEmbeddedsRecursively(entityMetadata: EntityMetadata, embeddedArgs: EmbeddedMetadataArgs[]): EmbeddedMetadata[] {\r\n        return embeddedArgs.map(embeddedArgs => {\r\n            const embeddedMetadata = new EmbeddedMetadata({ entityMetadata: entityMetadata, args: embeddedArgs });\r\n            embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(embeddedMetadata.type).map(args => {\r\n                return new ColumnMetadata({ entityMetadata, embeddedMetadata, args});\r\n            });\r\n            embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(embeddedMetadata.type).map(args => {\r\n                return new RelationMetadata({ entityMetadata, embeddedMetadata, args });\r\n            });\r\n            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(embeddedMetadata.type));\r\n            embeddedMetadata.embeddeds.forEach(subEmbedded => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);\r\n            return embeddedMetadata;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\r\n     */\r\n    protected computeEntityMetadata(entityMetadata: EntityMetadata) {\r\n        entityMetadata.embeddeds.forEach(embedded => embedded.build(this.connection.driver.namingStrategy));\r\n        entityMetadata.embeddeds.forEach(embedded => {\r\n            embedded.columnsFromTree.forEach(column => column.build(this.connection.driver.namingStrategy));\r\n            embedded.relationsFromTree.forEach(relation => relation.build());\r\n        });\r\n        entityMetadata.ownColumns.forEach(column => column.build(this.connection.driver.namingStrategy));\r\n        entityMetadata.ownRelations.forEach(relation => relation.build());\r\n        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\r\n        entityMetadata.oneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOne);\r\n        entityMetadata.oneToManyRelations = entityMetadata.relations.filter(relation => relation.isOneToMany);\r\n        entityMetadata.manyToOneRelations = entityMetadata.relations.filter(relation => relation.isManyToOne);\r\n        entityMetadata.manyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToMany);\r\n        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOneOwner);\r\n        entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToManyOwner);\r\n        entityMetadata.treeParentRelation = entityMetadata.relations.find(relation => relation.isTreeParent);\r\n        entityMetadata.treeChildrenRelation = entityMetadata.relations.find(relation => relation.isTreeChildren);\r\n        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\r\n        entityMetadata.primaryColumns = entityMetadata.columns.filter(column => column.isPrimary);\r\n        entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\r\n        entityMetadata.generatedColumn = entityMetadata.columns.find(column => column.isGenerated);\r\n        entityMetadata.createDateColumn = entityMetadata.columns.find(column => column.isCreateDate);\r\n        entityMetadata.updateDateColumn = entityMetadata.columns.find(column => column.isUpdateDate);\r\n        entityMetadata.versionColumn = entityMetadata.columns.find(column => column.isVersion);\r\n        entityMetadata.discriminatorColumn = entityMetadata.columns.find(column => column.isDiscriminator);\r\n        entityMetadata.treeLevelColumn = entityMetadata.columns.find(column => column.isTreeLevel);\r\n        entityMetadata.parentIdColumns = entityMetadata.columns.filter(column => column.isParentId);\r\n        entityMetadata.objectIdColumn = entityMetadata.columns.find(column => column.isObjectId);\r\n        entityMetadata.foreignKeys.forEach(foreignKey => foreignKey.build(this.connection.driver.namingStrategy));\r\n        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\r\n\r\n        entityMetadata.relationIds.forEach(relationId => relationId.build());\r\n        entityMetadata.relationCounts.forEach(relationCount => relationCount.build());\r\n        entityMetadata.embeddeds.forEach(embedded => {\r\n            embedded.relationIdsFromTree.forEach(relationId => relationId.build());\r\n            embedded.relationCountsFromTree.forEach(relationCount => relationCount.build());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Computes entity metadata's relations inverse side properties.\r\n     */\r\n    protected computeInverseProperties(entityMetadata: EntityMetadata, entityMetadatas: EntityMetadata[]) {\r\n        entityMetadata.relations.forEach(relation => {\r\n\r\n            // compute inverse side (related) entity metadatas for all relation metadatas\r\n            const inverseEntityMetadata = entityMetadatas.find(m => m.target === relation.type || (typeof relation.type === \"string\" && m.targetName === relation.type));\r\n            if (!inverseEntityMetadata)\r\n                throw new Error(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object, check its really entity and its connected in the connection options.\");\r\n\r\n            relation.inverseEntityMetadata = inverseEntityMetadata;\r\n            relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();\r\n\r\n            // and compute inverse relation and mark if it has such\r\n            relation.inverseRelation = inverseEntityMetadata.relations.find(foundRelation => foundRelation.propertyPath === relation.inverseSidePropertyPath);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates indices for the table of single table inheritance.\r\n     */\r\n    protected createKeysForTableInheritance(entityMetadata: EntityMetadata) {\r\n        entityMetadata.indices.push(\r\n            new IndexMetadata({\r\n                entityMetadata: entityMetadata,\r\n                columns: [entityMetadata.discriminatorColumn!],\r\n                args: {\r\n                    target: entityMetadata.target,\r\n                    unique: false\r\n                }\r\n            }),\r\n            new IndexMetadata({\r\n                entityMetadata: entityMetadata,\r\n                columns: [...entityMetadata.primaryColumns, entityMetadata.discriminatorColumn!],\r\n                args: {\r\n                    target: entityMetadata.target,\r\n                    unique: false\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n}\r\n\r\n// generate virtual column with foreign key for class-table inheritance\r\n/*entityMetadatas.forEach(entityMetadata => {\r\n if (!entityMetadata.parentEntityMetadata)\r\n return;\r\n\r\n const parentPrimaryColumns = entityMetadata.parentEntityMetadata.primaryColumns;\r\n const parentIdColumns = parentPrimaryColumns.map(primaryColumn => {\r\n const columnName = this.namingStrategy.classTableInheritanceParentColumnName(entityMetadata.parentEntityMetadata.tableName, primaryColumn.propertyName);\r\n const column = new ColumnMetadataBuilder(entityMetadata);\r\n column.type = primaryColumn.type;\r\n column.propertyName = primaryColumn.propertyName; // todo: check why needed\r\n column.givenName = columnName;\r\n column.mode = \"parentId\";\r\n column.isUnique = true;\r\n column.isNullable = false;\r\n // column.entityTarget = entityMetadata.target;\r\n return column;\r\n });\r\n\r\n // add foreign key\r\n const foreignKey = new ForeignKeyMetadataBuilder(\r\n entityMetadata,\r\n parentIdColumns,\r\n entityMetadata.parentEntityMetadata,\r\n parentPrimaryColumns,\r\n \"CASCADE\"\r\n );\r\n entityMetadata.ownColumns.push(...parentIdColumns);\r\n entityMetadata.foreignKeys.push(foreignKey);\r\n });*/\r\n\r\n\r\n/*protected createEntityMetadata(metadata: EntityMetadata, options: {\r\n userSpecifiedTableName?: string,\r\n closureOwnerTableName?: string,\r\n }) {\r\n\r\n const tableNameUserSpecified = options.userSpecifiedTableName;\r\n const isClosureJunction = metadata.tableType === \"closure-junction\";\r\n const targetName = metadata.target instanceof Function ? (metadata.target as any).name : metadata.target;\r\n const tableNameWithoutPrefix = isClosureJunction\r\n ? this.namingStrategy.closureJunctionTableName(options.closureOwnerTableName!)\r\n : this.namingStrategy.tableName(targetName, options.userSpecifiedTableName);\r\n\r\n const tableName = this.namingStrategy.prefixTableName(this.driver.options.tablesPrefix, tableNameWithoutPrefix);\r\n\r\n // for virtual tables (like junction table) target is equal to undefined at this moment\r\n // we change this by setting virtual's table name to a target name\r\n // todo: add validation so targets with same schema names won't conflicts with virtual table names\r\n metadata.target = metadata.target ? metadata.target : tableName;\r\n metadata.targetName = targetName;\r\n metadata.givenTableName = tableNameUserSpecified;\r\n metadata.tableNameWithoutPrefix = tableNameWithoutPrefix;\r\n metadata.tableName = tableName;\r\n metadata.name = targetName ? targetName : tableName;\r\n // metadata.namingStrategy = this.namingStrategy;\r\n }*/\r\n\r\n/*protected createEntityMetadata(tableArgs: any, argsForTable: any, ): EntityMetadata {\r\n const metadata = new EntityMetadata({\r\n junction: false,\r\n target: tableArgs.target,\r\n tablesPrefix: this.driver.options.tablesPrefix,\r\n namingStrategy: this.namingStrategy,\r\n tableName: argsForTable.name,\r\n tableType: argsForTable.type,\r\n orderBy: argsForTable.orderBy,\r\n engine: argsForTable.engine,\r\n skipSchemaSync: argsForTable.skipSchemaSync,\r\n columnMetadatas: columns,\r\n relationMetadatas: relations,\r\n relationIdMetadatas: relationIds,\r\n relationCountMetadatas: relationCounts,\r\n indexMetadatas: indices,\r\n embeddedMetadatas: embeddeds,\r\n inheritanceType: mergedArgs.inheritance ? mergedArgs.inheritance.type : undefined,\r\n discriminatorValue: discriminatorValueArgs ? discriminatorValueArgs.value : (tableArgs.target as any).name // todo: pass this to naming strategy to generate a name\r\n }, this.lazyRelationsWrapper);\r\n return metadata;\r\n }*/\r\n\r\n\r\n// const tables = [mergedArgs.table].concat(mergedArgs.children);\r\n// tables.forEach(tableArgs => {\r\n\r\n// find embeddable tables for embeddeds registered in this table and create EmbeddedMetadatas from them\r\n// const findEmbeddedsRecursively = (embeddedArgs: EmbeddedMetadataArgs[]) => {\r\n//     const embeddeds: EmbeddedMetadata[] = [];\r\n//     embeddedArgs.forEach(embedded => {\r\n//         const embeddableTable = embeddableMergedArgs.find(embeddedMergedArgs => embeddedMergedArgs.table.target === embedded.type());\r\n//         if (embeddableTable) {\r\n//             const columns = embeddableTable.columns.toArray().map(args => new ColumnMetadata(args));\r\n//             const relations = embeddableTable.relations.toArray().map(args => new RelationMetadata(args));\r\n//             const subEmbeddeds = findEmbeddedsRecursively(embeddableTable.embeddeds.toArray());\r\n//             embeddeds.push(new EmbeddedMetadata(columns, relations, subEmbeddeds, embedded));\r\n//         }\r\n//     });\r\n//     return embeddeds;\r\n// };\r\n// const embeddeds = findEmbeddedsRecursively(mergedArgs.embeddeds.toArray());\r\n\r\n// create metadatas from args\r\n// const argsForTable = mergedArgs.inheritance && mergedArgs.inheritance.type === \"single-table\" ? mergedArgs.table : tableArgs;\r\n\r\n// const table = new TableMetadata(argsForTable);\r\n// const columns = mergedArgs.columns.toArray().map(args => {\r\n//\r\n//     // if column's target is a child table then this column should have all nullable columns\r\n//     if (mergedArgs.inheritance &&\r\n//         mergedArgs.inheritance.type === \"single-table\" &&\r\n//         args.target !== mergedArgs.table.target && !!mergedArgs.children.find(childTable => childTable.target === args.target)) {\r\n//         args.options.nullable = true;\r\n//     }\r\n//     return new ColumnMetadata(args);\r\n// });\r\n// const discriminatorValueArgs = mergedArgs.discriminatorValues.find(discriminatorValueArgs => {\r\n//     return discriminatorValueArgs.target === tableArgs.target;\r\n// });\r\n\r\n\r\n\r\n// after all metadatas created we set parent entity metadata for class-table inheritance\r\n// entityMetadatas.forEach(entityMetadata => {\r\n//     const mergedArgs = realTables.find(args => args.target === entityMetadata.target);\r\n//     if (mergedArgs && mergedArgs.parent) {\r\n//         const parentEntityMetadata = entityMetadatas.find(entityMetadata => entityMetadata.target === (mergedArgs!.parent! as any).target); // todo: weird compiler error here, thats why type casing is used\r\n//         if (parentEntityMetadata)\r\n//             entityMetadata.parentEntityMetadata = parentEntityMetadata;\r\n//     }\r\n// });"],"sourceRoot":".."}