{"version":3,"sources":["../../src/repository/SpecificRepository.ts"],"names":[],"mappings":"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","file":"SpecificRepository.js","sourcesContent":["import {Connection} from \"../connection/Connection\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\r\nimport {Subject} from \"../persistence/Subject\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {QueryBuilder} from \"../query-builder/QueryBuilder\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\n\r\n/**\r\n * Repository for more specific operations.\r\n *\r\n * @deprecated Don't use it yet\r\n */\r\nexport class SpecificRepository<Entity extends ObjectLiteral> {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected connection: Connection,\r\n                protected metadata: EntityMetadata,\r\n                protected queryRunnerProvider?: QueryRunnerProvider) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationName: string, entityId: any, relatedEntityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\r\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n        if (relation.isManyToMany)\r\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\r\n\r\n        // todo: fix issues with joinColumns[0]\r\n\r\n        let table: string, values: any = {}, conditions: any = {};\r\n        if (relation.isOwning) {\r\n            table = relation.entityMetadata.tableName;\r\n            values[relation.joinColumns[0].referencedColumn!.databaseName] = relatedEntityId;\r\n            conditions[relation.joinColumns[0].referencedColumn!.databaseName] = entityId;\r\n        } else {\r\n            table = relation.inverseEntityMetadata.tableName;\r\n            values[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = relatedEntityId;\r\n            conditions[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = entityId;\r\n        }\r\n\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        await queryRunner.update(table, values, conditions);\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationName: string, relatedEntityId: any, entityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        // todo: fix issues with joinColumns[0]\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\r\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n        if (relation.isManyToMany)\r\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\r\n\r\n        let table: string, values: any = {}, conditions: any = {};\r\n        if (relation.isOwning) {\r\n            table = relation.inverseEntityMetadata.tableName;\r\n            values[relation.inverseRelation!.joinColumns[0].databaseName] = relatedEntityId;\r\n            conditions[relation.inverseRelation!.joinColumns[0].referencedColumn!.databaseName] = entityId;\r\n        } else {\r\n            table = relation.entityMetadata.tableName;\r\n            values[relation.joinColumns[0].databaseName] = relatedEntityId;\r\n            conditions[relation.joinColumns[0].referencedColumn!.databaseName] = entityId;\r\n        }\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        await queryRunner.update(table, values, conditions);\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        const insertPromises = relatedEntityIds.map(relatedEntityId => {\r\n            const values: any = {};\r\n            if (relation.isOwning) {\r\n                values[relation.junctionEntityMetadata!.columns[0].databaseName] = entityId;\r\n                values[relation.junctionEntityMetadata!.columns[1].databaseName] = relatedEntityId;\r\n            } else {\r\n                values[relation.junctionEntityMetadata!.columns[1].databaseName] = entityId;\r\n                values[relation.junctionEntityMetadata!.columns[0].databaseName] = relatedEntityId;\r\n            }\r\n\r\n            return queryRunner.insert(relation.junctionEntityMetadata!.tableName, values);\r\n        });\r\n        await Promise.all(insertPromises);\r\n\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        try {\r\n            const insertPromises = entityIds.map(entityId => {\r\n                const values: any = {};\r\n                if (relation.isOwning) {\r\n                    values[relation.junctionEntityMetadata!.columns[0].databaseName] = entityId;\r\n                    values[relation.junctionEntityMetadata!.columns[1].databaseName] = relatedEntityId;\r\n                } else {\r\n                    values[relation.junctionEntityMetadata!.columns[1].databaseName] = entityId;\r\n                    values[relation.junctionEntityMetadata!.columns[0].databaseName] = relatedEntityId;\r\n                }\r\n\r\n                return queryRunner.insert(relation.junctionEntityMetadata!.tableName, values);\r\n            });\r\n            await Promise.all(insertPromises);\r\n\r\n        } finally {\r\n            if (!this.queryRunnerProvider) // means created by this method\r\n                await queryRunnerProvider.release(queryRunner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationProperty: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\r\n\r\n        // check if given relation entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\r\n        if (!relatedEntityIds || !relatedEntityIds.length)\r\n            return Promise.resolve();\r\n\r\n        const qb = new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .fromTable(relation.junctionEntityMetadata!.tableName, \"junctionEntity\");\r\n\r\n        const firstColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata!.columns[0].databaseName : relation.junctionEntityMetadata!.columns[1].databaseName);\r\n        const secondColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata!.columns[1].databaseName : relation.junctionEntityMetadata!.columns[0].databaseName);\r\n\r\n        relatedEntityIds.forEach((relatedEntityId, index) => {\r\n            qb.orWhere(`(${firstColumnName}=:entityId AND ${secondColumnName}=:relatedEntity_${index})`)\r\n                .setParameter(\"relatedEntity_\" + index, relatedEntityId);\r\n        });\r\n\r\n        await qb\r\n            .setParameter(\"entityId\", entityId)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationProperty: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\r\n        const propertyPath = this.metadata.computePropertyPath(relationProperty);\r\n        const relation = this.metadata.findRelationWithPropertyPath(propertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${propertyPath} in entity was not found.`);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyPath} relation type is ${relation.relationType}`);\r\n\r\n        // check if given entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\r\n        if (!entityIds || !entityIds.length)\r\n            return Promise.resolve();\r\n\r\n        const qb = new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(relation.junctionEntityMetadata!.tableName, \"junctionEntity\");\r\n\r\n        const firstColumnName = relation.isOwning ? relation.junctionEntityMetadata!.columns[1].databaseName : relation.junctionEntityMetadata!.columns[0].databaseName;\r\n        const secondColumnName = relation.isOwning ? relation.junctionEntityMetadata!.columns[0].databaseName : relation.junctionEntityMetadata!.columns[1].databaseName;\r\n\r\n        entityIds.forEach((entityId, index) => {\r\n            qb.orWhere(`(${firstColumnName}=:relatedEntityId AND ${secondColumnName}=:entity_${index})`)\r\n              .setParameter(\"entity_\" + index, entityId);\r\n        });\r\n\r\n        await qb.setParameter(\"relatedEntityId\", relatedEntityId).execute();\r\n    }\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: string, entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: ((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: string|((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void> {\r\n        await Promise.all([\r\n            this.addToRelation(relation as any, entityId, addRelatedEntityIds),\r\n            this.removeFromRelation(relation as any, entityId, removeRelatedEntityIds)\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: string, relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: ((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: string|((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void> {\r\n        await Promise.all([\r\n            this.addToInverseRelation(relation as any, relatedEntityId, addEntityIds),\r\n            this.removeFromInverseRelation(relation as any, relatedEntityId, removeEntityIds)\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Removes entity with the given id.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeById(id: any): Promise<void> {\r\n        const alias = this.metadata.tableName;\r\n        const parameters: ObjectLiteral = {};\r\n        let condition = \"\";\r\n\r\n        if (this.metadata.hasMultiplePrimaryKeys) {\r\n            condition = this.metadata.primaryColumns.map(primaryColumn => {\r\n                parameters[primaryColumn.propertyName] = id[primaryColumn.propertyName];\r\n                return alias + \".\" + primaryColumn.propertyName + \"=:\" + primaryColumn.propertyName;\r\n            }).join(\" AND \");\r\n\r\n        } else {\r\n            condition = alias + \".\" + this.metadata.primaryColumns[0].propertyName + \"=:id\";\r\n            parameters[\"id\"] = id;\r\n        }\r\n\r\n        await new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(this.metadata.target, alias)\r\n            .where(condition, parameters)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Removes all entities with the given ids.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeByIds(ids: any[]): Promise<void> {\r\n        const alias = this.metadata.tableName;\r\n        const parameters: ObjectLiteral = {};\r\n        let condition = \"\";\r\n\r\n        if (this.metadata.hasMultiplePrimaryKeys) {\r\n            condition = ids.map((id, idIndex) => {\r\n                this.metadata.primaryColumns.map(primaryColumn => {\r\n                    parameters[primaryColumn.propertyName + \"_\" + idIndex] = id[primaryColumn.propertyName];\r\n                    return alias + \".\" + primaryColumn.propertyName + \"=:\" + primaryColumn.propertyName + \"_\" + idIndex;\r\n                }).join(\" AND \");\r\n            }).join(\" OR \");\r\n        } else {\r\n            condition = alias + \".\" + this.metadata.primaryColumns[0].propertyName + \" IN (:ids)\";\r\n            parameters[\"ids\"] = ids;\r\n        }\r\n\r\n        await new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(this.metadata.target, alias)\r\n            .where(condition, parameters)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Finds all relation ids in the given entities.\r\n     */\r\n    async findRelationIds(relationOrName: RelationMetadata|string|((...args: any[]) => any), entityOrEntities: Entity[]|Entity|any|any[], inIds?: any[], notInIds?: any[]): Promise<any[]> {\r\n\r\n        const relation = this.convertMixedRelationToMetadata(relationOrName);\r\n        if (!(entityOrEntities instanceof Array)) entityOrEntities = [entityOrEntities];\r\n        const entityReferencedColumns = relation.isOwning ? relation.joinColumns.map(joinColumn => joinColumn.referencedColumn!) : relation.inverseRelation!.inverseJoinColumns.map(joinColumn => joinColumn.referencedColumn!);\r\n        const ownerEntityColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation!.inverseJoinColumns;\r\n        const inverseEntityColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\r\n        const inverseEntityColumnNames = relation.isOwning ? relation.inverseJoinColumns.map(joinColumn => joinColumn.databaseName) : relation.inverseRelation!.joinColumns.map(joinColumn => joinColumn.databaseName);\r\n\r\n        let entityIds = this.convertEntityOrEntitiesToIdOrIds(entityReferencedColumns, entityOrEntities);\r\n        if (!(entityIds instanceof Array)) entityIds = [entityIds];\r\n\r\n        // filter out empty entity ids\r\n        entityIds = (entityIds as any[]).filter(entityId => entityId !== null && entityId !== undefined);\r\n\r\n        // if no entity ids at the end, then we don't need to load anything\r\n        if ((entityIds as any[]).length === 0)\r\n            return [];\r\n\r\n        // create shortcuts for better readability\r\n        const ea = (alias: string) => this.connection.driver.escapeAliasName(alias);\r\n        const ec = (column: string) => this.connection.driver.escapeColumnName(column);\r\n\r\n        let ids: any[] = [];\r\n        // console.log(\"entityOrEntities:\", entityOrEntities);\r\n        // console.log(\"entityIds:\", entityIds);\r\n        const promises = (entityIds as any[]).map((entityId: any) => {\r\n            const qb = new QueryBuilder(this.connection, this.queryRunnerProvider);\r\n            inverseEntityColumnNames.forEach(columnName => {\r\n                qb.select(ea(\"junction\") + \".\" + ec(columnName) + \" AS \" + ea(columnName));\r\n            });\r\n            qb.fromTable(relation.junctionEntityMetadata!.tableName, \"junction\");\r\n            Object.keys(entityId).forEach((columnName) => {\r\n                const junctionColumnName = ownerEntityColumns.find(joinColumn => joinColumn.referencedColumn!.databaseName === columnName);\r\n                qb.andWhere(ea(\"junction\") + \".\" + ec(junctionColumnName!.databaseName) + \"=:\" + junctionColumnName!.databaseName + \"_entityId\", {[junctionColumnName!.databaseName + \"_entityId\"]: entityId[columnName]});\r\n            });\r\n            // ownerEntityColumnNames.forEach(columnName => {\r\n            //     qb.andWhere(ea(\"junction\") + \".\" + ec(columnName) + \"=:\" + columnName + \"_entityId\", {[columnName + \"_entityId\"]: entityId});\r\n            // });\r\n\r\n            // todo: fix inIds\r\n            // if (inIds && inIds.length > 0)\r\n            //     qb.andWhere(ea(\"junction\") + \".\" + ec(inverseEntityColumnNames.fullName) + \" IN (:inIds)\", {inIds: inIds});\r\n            //\r\n            // if (notInIds && notInIds.length > 0)\r\n            //     qb.andWhere(ea(\"junction\") + \".\" + ec(inverseEntityColumnNames.fullName) + \" NOT IN (:notInIds)\", {notInIds: notInIds});\r\n\r\n            // console.log(qb.getSql());\r\n            return qb.getRawMany()\r\n                .then((results: any[]) => {\r\n                    // console.log(results);\r\n                    results.forEach(result => {\r\n                        ids.push(Object.keys(result).reduce((id, key) => {\r\n                            const junctionColumnName = inverseEntityColumns.find(joinColumn => joinColumn.databaseName === key)!;\r\n                            OrmUtils.mergeDeep(id, junctionColumnName.referencedColumn!.createValueMap(result[key]));\r\n                            return id;\r\n                        }, {} as ObjectLiteral));\r\n                    }); // todo: prepare result?\r\n                });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n        return ids;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Converts entity or entities to id or ids map.\r\n     */\r\n    protected convertEntityOrEntitiesToIdOrIds(columns: ColumnMetadata[], entityOrEntities: Entity[]|Entity|any|any[]): any|any[] {\r\n        if (entityOrEntities instanceof Array) {\r\n            return entityOrEntities.map(entity => this.convertEntityOrEntitiesToIdOrIds(columns, entity));\r\n\r\n        } else {\r\n            if (entityOrEntities instanceof Object) {\r\n                return columns.reduce((ids, column) => {\r\n                    ids[column.databaseName] = column.getEntityValue(entityOrEntities);\r\n                    return ids;\r\n                }, {} as ObjectLiteral);\r\n            } else {\r\n                return entityOrEntities;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts relation name, relation name in function into RelationMetadata.\r\n     */\r\n    protected convertMixedRelationToMetadata(relationOrName: RelationMetadata|string|((...args: any[]) => any)): RelationMetadata {\r\n        if (relationOrName instanceof RelationMetadata)\r\n            return relationOrName;\r\n\r\n        const relationPropertyPath = relationOrName instanceof Function ? relationOrName(this.metadata.propertiesMap) : relationOrName;\r\n        const relation = this.metadata.findRelationWithPropertyPath(relationPropertyPath);\r\n        if (!relation)\r\n            throw new Error(`Relation with property path ${relationPropertyPath} in entity was not found.`);\r\n        return relation;\r\n    }\r\n\r\n    /**\r\n     * Extracts unique objects from given entity and all its downside relations.\r\n     */\r\n    protected extractObjectsById(entity: any, metadata: EntityMetadata, entityWithIds: Subject[] = []): Promise<Subject[]> {\r\n        const promises = metadata.relations.map(relation => {\r\n            const relMetadata = relation.inverseEntityMetadata;\r\n\r\n            const value = relation.getEntityValue(entity);\r\n            if (!value)\r\n                return undefined;\r\n\r\n            if (value instanceof Array) {\r\n                const subPromises = value.map((subEntity: any) => {\r\n                    return this.extractObjectsById(subEntity, relMetadata, entityWithIds);\r\n                });\r\n                return Promise.all(subPromises);\r\n\r\n            } else {\r\n                return this.extractObjectsById(value, relMetadata, entityWithIds);\r\n            }\r\n        });\r\n\r\n        return Promise.all<any>(promises.filter(result => !!result)).then(() => {\r\n            if (!entityWithIds.find(entityWithId => entityWithId.entity === entity)) {\r\n                const entityWithId = new Subject(metadata, entity);\r\n                entityWithIds.push(entityWithId);\r\n            }\r\n\r\n            return entityWithIds;\r\n        });\r\n    }\r\n\r\n}"],"sourceRoot":".."}