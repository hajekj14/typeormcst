{"version":3,"sources":["../../src/repository/SpecificRepository.ts"],"names":[],"mappings":"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","file":"SpecificRepository.js","sourcesContent":["import {Connection} from \"../connection/Connection\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\r\nimport {Subject} from \"../persistence/Subject\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {QueryBuilder} from \"../query-builder/QueryBuilder\";\r\n\r\n/**\r\n * Repository for more specific operations.\r\n */\r\nexport class SpecificRepository<Entity extends ObjectLiteral> {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected connection: Connection,\r\n                protected metadata: EntityMetadata,\r\n                protected queryRunnerProvider?: QueryRunnerProvider) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationName: string, entityId: any, relatedEntityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setRelation(relationName: string|((t: Entity) => string|any), entityId: any, relatedEntityId: any): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\r\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n        if (relation.isManyToMany)\r\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\r\n\r\n        let table: string, values: any = {}, conditions: any = {};\r\n        if (relation.isOwning) {\r\n            table = relation.entityMetadata.table.name;\r\n            values[relation.name] = relatedEntityId;\r\n            conditions[relation.joinColumn.referencedColumn.fullName] = entityId;\r\n        } else {\r\n            table = relation.inverseEntityMetadata.table.name;\r\n            values[relation.inverseRelation.name] = relatedEntityId;\r\n            conditions[relation.inverseRelation.joinColumn.referencedColumn.fullName] = entityId;\r\n        }\r\n\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        await queryRunner.update(table, values, conditions);\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationName: string, relatedEntityId: any, entityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void>;\r\n\r\n    /**\r\n     * Sets given relatedEntityId to the value of the relation of the entity with entityId id.\r\n     * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async setInverseRelation(relationName: string|((t: Entity) => string|any), relatedEntityId: any, entityId: any): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)\r\n        //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n        if (relation.isManyToMany)\r\n            throw new Error(`Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.`);\r\n\r\n        let table: string, values: any = {}, conditions: any = {};\r\n        if (relation.isOwning) {\r\n            table = relation.inverseEntityMetadata.table.name;\r\n            values[relation.inverseRelation.name] = relatedEntityId;\r\n            conditions[relation.inverseRelation.joinColumn.referencedColumn.fullName] = entityId;\r\n        } else {\r\n            table = relation.entityMetadata.table.name;\r\n            values[relation.name] = relatedEntityId;\r\n            conditions[relation.joinColumn.referencedColumn.fullName] = entityId;\r\n        }\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        await queryRunner.update(table, values, conditions);\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToRelation(relationName: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        const insertPromises = relatedEntityIds.map(relatedEntityId => {\r\n            const values: any = {};\r\n            if (relation.isOwning) {\r\n                values[relation.junctionEntityMetadata.columns[0].fullName] = entityId;\r\n                values[relation.junctionEntityMetadata.columns[1].fullName] = relatedEntityId;\r\n            } else {\r\n                values[relation.junctionEntityMetadata.columns[1].fullName] = entityId;\r\n                values[relation.junctionEntityMetadata.columns[0].fullName] = relatedEntityId;\r\n            }\r\n\r\n            return queryRunner.insert(relation.junctionEntityMetadata.table.name, values);\r\n        });\r\n        await Promise.all(insertPromises);\r\n\r\n        if (!this.queryRunnerProvider) // means created by this method\r\n            await queryRunnerProvider.release(queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.\r\n     * Should be used when you want quickly and efficiently add a relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addToInverseRelation(relationName: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n\r\n\r\n        const queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider(this.connection.driver);\r\n        const queryRunner = await queryRunnerProvider.provide();\r\n        try {\r\n            const insertPromises = entityIds.map(entityId => {\r\n                const values: any = {};\r\n                if (relation.isOwning) {\r\n                    values[relation.junctionEntityMetadata.columns[0].fullName] = entityId;\r\n                    values[relation.junctionEntityMetadata.columns[1].fullName] = relatedEntityId;\r\n                } else {\r\n                    values[relation.junctionEntityMetadata.columns[1].fullName] = entityId;\r\n                    values[relation.junctionEntityMetadata.columns[0].fullName] = relatedEntityId;\r\n                }\r\n\r\n                return queryRunner.insert(relation.junctionEntityMetadata.table.name, values);\r\n            });\r\n            await Promise.all(insertPromises);\r\n\r\n        } finally {\r\n            if (!this.queryRunnerProvider) // means created by this method\r\n                await queryRunnerProvider.release(queryRunner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationName: string, entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationName: ((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromRelation(relationName: string|((t: Entity) => string|any), entityId: any, relatedEntityIds: any[]): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n\r\n        // check if given relation entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\r\n        if (!relatedEntityIds || !relatedEntityIds.length)\r\n            return Promise.resolve();\r\n\r\n        const qb = new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .fromTable(relation.junctionEntityMetadata.table.name, \"junctionEntity\");\r\n\r\n        const firstColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[0].fullName : relation.junctionEntityMetadata.columns[1].fullName);\r\n        const secondColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[1].fullName : relation.junctionEntityMetadata.columns[0].fullName);\r\n\r\n        relatedEntityIds.forEach((relatedEntityId, index) => {\r\n            qb.orWhere(`(${firstColumnName}=:entityId AND ${secondColumnName}=:relatedEntity_${index})`)\r\n                .setParameter(\"relatedEntity_\" + index, relatedEntityId);\r\n        });\r\n\r\n        await qb\r\n            .setParameter(\"entityId\", entityId)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationName: string, relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationName: ((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Removes a relation between two entities from relation's many-to-many table.\r\n     * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeFromInverseRelation(relationName: string|((t: Entity) => string|any), relatedEntityId: any, entityIds: any[]): Promise<void> {\r\n        const propertyName = this.metadata.computePropertyName(relationName);\r\n        if (!this.metadata.hasRelationWithPropertyName(propertyName))\r\n            throw new Error(`Relation ${propertyName} was not found in the ${this.metadata.name} entity.`);\r\n\r\n        const relation = this.metadata.findRelationWithPropertyName(propertyName);\r\n        if (!relation.isManyToMany)\r\n            throw new Error(`Only many-to-many relation supported for this operation. However ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);\r\n\r\n        // check if given entity ids is empty - then nothing to do here (otherwise next code will remove all ids)\r\n        if (!entityIds || !entityIds.length)\r\n            return Promise.resolve();\r\n\r\n        const qb = new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(relation.junctionEntityMetadata.table.name, \"junctionEntity\");\r\n\r\n        const firstColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[1].fullName : relation.junctionEntityMetadata.columns[0].fullName;\r\n        const secondColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[0].fullName : relation.junctionEntityMetadata.columns[1].fullName;\r\n\r\n        entityIds.forEach((entityId, index) => {\r\n            qb.orWhere(`(${firstColumnName}=:relatedEntityId AND ${secondColumnName}=:entity_${index})`)\r\n              .setParameter(\"entity_\" + index, entityId);\r\n        });\r\n\r\n        await qb.setParameter(\"relatedEntityId\", relatedEntityId).execute();\r\n    }\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: string, entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: ((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromRelation(relation: string|((t: Entity) => string|any), entityId: any, addRelatedEntityIds: any[], removeRelatedEntityIds: any[]): Promise<void> {\r\n        await Promise.all([\r\n            this.addToRelation(relation as any, entityId, addRelatedEntityIds),\r\n            this.removeFromRelation(relation as any, entityId, removeRelatedEntityIds)\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: string, relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: ((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void>;\r\n\r\n    /**\r\n     * Performs both #addToRelation and #removeFromRelation operations.\r\n     * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async addAndRemoveFromInverseRelation(relation: string|((t: Entity) => string|any), relatedEntityId: any, addEntityIds: any[], removeEntityIds: any[]): Promise<void> {\r\n        await Promise.all([\r\n            this.addToInverseRelation(relation as any, relatedEntityId, addEntityIds),\r\n            this.removeFromInverseRelation(relation as any, relatedEntityId, removeEntityIds)\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Removes entity with the given id.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeById(id: any): Promise<void> {\r\n        const alias = this.metadata.table.name;\r\n        const parameters: ObjectLiteral = {};\r\n        let condition = \"\";\r\n\r\n        if (this.metadata.hasMultiplePrimaryKeys) {\r\n            condition = this.metadata.primaryColumns.map(primaryColumn => {\r\n                parameters[primaryColumn.propertyName] = id[primaryColumn.propertyName];\r\n                return alias + \".\" + primaryColumn.propertyName + \"=:\" + primaryColumn.propertyName;\r\n            }).join(\" AND \");\r\n\r\n        } else {\r\n            condition = alias + \".\" + this.metadata.firstPrimaryColumn.propertyName + \"=:id\";\r\n            parameters[\"id\"] = id;\r\n        }\r\n\r\n        await new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(this.metadata.target, alias)\r\n            .where(condition, parameters)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Removes all entities with the given ids.\r\n     * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.\r\n     */\r\n    async removeByIds(ids: any[]): Promise<void> {\r\n        const alias = this.metadata.table.name;\r\n        const parameters: ObjectLiteral = {};\r\n        let condition = \"\";\r\n\r\n        if (this.metadata.hasMultiplePrimaryKeys) {\r\n            condition = ids.map((id, idIndex) => {\r\n                this.metadata.primaryColumns.map(primaryColumn => {\r\n                    parameters[primaryColumn.propertyName + \"_\" + idIndex] = id[primaryColumn.propertyName];\r\n                    return alias + \".\" + primaryColumn.propertyName + \"=:\" + primaryColumn.propertyName + \"_\" + idIndex;\r\n                }).join(\" AND \");\r\n            }).join(\" OR \");\r\n        } else {\r\n            condition = alias + \".\" + this.metadata.firstPrimaryColumn.propertyName + \" IN (:ids)\";\r\n            parameters[\"ids\"] = ids;\r\n        }\r\n\r\n        await new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n            .delete()\r\n            .from(this.metadata.target, alias)\r\n            .where(condition, parameters)\r\n            .execute();\r\n    }\r\n\r\n    /**\r\n     * Finds all relation ids in the given entities.\r\n     */\r\n    async findRelationIds(relationOrName: RelationMetadata|string|((...args: any[]) => any), entityOrEntities: Entity[]|Entity|any|any[], inIds?: any[], notInIds?: any[]): Promise<any[]> {\r\n\r\n        const relation = this.convertMixedRelationToMetadata(relationOrName);\r\n        if (!(entityOrEntities instanceof Array)) entityOrEntities = [entityOrEntities];\r\n\r\n        const entityReferencedColumn = relation.isOwning ? relation.joinTable.referencedColumn : relation.inverseRelation.joinTable.inverseReferencedColumn;\r\n        const ownerEntityColumn = relation.isOwning ? relation.junctionEntityMetadata.columns[0] : relation.junctionEntityMetadata.columns[1];\r\n        const inverseEntityColumn = relation.isOwning ? relation.junctionEntityMetadata.columns[1] : relation.junctionEntityMetadata.columns[0];\r\n\r\n        let entityIds = this.convertEntityOrEntitiesToIdOrIds(entityReferencedColumn, entityOrEntities);\r\n        if (!(entityIds instanceof Array)) entityIds = [entityIds];\r\n\r\n        // filter out empty entity ids\r\n        entityIds = (entityIds as any[]).filter(entityId => entityId !== null && entityId !== undefined);\r\n\r\n        // if no entity ids at the end, then we don't need to load anything\r\n        if ((entityIds as any[]).length === 0)\r\n            return [];\r\n\r\n        // create shortcuts for better readability\r\n        const escapeAlias = (alias: string) => this.connection.driver.escapeAliasName(alias);\r\n        const escapeColumn = (column: string) => this.connection.driver.escapeColumnName(column);\r\n\r\n        const ids: any[] = [];\r\n        const promises = (entityIds as any[]).map((entityId: any) => {\r\n            const qb = new QueryBuilder(this.connection, this.queryRunnerProvider)\r\n                .select(escapeAlias(\"junction\") + \".\" + escapeColumn(inverseEntityColumn.fullName) + \" AS \" + escapeColumn(\"id\"))\r\n                .fromTable(relation.junctionEntityMetadata.table.name, \"junction\")\r\n                .andWhere(escapeAlias(\"junction\") + \".\" + escapeColumn(ownerEntityColumn.fullName) + \"=:entityId\", {entityId: entityId});\r\n\r\n            if (inIds && inIds.length > 0)\r\n                qb.andWhere(escapeAlias(\"junction\") + \".\" + escapeColumn(inverseEntityColumn.fullName) + \" IN (:inIds)\", {inIds: inIds});\r\n\r\n            if (notInIds && notInIds.length > 0)\r\n                qb.andWhere(escapeAlias(\"junction\") + \".\" + escapeColumn(inverseEntityColumn.fullName) + \" NOT IN (:notInIds)\", {notInIds: notInIds});\r\n\r\n            return qb.getRawMany()\r\n                .then((results: { id: any }[]) => {\r\n                    results.forEach(result => ids.push(result.id)); // todo: prepare result?\r\n                });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n        return ids;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Converts entity or entities to id or ids map.\r\n     */\r\n    protected convertEntityOrEntitiesToIdOrIds(column: ColumnMetadata, entityOrEntities: Entity[]|Entity|any|any[]): any|any[] {\r\n        if (entityOrEntities instanceof Array) {\r\n            return entityOrEntities.map(entity => this.convertEntityOrEntitiesToIdOrIds(column, entity));\r\n\r\n        } else {\r\n            if (entityOrEntities instanceof Object) {\r\n                return entityOrEntities[column.propertyName];\r\n            } else {\r\n                return entityOrEntities;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts relation name, relation name in function into RelationMetadata.\r\n     */\r\n    protected convertMixedRelationToMetadata(relationOrName: RelationMetadata|string|((...args: any[]) => any)): RelationMetadata {\r\n        if (relationOrName instanceof RelationMetadata)\r\n            return relationOrName;\r\n\r\n        const relationName = relationOrName instanceof Function ? relationOrName(this.metadata.createPropertiesMap()) : relationOrName;\r\n        return this.metadata.findRelationWithPropertyName(relationName);\r\n    }\r\n\r\n    /**\r\n     * Extracts unique objects from given entity and all its downside relations.\r\n     */\r\n    protected extractObjectsById(entity: any, metadata: EntityMetadata, entityWithIds: Subject[] = []): Promise<Subject[]> {\r\n        const promises = metadata.relations.map(relation => {\r\n            const relMetadata = relation.inverseEntityMetadata;\r\n\r\n            const value = relation.isLazy ? entity[\"__\" + relation.propertyName + \"__\"] : entity[relation.propertyName];\r\n            if (!value)\r\n                return undefined;\r\n\r\n            if (value instanceof Array) {\r\n                const subPromises = value.map((subEntity: any) => {\r\n                    return this.extractObjectsById(subEntity, relMetadata, entityWithIds);\r\n                });\r\n                return Promise.all(subPromises);\r\n\r\n            } else {\r\n                return this.extractObjectsById(value, relMetadata, entityWithIds);\r\n            }\r\n        });\r\n\r\n        return Promise.all<any>(promises.filter(result => !!result)).then(() => {\r\n            if (!entityWithIds.find(entityWithId => entityWithId.entity === entity)) {\r\n                const entityWithId = new Subject(metadata, entity);\r\n                entityWithIds.push(entityWithId);\r\n            }\r\n\r\n            return entityWithIds;\r\n        });\r\n    }\r\n\r\n}"],"sourceRoot":".."}