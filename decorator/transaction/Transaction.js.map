{"version":3,"sources":["../../src/decorator/transaction/Transaction.ts"],"names":[],"mappings":";;AAAA,qCAAkE;AAElE;;;;;;;GAOG;AACH,qBAA4B,cAAkC;IAAlC,+BAAA,EAAA,0BAAkC;IAC1D,MAAM,CAAC,UAAU,MAAc,EAAE,UAAkB,EAAE,UAA8B;QAE/E,0CAA0C;QAC1C,IAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;QAExC,+CAA+C;QAC/C,UAAU,CAAC,KAAK,GAAG;YAAA,iBAsBlB;YAtB2B,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,yBAAc;;YACtC,MAAM,CAAC,qBAAa,CAAC,cAAc,CAAC;iBAC/B,OAAO;iBACP,WAAW,CAAC,UAAA,aAAa;gBAEtB,wEAAwE;gBACxE,IAAM,OAAO,GAAG,8BAAsB,EAAE;qBACnC,+BAA+B,CAAC,MAAM,CAAC,WAAW,CAAC;qBACnD,MAAM,CAAC,UAAA,wBAAwB,IAAI,OAAA,wBAAwB,CAAC,UAAU,KAAK,UAAU,EAAlD,CAAkD,CAAC;qBACtF,GAAG,CAAC,UAAA,wBAAwB,IAAI,OAAA,wBAAwB,CAAC,KAAK,EAA9B,CAA8B,CAAC,CAAC;gBAErE,IAAI,6BAAoC,CAAC;gBACzC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;oBACjB,6BAA6B,GAAO,IAAI,QAAC,CAAC;oBAC1C,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,6BAA6B,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,aAAa,CAAC,EAA7D,CAA6D,CAAC,CAAC;gBAE5F,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACJ,6BAA6B,IAAI,aAAa,SAAK,IAAI,CAAC,CAAC;gBAC7D,CAAC;gBAED,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,KAAI,EAAE,6BAA6B,CAAC,CAAC;YACrE,CAAC,CAAC,CAAC;QACX,CAAC,CAAC;IACN,CAAC,CAAC;AACN,CAAC;AA/BD,kCA+BC","file":"Transaction.js","sourcesContent":["import {getConnection, getMetadataArgsStorage} from \"../../index\";\r\n\r\n/**\r\n * Wraps some method into the transaction.\r\n * Note, method result will return a promise if this decorator applied.\r\n * Note, all database operations in the wrapped method should be executed using entity managed passed as a first parameter\r\n * into the wrapped method.\r\n * If you want to control at what position in your method parameters entity manager should be injected,\r\n * then use @TransactionEntityManager() decorator.\r\n */\r\nexport function Transaction(connectionName: string = \"default\"): Function {\r\n    return function (target: Object, methodName: string, descriptor: PropertyDescriptor) {\r\n\r\n        // save original method - we gonna need it\r\n        const originalMethod = descriptor.value;\r\n\r\n        // override method descriptor with proxy method\r\n        descriptor.value = function(...args: any[]) {\r\n            return getConnection(connectionName)\r\n                .manager\r\n                .transaction(entityManager => {\r\n\r\n                    // gets all @TransactionEntityManager() decorator usages for this method\r\n                    const indices = getMetadataArgsStorage()\r\n                        .filterTransactionEntityManagers(target.constructor)\r\n                        .filter(transactionEntityManager => transactionEntityManager.methodName === methodName)\r\n                        .map(transactionEntityManager => transactionEntityManager.index);\r\n\r\n                    let argsWithInjectedEntityManager: any[];\r\n                    if (indices.length) { // if there are @TransactionEntityManager() decorator usages the inject them\r\n                        argsWithInjectedEntityManager = [...args];\r\n                        indices.forEach(index => argsWithInjectedEntityManager.splice(index, 0, entityManager));\r\n\r\n                    } else { // otherwise inject it as a first parameter\r\n                        argsWithInjectedEntityManager = [entityManager, ...args];\r\n                    }\r\n\r\n                    return originalMethod.apply(this, argsWithInjectedEntityManager);\r\n                });\r\n        };\r\n    };\r\n}\r\n"],"sourceRoot":"../.."}