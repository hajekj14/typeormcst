{"version":3,"sources":["../../src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","file":"Broadcaster.js","sourcesContent":["import {EntitySubscriberInterface} from \"./EntitySubscriberInterface\";\r\nimport {EventListenerTypes} from \"../metadata/types/EventListenerTypes\";\r\nimport {EntityListenerMetadata} from \"../metadata/EntityListenerMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {Subject} from \"../persistence/Subject\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {EntityManager} from \"../entity-manager/EntityManager\";\r\n\r\n/**\r\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\r\n */\r\nexport class Broadcaster {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private connection: Connection,\r\n                private subscriberMetadatas: EntitySubscriberInterface<any>[],\r\n                private entityListeners: EntityListenerMetadata[]) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\r\n     */\r\n    async broadcastBeforeEventsForAll(entityManager: EntityManager, insertSubjects: Subject[], updateSubjects: Subject[], removeSubjects: Subject[]): Promise<void> {\r\n        const insertPromises = insertSubjects.map(subject => this.broadcastBeforeInsertEvent(entityManager, subject));\r\n        const updatePromises = updateSubjects.map(subject => this.broadcastBeforeUpdateEvent(entityManager, subject));\r\n        const removePromises = removeSubjects.map(subject => this.broadcastBeforeRemoveEvent(entityManager, subject));\r\n        const allPromises = insertPromises.concat(updatePromises).concat(removePromises);\r\n        await Promise.all(allPromises);\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\r\n     */\r\n    async broadcastAfterEventsForAll(entityManager: EntityManager, insertSubjects: Subject[], updateSubjects: Subject[], removeSubjects: Subject[]): Promise<void> {\r\n        const insertPromises = insertSubjects.map(subject => this.broadcastAfterInsertEvent(entityManager, subject));\r\n        const updatePromises = updateSubjects.map(subject => this.broadcastAfterUpdateEvent(entityManager, subject));\r\n        const removePromises = removeSubjects.map(subject => this.broadcastAfterRemoveEvent(entityManager, subject));\r\n        const allPromises = insertPromises.concat(updatePromises).concat(removePromises);\r\n        await Promise.all(allPromises);\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_INSERT\" event.\r\n     * Before insert event is executed before entity is being inserted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastBeforeInsertEvent(entityManager: EntityManager, subject: Subject): Promise<void> {\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_INSERT && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.entity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeInsert)\r\n            .map(subscriber => subscriber.beforeInsert!({\r\n                entityManager: entityManager,\r\n                entity: subject.entity\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_UPDATE\" event.\r\n     * Before update event is executed before entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastBeforeUpdateEvent(entityManager: EntityManager, subject: Subject): Promise<void> { // todo: send relations too?\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_UPDATE && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.entity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeUpdate)\r\n            .map(subscriber => subscriber.beforeUpdate!({\r\n                entityManager: entityManager,\r\n                entity: subject.entity,\r\n                databaseEntity: subject.databaseEntity,\r\n                updatedColumns: subject.diffColumns,\r\n                updatedRelations: subject.diffRelations,\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_REMOVE\" event.\r\n     * Before remove event is executed before entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastBeforeRemoveEvent(entityManager: EntityManager, subject: Subject): Promise<void> {\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.BEFORE_REMOVE && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.databaseEntity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeRemove)\r\n            .map(subscriber => subscriber.beforeRemove!({\r\n                entityManager: entityManager,\r\n                entity: subject.hasEntity ? subject.entity : undefined,\r\n                databaseEntity: subject.databaseEntity,\r\n                entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_INSERT\" event.\r\n     * After insert event is executed after entity is being persisted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastAfterInsertEvent(entityManager: EntityManager, subject: Subject): Promise<void> {\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.AFTER_INSERT && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.entity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterInsert)\r\n            .map(subscriber => subscriber.afterInsert!({\r\n                entityManager: entityManager,\r\n                entity: subject.entity\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_UPDATE\" event.\r\n     * After update event is executed after entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastAfterUpdateEvent(entityManager: EntityManager, subject: Subject): Promise<void> {\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.AFTER_UPDATE && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.entity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterUpdate)\r\n            .map(subscriber => subscriber.afterUpdate!({\r\n                entityManager: entityManager,\r\n                entity: subject.entity,\r\n                databaseEntity: subject.databaseEntity,\r\n                updatedColumns: subject.diffColumns,\r\n                updatedRelations: subject.diffRelations,\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_REMOVE\" event.\r\n     * After remove event is executed after entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastAfterRemoveEvent(entityManager: EntityManager, subject: Subject): Promise<void> {\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.AFTER_REMOVE && this.isAllowedListener(listener, subject.entity))\r\n            .map(entityListener => subject.entity[entityListener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterRemove)\r\n            .map(subscriber => subscriber.afterRemove!({\r\n                entityManager: entityManager,\r\n                entity: subject.hasEntity ? subject.entity : undefined,\r\n                databaseEntity: subject.databaseEntity,\r\n                entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)\r\n            }));\r\n\r\n        await Promise.all(listeners.concat(subscribers));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\r\n     * After load event is executed after entity has been loaded from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastLoadEventsForAll(target: Function|string, entities: ObjectLiteral[]): Promise<void> {\r\n        await Promise.all(entities.map(entity => this.broadcastLoadEvents(target, entity)));\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_LOAD\" event for the given entity and all its sub-entities.\r\n     * After load event is executed after entity has been loaded from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     */\r\n    async broadcastLoadEvents(target: Function|string, entity: ObjectLiteral): Promise<void> {\r\n        if (entity instanceof Promise) // todo: check why need this?\r\n            return;\r\n\r\n        // collect load events for all children entities that were loaded with the main entity\r\n        const children = this.connection.getMetadata(target).relations.reduce((promises, relation) => {\r\n            if (!entity.hasOwnProperty(relation.propertyName))\r\n                return promises;\r\n\r\n            const value = relation.getEntityValue(entity);\r\n            if (value instanceof Array) {\r\n                promises = promises.concat(this.broadcastLoadEventsForAll(relation.inverseEntityMetadata.target, value));\r\n            } else if (value) {\r\n                promises.push(this.broadcastLoadEvents(relation.inverseEntityMetadata.target, value));\r\n            }\r\n\r\n            return promises;\r\n        }, [] as Promise<void>[]);\r\n\r\n        const listeners = this.entityListeners\r\n            .filter(listener => listener.type === EventListenerTypes.AFTER_LOAD && this.isAllowedListener(listener, entity))\r\n            .map(listener => entity[listener.propertyName]());\r\n\r\n        const subscribers = this.subscriberMetadatas\r\n            .filter(subscriber => this.isAllowedSubscriber(subscriber, target) && subscriber.afterLoad)\r\n            .map(subscriber => subscriber.afterLoad!(entity));\r\n\r\n        await Promise.all(children.concat(listeners.concat(subscribers)));\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Checks if entity listener is allowed to be executed on the given entity.\r\n     */\r\n    protected isAllowedListener(listener: EntityListenerMetadata, entity: ObjectLiteral) {\r\n        // todo: create in entity metadata method like isInherited\r\n        return listener.target === entity.constructor || // todo: .constructor won't work for entity schemas\r\n            (listener.target instanceof Function && entity.constructor.prototype instanceof listener.target); // todo: also need to implement entity schema inheritance\r\n    }\r\n\r\n    /**\r\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\r\n     * or listens our entity.\r\n     */\r\n    protected isAllowedSubscriber(subscriber: EntitySubscriberInterface<any>, target: Function|string): boolean {\r\n        return  !subscriber.listenTo ||\r\n                !subscriber.listenTo() ||\r\n                subscriber.listenTo() === Object ||\r\n                subscriber.listenTo() === target;\r\n    }\r\n\r\n}"],"sourceRoot":".."}