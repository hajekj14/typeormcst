var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
System.register("typeorm/driver/DriverOptions", [], function (exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/ColumnTypes", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    var ColumnTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * All data types that column can be.
             */
            ColumnTypes = (function () {
                function ColumnTypes() {
                }
                /**
                 * Checks if given type in a string format is supported by ORM.
                 */
                ColumnTypes.isTypeSupported = function (type) {
                    return this.supportedTypes.indexOf(type) !== -1;
                };
                Object.defineProperty(ColumnTypes, "supportedTypes", {
                    /**
                     * Returns list of all supported types by the ORM.
                     */
                    get: function () {
                        return [
                            this.STRING,
                            this.TEXT,
                            this.NUMBER,
                            this.INTEGER,
                            this.INT,
                            this.SMALLINT,
                            this.BIGINT,
                            this.FLOAT,
                            this.DOUBLE,
                            this.DECIMAL,
                            this.DATE,
                            this.TIME,
                            this.DATETIME,
                            this.BOOLEAN,
                            this.JSON,
                            this.JSONB,
                            this.SIMPLE_ARRAY,
                            this.UUID
                        ];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Tries to guess a column type from the given function.
                 */
                ColumnTypes.determineTypeFromFunction = function (type) {
                    if (type instanceof Date) {
                        return ColumnTypes.DATETIME;
                    }
                    else if (type instanceof Function) {
                        var typeName = type.name.toLowerCase();
                        switch (typeName) {
                            case "number":
                                return ColumnTypes.NUMBER;
                            case "boolean":
                                return ColumnTypes.BOOLEAN;
                            case "string":
                                return ColumnTypes.STRING;
                            case "date":
                                return ColumnTypes.DATETIME;
                            case "object":
                                return ColumnTypes.JSON;
                        }
                    }
                    else if (type instanceof Object) {
                        return ColumnTypes.JSON;
                    }
                    return undefined;
                };
                ColumnTypes.typeToString = function (type) {
                    return type.name.toLowerCase();
                };
                /**
                 * Checks if column type is numeric.
                 */
                ColumnTypes.isNumeric = function (type) {
                    return type === ColumnTypes.NUMBER ||
                        type === ColumnTypes.INT ||
                        type === ColumnTypes.INTEGER ||
                        type === ColumnTypes.BIGINT ||
                        type === ColumnTypes.SMALLINT ||
                        type === ColumnTypes.DOUBLE ||
                        type === ColumnTypes.FLOAT;
                };
                return ColumnTypes;
            }());
            /**
             * SQL VARCHAR type. Your class's property type should be a "string".
             */
            ColumnTypes.STRING = "string";
            /**
             * SQL CLOB type. Your class's property type should be a "string".
             */
            ColumnTypes.TEXT = "text";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.NUMBER = "number";
            /**
             * SQL INT type. Your class's property type should be a "number".
             */
            ColumnTypes.INTEGER = "integer";
            /**
             * SQL INT type. Your class's property type should be a "number".
             */
            ColumnTypes.INT = "int";
            /**
             * SQL SMALLINT type. Your class's property type should be a "number".
             */
            ColumnTypes.SMALLINT = "smallint";
            /**
             * SQL BIGINT type. Your class's property type should be a "number".
             */
            ColumnTypes.BIGINT = "bigint";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.FLOAT = "float";
            /**
             * SQL FLOAT type. Your class's property type should be a "number".
             */
            ColumnTypes.DOUBLE = "double";
            /**
             * SQL DECIMAL type. Your class's property type should be a "string".
             */
            ColumnTypes.DECIMAL = "decimal";
            /**
             * SQL DATETIME type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.DATE = "date";
            /**
             * SQL TIME type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.TIME = "time";
            /**
             * SQL DATETIME/TIMESTAMP type. Your class's property type should be a "Date" object.
             */
            ColumnTypes.DATETIME = "datetime";
            /**
             * SQL BOOLEAN type. Your class's property type should be a "boolean".
             */
            ColumnTypes.BOOLEAN = "boolean";
            /**
             * SQL CLOB type. Your class's property type should be any Object.
             */
            ColumnTypes.JSON = "json";
            /**
             * Postgres jsonb type. Your class's property type should be any Object.
             */
            ColumnTypes.JSONB = "jsonb";
            /**
             * SQL CLOB type. Your class's property type should be array of string. Note: value in this column should not contain
             * a comma (",") since this symbol is used to create a string from the array, using .join(",") operator.
             */
            ColumnTypes.SIMPLE_ARRAY = "simple_array";
            /**
             * UUID type. Serialized to a string in typescript or javascript
             */
            ColumnTypes.UUID = "uuid";
            exports_2("ColumnTypes", ColumnTypes);
        }
    };
});
System.register("typeorm/metadata/types/RelationTypes", [], function (exports_3, context_3) {
    "use strict";
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/naming-strategy/NamingStrategyInterface", [], function (exports_4, context_4) {
    "use strict";
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/OnDeleteType", [], function (exports_5, context_5) {
    "use strict";
    var __moduleName = context_5 && context_5.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/ForeignKeyMetadata", [], function (exports_6, context_6) {
    "use strict";
    var __moduleName = context_6 && context_6.id;
    var ForeignKeyMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's foreign key.
             */
            ForeignKeyMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function ForeignKeyMetadata(options) {
                    /**
                     * Array of columns of this foreign key.
                     */
                    this.columns = [];
                    /**
                     * Array of referenced columns.
                     */
                    this.referencedColumns = [];
                    /**
                     * Gets array of column names.
                     */
                    this.columnNames = [];
                    /**
                     * Gets array of referenced column names.
                     */
                    this.referencedColumnNames = [];
                    this.entityMetadata = options.entityMetadata;
                    this.referencedEntityMetadata = options.referencedEntityMetadata;
                    this.columns = options.columns;
                    this.referencedColumns = options.referencedColumns;
                    this.onDelete = options.onDelete;
                    if (options.namingStrategy)
                        this.build(options.namingStrategy);
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend foreign key properties.
                 * Must be called after all entity metadatas and their columns are built.
                 */
                ForeignKeyMetadata.prototype.build = function (namingStrategy) {
                    this.columnNames = this.columns.map(function (column) { return column.databaseName; });
                    this.referencedColumnNames = this.referencedColumns.map(function (column) { return column.databaseName; });
                    this.tableName = this.entityMetadata.tableName;
                    this.referencedTableName = this.referencedEntityMetadata.tableName;
                    this.name = namingStrategy.foreignKeyName(this.tableName, this.columnNames, this.referencedEntityMetadata.tableName, this.referencedColumnNames);
                };
                return ForeignKeyMetadata;
            }());
            exports_6("ForeignKeyMetadata", ForeignKeyMetadata);
        }
    };
});
System.register("typeorm/common/ObjectLiteral", [], function (exports_7, context_7) {
    "use strict";
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EmbeddedMetadataArgs", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/error/ConnectionIsNotSetError", [], function (exports_9, context_9) {
    "use strict";
    var __moduleName = context_9 && context_9.id;
    var ConnectionIsNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when user tries to execute operation that requires connection to be established.
             */
            ConnectionIsNotSetError = (function (_super) {
                __extends(ConnectionIsNotSetError, _super);
                function ConnectionIsNotSetError(dbType) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionIsNotSetError";
                    _this.message = "Connection with " + dbType + " database is not established. Check connection configuration.";
                    return _this;
                }
                return ConnectionIsNotSetError;
            }(Error));
            exports_9("ConnectionIsNotSetError", ConnectionIsNotSetError);
        }
    };
});
System.register("typeorm/driver/DatabaseConnection", [], function (exports_10, context_10) {
    "use strict";
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/error/DriverPackageNotInstalledError", [], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    var DriverPackageNotInstalledError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when required driver's package is not installed.
             */
            DriverPackageNotInstalledError = (function (_super) {
                __extends(DriverPackageNotInstalledError, _super);
                function DriverPackageNotInstalledError(driverName, packageName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPackageNotInstalledError";
                    _this.message = driverName + " package has not been found installed. Try to install it: npm install " + packageName + " --save";
                    return _this;
                }
                return DriverPackageNotInstalledError;
            }(Error));
            exports_11("DriverPackageNotInstalledError", DriverPackageNotInstalledError);
        }
    };
});
System.register("typeorm/driver/DriverUtils", [], function (exports_12, context_12) {
    "use strict";
    var __moduleName = context_12 && context_12.id;
    var DriverUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Common driver utility functions.
             */
            DriverUtils = (function () {
                function DriverUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes and builds a new driver options.
                 * Extracts settings from connection url and sets to a new options object.
                 */
                DriverUtils.buildDriverOptions = function (options, buildOptions) {
                    if (options.url) {
                        var parsedUrl = this.parseConnectionUrl(options.url);
                        if (buildOptions && buildOptions.useSid) {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                sid: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                        else {
                            var urlDriverOptions = {
                                type: options.type,
                                host: parsedUrl.host,
                                username: parsedUrl.username,
                                password: parsedUrl.password,
                                port: parsedUrl.port,
                                database: parsedUrl.database
                            };
                            return Object.assign(urlDriverOptions, options);
                        }
                    }
                    return Object.assign({}, options);
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Extracts connection data from the connection url.
                 */
                DriverUtils.parseConnectionUrl = function (url) {
                    var firstSlashes = url.indexOf("//");
                    var preBase = url.substr(firstSlashes + 2);
                    var secondSlash = preBase.indexOf("/");
                    var base = (secondSlash !== -1) ? preBase.substr(0, secondSlash) : preBase;
                    var afterBase = (secondSlash !== -1) ? preBase.substr(secondSlash + 1) : undefined;
                    var _a = base.split("@"), usernameAndPassword = _a[0], hostAndPort = _a[1];
                    var _b = usernameAndPassword.split(":"), username = _b[0], password = _b[1];
                    var _c = hostAndPort.split(":"), host = _c[0], port = _c[1];
                    return {
                        host: host,
                        username: username,
                        password: password,
                        port: port ? parseInt(port) : undefined,
                        database: afterBase || undefined
                    };
                };
                return DriverUtils;
            }());
            exports_12("DriverUtils", DriverUtils);
        }
    };
});
System.register("typeorm/logger/LoggerOptions", [], function (exports_13, context_13) {
    "use strict";
    var __moduleName = context_13 && context_13.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/platform/PlatformTools", [], function (exports_14, context_14) {
    "use strict";
    var __moduleName = context_14 && context_14.id;
    var PlatformTools;
    return {
        setters: [],
        execute: function () {
            /**
             * Browser's implementation of the platform-specific tools.
             *
             * This file gonna replace PlatformTools for browser environment.
             * For node.js environment this class is not getting packaged.
             * Don't use methods of this class in the code, use PlatformTools methods instead.
             */
            PlatformTools = (function () {
                function PlatformTools() {
                }
                /**
                 * Gets global variable where global stuff can be stored.
                 */
                PlatformTools.getGlobalVariable = function () {
                    return window;
                };
                /**
                 * Loads ("require"-s) given file or package.
                 * This operation only supports on node platform
                 */
                PlatformTools.load = function (name) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: require(\"" + name + "\").");
                    return "";
                };
                /**
                 * Normalizes given path. Does "path.normalize".
                 */
                PlatformTools.pathNormilize = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.normalize(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Gets file extension. Does "path.extname".
                 */
                PlatformTools.pathExtname = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.extname(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Resolved given path. Does "path.resolve".
                 */
                PlatformTools.pathResolve = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: path.resolve(\"" + pathStr + "\").");
                    return "";
                };
                /**
                 * Synchronously checks if file exist. Does "fs.existsSync".
                 */
                PlatformTools.fileExist = function (pathStr) {
                    if (this.type === "browser")
                        throw new Error("This option/function is not supported in the browser environment. Failed operation: fs.existsSync(\"" + pathStr + "\").");
                    return false;
                };
                /**
                 * Gets environment variable.
                 */
                PlatformTools.getEnvVariable = function (name) {
                    // if (this.type === "browser")
                    //     throw new Error(`This option/function is not supported in the browser environment. Failed operation: process.env["${name}"].`);
                    return undefined;
                };
                return PlatformTools;
            }());
            /**
             * Type of the currently running platform.
             */
            PlatformTools.type = "browser";
            exports_14("PlatformTools", PlatformTools);
        }
    };
});
System.register("typeorm/logger/Logger", ["typeorm/platform/PlatformTools"], function (exports_15, context_15) {
    "use strict";
    var __moduleName = context_15 && context_15.id;
    var PlatformTools_1, Logger;
    return {
        setters: [
            function (PlatformTools_1_1) {
                PlatformTools_1 = PlatformTools_1_1;
            }
        ],
        execute: function () {
            /**
             * Performs logging of the events in TypeORM.
             */
            Logger = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Logger(options) {
                    this.options = options;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Logs query and parameters used in it.
                 */
                Logger.prototype.logQuery = function (query, parameters) {
                    if (this.options.logQueries ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("log", "executing query: " + query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : ""));
                };
                /**
                 * Logs query that failed.
                 */
                Logger.prototype.logFailedQuery = function (query, parameters) {
                    if (this.options.logQueries ||
                        this.options.logOnlyFailedQueries ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("error", "query failed: " + query + (parameters && parameters.length ? " -- PARAMETERS: " + this.stringifyParams(parameters) : ""));
                };
                /**
                 * Logs failed query's error.
                 */
                Logger.prototype.logQueryError = function (error) {
                    if (this.options.logFailedQueryError ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("error", "error during executing query:" + error);
                };
                /**
                 * Logs events from the schema build process.
                 */
                Logger.prototype.logSchemaBuild = function (message) {
                    if (this.options.logSchemaCreation ||
                        PlatformTools_1.PlatformTools.getEnvVariable("LOGGER_CLI_SCHEMA_SYNC"))
                        this.log("info", message);
                };
                /**
                 * Perform logging using given logger, or by default to the console.
                 * Log has its own level and message.
                 */
                Logger.prototype.log = function (level, message) {
                    if (!this.options)
                        return;
                    if (this.options.logger) {
                        this.options.logger(level, message);
                    }
                    else {
                        switch (level) {
                            case "log":
                                console.log(message);
                                break;
                            case "info":
                                console.info(message);
                                break;
                            case "warn":
                                console.warn(message);
                                break;
                            case "error":
                                console.error(message);
                                break;
                        }
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts parameters to a string.
                 * Sometimes parameters can have circular objects and therefor we are handle this case too.
                 */
                Logger.prototype.stringifyParams = function (parameters) {
                    try {
                        return JSON.stringify(parameters);
                    }
                    catch (error) {
                        return parameters;
                    }
                };
                return Logger;
            }());
            exports_15("Logger", Logger);
        }
    };
});
System.register("typeorm/driver/error/TransactionAlreadyStartedError", [], function (exports_16, context_16) {
    "use strict";
    var __moduleName = context_16 && context_16.id;
    var TransactionAlreadyStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is already started and user tries to run it again.
             */
            TransactionAlreadyStartedError = (function (_super) {
                __extends(TransactionAlreadyStartedError, _super);
                function TransactionAlreadyStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionAlreadyStartedError";
                    _this.message = "Transaction already started for the given connection, commit current transaction before starting a new one.";
                    return _this;
                }
                return TransactionAlreadyStartedError;
            }(Error));
            exports_16("TransactionAlreadyStartedError", TransactionAlreadyStartedError);
        }
    };
});
System.register("typeorm/driver/error/TransactionNotStartedError", [], function (exports_17, context_17) {
    "use strict";
    var __moduleName = context_17 && context_17.id;
    var TransactionNotStartedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when transaction is not started yet and user tries to run commit or rollback.
             */
            TransactionNotStartedError = (function (_super) {
                __extends(TransactionNotStartedError, _super);
                function TransactionNotStartedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "TransactionNotStartedError";
                    _this.message = "Transaction is not started yet, start transaction before committing or rolling it back.";
                    return _this;
                }
                return TransactionNotStartedError;
            }(Error));
            exports_17("TransactionNotStartedError", TransactionNotStartedError);
        }
    };
});
System.register("typeorm/driver/error/DataTypeNotSupportedByDriverError", [], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    var DataTypeNotSupportedByDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if some data type is not supported by a driver.
             */
            DataTypeNotSupportedByDriverError = (function (_super) {
                __extends(DataTypeNotSupportedByDriverError, _super);
                function DataTypeNotSupportedByDriverError(dataType, driverName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DataTypeNotSupportedByDriverError";
                    _this.message = "Specified type (" + dataType + ") is not supported by " + driverName + " driver.";
                    return _this;
                }
                return DataTypeNotSupportedByDriverError;
            }(Error));
            exports_18("DataTypeNotSupportedByDriverError", DataTypeNotSupportedByDriverError);
        }
    };
});
System.register("typeorm/metadata-args/IndexMetadataArgs", [], function (exports_19, context_19) {
    "use strict";
    var __moduleName = context_19 && context_19.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/IndexMetadata", [], function (exports_20, context_20) {
    "use strict";
    var __moduleName = context_20 && context_20.id;
    var IndexMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Index metadata contains all information about table's index.
             */
            IndexMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function IndexMetadata(options) {
                    /**
                     * Indicates if this index must be unique.
                     */
                    this.isUnique = false;
                    /**
                     * Indexed columns.
                     */
                    this.columns = [];
                    /**
                     * Map of column names with order set.
                     * Used only by MongoDB driver.
                     */
                    this.columnNamesWithOrderingMap = {};
                    this.entityMetadata = options.entityMetadata;
                    if (options.columns)
                        this.columns = options.columns;
                    if (options.args) {
                        this.target = options.args.target;
                        this.isUnique = options.args.unique;
                        this.givenName = options.args.name;
                        this.givenColumnNames = options.args.columns;
                    }
                }
                // ---------------------------------------------------------------------
                // Public Build Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend index properties.
                 * Must be called after all entity metadata's properties map, columns and relations are built.
                 */
                IndexMetadata.prototype.build = function (namingStrategy) {
                    var _this = this;
                    var map = {};
                    this.tableName = this.entityMetadata.tableName;
                    // if columns already an array of string then simply return it
                    if (this.givenColumnNames) {
                        var columnPropertyNames_1 = [];
                        if (this.givenColumnNames instanceof Array) {
                            columnPropertyNames_1 = this.givenColumnNames;
                            columnPropertyNames_1.forEach(function (name) { return map[name] = 1; });
                        }
                        else {
                            // if columns is a function that returns array of field names then execute it and get columns names from it
                            var columnsFnResult_1 = this.givenColumnNames(this.entityMetadata.propertiesMap);
                            if (columnsFnResult_1 instanceof Array) {
                                columnPropertyNames_1 = columnsFnResult_1.map(function (i) { return String(i); });
                                columnPropertyNames_1.forEach(function (name) { return map[name] = 1; });
                            }
                            else {
                                columnPropertyNames_1 = Object.keys(columnsFnResult_1).map(function (i) { return String(i); });
                                Object.keys(columnsFnResult_1).forEach(function (columnName) { return map[columnName] = columnsFnResult_1[columnName]; });
                            }
                        }
                        // console.log("columnPropertyNames:", columnPropertyNames);
                        // console.log("this.entityMetadata.columns:", this.entityMetadata.columns);
                        var columns_1 = this.entityMetadata.columns.filter(function (column) { return columnPropertyNames_1.indexOf(column.propertyPath) !== -1; });
                        // console.log("columns:", columns);
                        this.entityMetadata.relations
                            .filter(function (relation) { return relation.isWithJoinColumn && columnPropertyNames_1.indexOf(relation.propertyName) !== -1; })
                            .forEach(function (relation) { return columns_1.push.apply(columns_1, relation.joinColumns); });
                        // todo: better to extract all validation into single place if possible
                        var missingColumnNames = columnPropertyNames_1.filter(function (columnPropertyName) {
                            return !_this.entityMetadata.columns.find(function (column) { return column.propertyPath === columnPropertyName; }) &&
                                !_this.entityMetadata.relations.find(function (relation) { return relation.isWithJoinColumn && relation.propertyPath === columnPropertyName; });
                        });
                        if (missingColumnNames.length > 0) {
                            throw new Error("Index " + (this.givenName ? "\"" + this.givenName + "\" " : "") + "contains columns that are missing in the entity: " + missingColumnNames.join(", "));
                        }
                        this.columns = columns_1;
                    }
                    this.columnNamesWithOrderingMap = Object.keys(map).reduce(function (updatedMap, key) {
                        var column = _this.entityMetadata.columns.find(function (column) { return column.propertyPath === key; });
                        if (column)
                            updatedMap[column.databaseName] = map[key];
                        return updatedMap;
                    }, {});
                    this.name = namingStrategy.indexName(this.givenName ? this.givenName : undefined, this.entityMetadata.tableName, this.columns.map(function (column) { return column.databaseName; }));
                    return this;
                };
                return IndexMetadata;
            }());
            exports_20("IndexMetadata", IndexMetadata);
        }
    };
});
System.register("typeorm/schema-builder/schema/IndexSchema", [], function (exports_21, context_21) {
    "use strict";
    var __moduleName = context_21 && context_21.id;
    var IndexSchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Database's table index stored in this class.
             */
            IndexSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function IndexSchema(tableName, name, columnNames, isUnique) {
                    this.tableName = tableName;
                    this.name = name;
                    this.columnNames = columnNames;
                    this.isUnique = isUnique;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this index with exactly same properties.
                 */
                IndexSchema.prototype.clone = function () {
                    return new IndexSchema(this.tableName, this.name, this.columnNames.map(function (name) { return name; }), this.isUnique);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates index from the index metadata object.
                 */
                IndexSchema.create = function (indexMetadata) {
                    return new IndexSchema(indexMetadata.entityMetadata.tableName, indexMetadata.name, indexMetadata.columns.map(function (column) { return column.databaseName; }), indexMetadata.isUnique);
                };
                return IndexSchema;
            }());
            exports_21("IndexSchema", IndexSchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/ForeignKeySchema", [], function (exports_22, context_22) {
    "use strict";
    var __moduleName = context_22 && context_22.id;
    var ForeignKeySchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Foreign key from the database stored in this class.
             */
            ForeignKeySchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ForeignKeySchema(name, columnNames, referencedColumnNames, referencedTable, onDelete) {
                    this.name = name;
                    this.columnNames = columnNames;
                    this.referencedColumnNames = referencedColumnNames;
                    this.referencedTableName = referencedTable;
                    this.onDelete = onDelete;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this foreign key with exactly same properties.
                 */
                ForeignKeySchema.prototype.clone = function () {
                    return new ForeignKeySchema(this.name, this.columnNames, this.referencedColumnNames, this.referencedTableName);
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new foreign schema from the given foreign key metadata.
                 */
                ForeignKeySchema.create = function (metadata) {
                    return new ForeignKeySchema(metadata.name, metadata.columnNames, metadata.referencedColumnNames, metadata.referencedTableName, metadata.onDelete);
                };
                return ForeignKeySchema;
            }());
            exports_22("ForeignKeySchema", ForeignKeySchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/PrimaryKeySchema", [], function (exports_23, context_23) {
    "use strict";
    var __moduleName = context_23 && context_23.id;
    var PrimaryKeySchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Primary key from the database stored in this class.
             */
            PrimaryKeySchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PrimaryKeySchema(name, columnName) {
                    this.name = name;
                    this.columnName = columnName;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new copy of this primary key with exactly same properties.
                 */
                PrimaryKeySchema.prototype.clone = function () {
                    return new PrimaryKeySchema(this.name, this.columnName);
                };
                return PrimaryKeySchema;
            }());
            exports_23("PrimaryKeySchema", PrimaryKeySchema);
        }
    };
});
System.register("typeorm/schema-builder/schema/TableSchema", ["typeorm/schema-builder/schema/ColumnSchema"], function (exports_24, context_24) {
    "use strict";
    var __moduleName = context_24 && context_24.id;
    var ColumnSchema_1, TableSchema;
    return {
        setters: [
            function (ColumnSchema_1_1) {
                ColumnSchema_1 = ColumnSchema_1_1;
            }
        ],
        execute: function () {
            /**
             * Table schema in the database represented in this class.
             */
            TableSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function TableSchema(name, columns, justCreated) {
                    /**
                     * Table columns.
                     */
                    this.columns = [];
                    /**
                     * Table indices.
                     */
                    this.indices = [];
                    /**
                     * Table foreign keys.
                     */
                    this.foreignKeys = [];
                    /**
                     * Table primary keys.
                     */
                    this.primaryKeys = [];
                    /**
                     * Indicates if table schema was just created.
                     * This is needed, for example to check if we need to skip primary keys creation
                     * for new table schemas.
                     */
                    this.justCreated = false;
                    this.name = name;
                    if (columns) {
                        this.columns = columns.map(function (column) {
                            if (column instanceof ColumnSchema_1.ColumnSchema) {
                                return column;
                            }
                            else {
                                return new ColumnSchema_1.ColumnSchema(column);
                            }
                        });
                    }
                    if (justCreated !== undefined)
                        this.justCreated = justCreated;
                }
                Object.defineProperty(TableSchema.prototype, "primaryKeysWithoutGenerated", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets only those primary keys that does not
                     */
                    get: function () {
                        var generatedColumn = this.columns.find(function (column) { return column.isGenerated; });
                        if (!generatedColumn)
                            return this.primaryKeys;
                        return this.primaryKeys.filter(function (primaryKey) {
                            return primaryKey.columnName !== generatedColumn.name;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TableSchema.prototype, "hasGeneratedColumn", {
                    get: function () {
                        return !!this.columns.find(function (column) { return column.isGenerated; });
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this table schema to a new table schema with all properties cloned.
                 */
                TableSchema.prototype.clone = function () {
                    var cloned = new TableSchema(this.name);
                    cloned.columns = this.columns.map(function (column) { return column.clone(); });
                    cloned.indices = this.indices.map(function (index) { return index.clone(); });
                    cloned.foreignKeys = this.foreignKeys.map(function (key) { return key.clone(); });
                    cloned.primaryKeys = this.primaryKeys.map(function (key) { return key.clone(); });
                    return cloned;
                };
                /**
                 * Adds column schemas.
                 */
                TableSchema.prototype.addColumns = function (columns) {
                    this.columns = this.columns.concat(columns);
                };
                /**
                 * Replaces given column.
                 */
                TableSchema.prototype.replaceColumn = function (oldColumn, newColumn) {
                    this.columns[this.columns.indexOf(oldColumn)] = newColumn;
                };
                /**
                 * Removes a column schema from this table schema.
                 */
                TableSchema.prototype.removeColumn = function (columnToRemove) {
                    var foundColumn = this.columns.find(function (column) { return column.name === columnToRemove.name; });
                    if (foundColumn)
                        this.columns.splice(this.columns.indexOf(foundColumn), 1);
                };
                /**
                 * Remove all column schemas from this table schema.
                 */
                TableSchema.prototype.removeColumns = function (columns) {
                    var _this = this;
                    columns.forEach(function (column) { return _this.removeColumn(column); });
                };
                /**
                 * Adds all given primary keys.
                 */
                TableSchema.prototype.addPrimaryKeys = function (addedKeys) {
                    var _this = this;
                    addedKeys.forEach(function (key) { return _this.primaryKeys.push(key); });
                };
                /**
                 * Removes all given primary keys.
                 */
                TableSchema.prototype.removePrimaryKeys = function (droppedKeys) {
                    var _this = this;
                    droppedKeys.forEach(function (key) {
                        _this.primaryKeys.splice(_this.primaryKeys.indexOf(key), 1);
                    });
                };
                /**
                 * Removes primary keys of the given columns.
                 */
                TableSchema.prototype.removePrimaryKeysOfColumns = function (columns) {
                    this.primaryKeys = this.primaryKeys.filter(function (primaryKey) {
                        return !columns.find(function (column) { return column.name === primaryKey.columnName; });
                    });
                };
                /**
                 * Adds foreign key schemas.
                 */
                TableSchema.prototype.addForeignKeys = function (foreignKeys) {
                    this.foreignKeys = this.foreignKeys.concat(foreignKeys);
                };
                /**
                 * Removes foreign key from this table schema.
                 */
                TableSchema.prototype.removeForeignKey = function (removedForeignKey) {
                    var fk = this.foreignKeys.find(function (foreignKey) { return foreignKey.name === removedForeignKey.name; }); // this must be by name
                    if (fk)
                        this.foreignKeys.splice(this.foreignKeys.indexOf(fk), 1);
                };
                /**
                 * Removes all foreign keys from this table schema.
                 */
                TableSchema.prototype.removeForeignKeys = function (dbForeignKeys) {
                    var _this = this;
                    dbForeignKeys.forEach(function (foreignKey) { return _this.removeForeignKey(foreignKey); });
                };
                /**
                 * Removes index schema from this table schema.
                 */
                TableSchema.prototype.removeIndex = function (indexSchema) {
                    var index = this.indices.find(function (index) { return index.name === indexSchema.name; });
                    if (index)
                        this.indices.splice(this.indices.indexOf(index), 1);
                };
                /**
                 * Differentiate columns of this table schema and columns from the given column metadatas columns
                 * and returns only changed.
                 */
                TableSchema.prototype.findChangedColumns = function (queryRunner, columnMetadatas) {
                    return this.columns.filter(function (columnSchema) {
                        var columnMetadata = columnMetadatas.find(function (columnMetadata) { return columnMetadata.databaseName === columnSchema.name; });
                        if (!columnMetadata)
                            return false; // we don't need new columns, we only need exist and changed
                        return columnSchema.name !== columnMetadata.databaseName ||
                            columnSchema.type !== queryRunner.normalizeType(columnMetadata) ||
                            columnSchema.comment !== columnMetadata.comment ||
                            (!columnSchema.isGenerated && !queryRunner.compareDefaultValues(columnMetadata.default, columnSchema.default)) ||
                            columnSchema.isNullable !== columnMetadata.isNullable ||
                            columnSchema.isUnique !== columnMetadata.isUnique ||
                            // columnSchema.isPrimary !== columnMetadata.isPrimary ||
                            columnSchema.isGenerated !== columnMetadata.isGenerated;
                    });
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates table schema from a given entity metadata.
                 *
                 * todo: need deeper implementation
                 */
                TableSchema.create = function (entityMetadata, queryRunner) {
                    var tableSchema = new TableSchema(entityMetadata.tableName);
                    entityMetadata.columns.forEach(function (column) {
                        tableSchema.columns.push(ColumnSchema_1.ColumnSchema.create(column, queryRunner.normalizeType(column)));
                    });
                    return tableSchema;
                };
                return TableSchema;
            }());
            exports_24("TableSchema", TableSchema);
        }
    };
});
System.register("typeorm/query-runner/error/QueryRunnerAlreadyReleasedError", [], function (exports_25, context_25) {
    "use strict";
    var __moduleName = context_25 && context_25.id;
    var QueryRunnerAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            QueryRunnerAlreadyReleasedError = (function (_super) {
                __extends(QueryRunnerAlreadyReleasedError, _super);
                function QueryRunnerAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerAlreadyReleasedError";
                    _this.message = "Query runner already released. Cannot run queries anymore.";
                    return _this;
                }
                return QueryRunnerAlreadyReleasedError;
            }(Error));
            exports_25("QueryRunnerAlreadyReleasedError", QueryRunnerAlreadyReleasedError);
        }
    };
});
System.register("typeorm/driver/oracle/OracleQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_26, context_26) {
    "use strict";
    var __moduleName = context_26 && context_26.id;
    var TransactionAlreadyStartedError_1, TransactionNotStartedError_1, DataTypeNotSupportedByDriverError_1, ColumnSchema_2, TableSchema_1, ForeignKeySchema_1, PrimaryKeySchema_1, QueryRunnerAlreadyReleasedError_1, OracleQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_1_1) {
                TransactionAlreadyStartedError_1 = TransactionAlreadyStartedError_1_1;
            },
            function (TransactionNotStartedError_1_1) {
                TransactionNotStartedError_1 = TransactionNotStartedError_1_1;
            },
            function (DataTypeNotSupportedByDriverError_1_1) {
                DataTypeNotSupportedByDriverError_1 = DataTypeNotSupportedByDriverError_1_1;
            },
            function (ColumnSchema_2_1) {
                ColumnSchema_2 = ColumnSchema_2_1;
            },
            function (TableSchema_1_1) {
                TableSchema_1 = TableSchema_1_1;
            },
            function (ForeignKeySchema_1_1) {
                ForeignKeySchema_1 = ForeignKeySchema_1_1;
            },
            function (PrimaryKeySchema_1_1) {
                PrimaryKeySchema_1 = PrimaryKeySchema_1_1;
            },
            function (QueryRunnerAlreadyReleasedError_1_1) {
                QueryRunnerAlreadyReleasedError_1 = QueryRunnerAlreadyReleasedError_1_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                OracleQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                OracleQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, 10, 12]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS ', table_name, ';') AS query FROM information_schema.tables WHERE table_schema = '" + this.dbName + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 8:
                                    error_1 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 9:
                                    _a.sent();
                                    throw error_1;
                                case 10: return [4 /*yield*/, this.release()];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                OracleQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_1.TransactionAlreadyStartedError();
                            // await this.query("START TRANSACTION");
                            this.databaseConnection.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                OracleQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_1.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                OracleQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_1.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                OracleQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                OracleQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var handler = function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result.rows || result.outBinds);
                        };
                        var executionOptions = {
                            autoCommit: _this.databaseConnection.isTransactionActive ? false : true
                        };
                        _this.databaseConnection.connection.execute(query, parameters || {}, executionOptions, handler);
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                OracleQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, insertSql, sql2, saveResult;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key) { return ":" + key; }).join(", ");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    insertSql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")"
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                                    if (!generatedColumn) return [3 /*break*/, 2];
                                    sql2 = "declare lastId number; begin " + insertSql + " returning \"id\" into lastId; dbms_output.enable; dbms_output.put_line(lastId); dbms_output.get_line(:ln, :st); end;";
                                    return [4 /*yield*/, this.query(sql2, parameters.concat([
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.STRING, maxSize: 32767 },
                                            { dir: this.driver.oracle.BIND_OUT, type: this.driver.oracle.NUMBER }
                                        ]))];
                                case 1:
                                    saveResult = _a.sent();
                                    return [2 /*return*/, parseInt(saveResult[0])];
                                case 2: return [2 /*return*/, this.query(insertSql, parameters)];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                OracleQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                OracleQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                OracleQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                OracleQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                OracleQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, uniqueKeysSql, constraintsSql, _a, dbTables, dbColumns, constraints;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE, IDENTITY_COLUMN FROM all_tab_cols WHERE TABLE_NAME IN (" + tableNamesString + ")";
                                    indicesSql = "SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND INDEX_NAME != 'PRIMARY'";
                                    foreignKeysSql = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = '" + this.dbName + "' AND REFERENCED_COLUMN_NAME IS NOT NULL";
                                    uniqueKeysSql = "SELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND CONSTRAINT_TYPE = 'UNIQUE'";
                                    constraintsSql = "SELECT cols.table_name, cols.column_name, cols.position, cons.constraint_type, cons.constraint_name\nFROM all_constraints cons, all_cons_columns cols WHERE cols.table_name IN (" + tableNamesString + ") \nAND cons.constraint_name = cols.constraint_name AND cons.owner = cols.owner ORDER BY cols.table_name, cols.position";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            // this.query(indicesSql),
                                            // this.query(foreignKeysSql),
                                            // this.query(uniqueKeysSql),
                                            this.query(constraintsSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], constraints = _a[2];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var tableSchema = new TableSchema_1.TableSchema(dbTable["TABLE_NAME"]);
                                            // create column schemas from the loaded columns
                                            tableSchema.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                .map(function (dbColumn) {
                                                var isPrimary = !!constraints
                                                    .find(function (constraint) {
                                                    return constraint["TABLE_NAME"] === tableSchema.name &&
                                                        constraint["CONSTRAINT_TYPE"] === "P" &&
                                                        constraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                });
                                                var columnType = dbColumn["DATA_TYPE"].toLowerCase();
                                                if (dbColumn["DATA_TYPE"].toLowerCase() === "varchar2" && dbColumn["DATA_LENGTH"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_LENGTH"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null && dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + "," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_SCALE"] !== null) {
                                                    columnType += "(0," + dbColumn["DATA_SCALE"] + ")";
                                                }
                                                else if (dbColumn["DATA_PRECISION"] !== null) {
                                                    columnType += "(" + dbColumn["DATA_PRECISION"] + ")";
                                                }
                                                var columnSchema = new ColumnSchema_2.ColumnSchema();
                                                columnSchema.name = dbColumn["COLUMN_NAME"];
                                                columnSchema.type = columnType;
                                                columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                columnSchema.isNullable = dbColumn["NULLABLE"] !== "N";
                                                columnSchema.isPrimary = isPrimary;
                                                columnSchema.isGenerated = dbColumn["IDENTITY_COLUMN"] === "YES"; // todo
                                                columnSchema.comment = ""; // todo
                                                return columnSchema;
                                            });
                                            // create primary key schema
                                            tableSchema.primaryKeys = constraints
                                                .filter(function (constraint) { return constraint["TABLE_NAME"] === tableSchema.name && constraint["CONSTRAINT_TYPE"] === "P"; })
                                                .map(function (constraint) { return new PrimaryKeySchema_1.PrimaryKeySchema(constraint["CONSTRAINT_NAME"], constraint["COLUMN_NAME"]); });
                                            // create foreign key schemas from the loaded indices
                                            tableSchema.foreignKeys = constraints
                                                .filter(function (constraint) { return constraint["TABLE_NAME"] === tableSchema.name && constraint["CONSTRAINT_TYPE"] === "R"; })
                                                .map(function (constraint) { return new ForeignKeySchema_1.ForeignKeySchema(constraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                            // console.log(tableSchema);
                                            // create index schemas from the loaded indices
                                            // tableSchema.indices = dbIndices
                                            //     .filter(dbIndex => {
                                            //         return  dbIndex["table_name"] === tableSchema.name &&
                                            //             (!tableSchema.foreignKeys.find(foreignKey => foreignKey.name === dbIndex["INDEX_NAME"])) &&
                                            //             (!tableSchema.primaryKeys.find(primaryKey => primaryKey.name === dbIndex["INDEX_NAME"]));
                                            //     })
                                            //     .map(dbIndex => dbIndex["INDEX_NAME"])
                                            //     .filter((value, index, self) => self.indexOf(value) === index) // unqiue
                                            //     .map(dbIndexName => {
                                            //         const columnNames = dbIndices
                                            //             .filter(dbIndex => dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName)
                                            //             .map(dbIndex => dbIndex["COLUMN_NAME"]);
                                            //
                                            //         return new IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                            //     });
                                            return tableSchema;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                OracleQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT TABLE_NAME FROM user_tables WHERE TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                OracleQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                OracleQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT COLUMN_NAME FROM all_tab_cols WHERE TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                OracleQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                OracleQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                OracleQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_1.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, dropPrimarySql, dropSql, createSql, sql, sql, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_1.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_2.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 10];
                                    if (!newColumn.isGenerated) return [3 /*break*/, 8];
                                    if (!(tableSchema.primaryKeys.length > 0 && oldColumn.isPrimary)) return [3 /*break*/, 5];
                                    dropPrimarySql = "ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"" + tableSchema.primaryKeys[0].name + "\"";
                                    return [4 /*yield*/, this.query(dropPrimarySql)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    dropSql = "ALTER TABLE \"" + tableSchema.name + "\" DROP COLUMN \"" + newColumn.name + "\"";
                                    return [4 /*yield*/, this.query(dropSql)];
                                case 6:
                                    _a.sent();
                                    createSql = "ALTER TABLE \"" + tableSchema.name + "\" ADD " + this.buildCreateColumnSql(newColumn);
                                    return [4 /*yield*/, this.query(createSql)];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 8:
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" DROP IDENTITY";
                                    return [4 /*yield*/, this.query(sql)];
                                case 9:
                                    _a.sent();
                                    _a.label = 10;
                                case 10:
                                    if (!(newColumn.isNullable !== oldColumn.isNullable)) return [3 /*break*/, 12];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" " + newColumn.type + " " + (newColumn.isNullable ? "NULL" : "NOT NULL");
                                    return [4 /*yield*/, this.query(sql)];
                                case 11:
                                    _a.sent();
                                    return [3 /*break*/, 14];
                                case 12:
                                    if (!(newColumn.type !== oldColumn.type)) return [3 /*break*/, 14];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" MODIFY \"" + newColumn.name + "\" " + newColumn.type;
                                    return [4 /*yield*/, this.query(sql)];
                                case 13:
                                    _a.sent();
                                    _a.label = 14;
                                case 14: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                OracleQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                OracleQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_2.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP COLUMN \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                OracleQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                OracleQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(dbTable.primaryKeys.length > 0 && dbTable.primaryKeys[0].name)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT \"" + dbTable.primaryKeys[0].name + "\"")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                OracleQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                OracleQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_1.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                OracleQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                OracleQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE" : "") + " INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                OracleQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_1.QueryRunnerAlreadyReleasedError();
                                    sql = "ALTER TABLE \"" + tableName + "\" DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                OracleQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            if (typeOptions.fixedLength) {
                                return "char(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                            else {
                                return "varchar2(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                        case "text":
                            return "clob";
                        case "boolean":
                            return "number(1)";
                        case "integer":
                        case "int":
                            // if (column.isGenerated)
                            //     return `number(22)`;
                            if (typeOptions.precision && typeOptions.scale)
                                return "number(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            if (typeOptions.precision)
                                return "number(" + typeOptions.precision + ",0)";
                            if (typeOptions.scale)
                                return "number(0," + typeOptions.scale + ")";
                            return "number(10,0)";
                        case "smallint":
                            return "number(5)";
                        case "bigint":
                            return "number(20)";
                        case "float":
                            if (typeOptions.precision && typeOptions.scale)
                                return "float(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            if (typeOptions.precision)
                                return "float(" + typeOptions.precision + ",0)";
                            if (typeOptions.scale)
                                return "float(0," + typeOptions.scale + ")";
                            return "float(126)";
                        case "double":
                        case "number":
                            return "float(126)";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(0," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            return "date";
                        case "datetime":
                            return "timestamp(0)";
                        case "json":
                            return "clob";
                        case "simple_array":
                            return typeOptions.length ? "varchar2(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_1.DataTypeNotSupportedByDriverError(typeOptions.type, "Oracle");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                OracleQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                OracleQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(OracleQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                OracleQueryRunner.prototype.parametrize = function (objectLiteral) {
                    var _this = this;
                    return Object.keys(objectLiteral).map(function (key) { return _this.driver.escapeColumnName(key) + "=:" + key; });
                };
                /**
                 * Builds a query for create column.
                 */
                OracleQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\" " + column.type;
                    if (column.isNullable !== true && !column.isGenerated)
                        c += " NOT NULL";
                    // if (column.isPrimary === true && addPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.isGenerated === true)
                        c += " GENERATED BY DEFAULT ON NULL AS IDENTITY";
                    // if (column.comment) // todo: less priority, fix it later
                    //     c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return OracleQueryRunner;
            }());
            exports_26("OracleQueryRunner", OracleQueryRunner);
        }
    };
});
System.register("typeorm/driver/error/DriverOptionNotSetError", [], function (exports_27, context_27) {
    "use strict";
    var __moduleName = context_27 && context_27.id;
    var DriverOptionNotSetError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if some required driver's option is not set.
             */
            DriverOptionNotSetError = (function (_super) {
                __extends(DriverOptionNotSetError, _super);
                function DriverOptionNotSetError(optionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverOptionNotSetError";
                    _this.message = "Driver option (" + optionName + ") is not set. Please set it to perform connection to the database.";
                    return _this;
                }
                return DriverOptionNotSetError;
            }(Error));
            exports_27("DriverOptionNotSetError", DriverOptionNotSetError);
        }
    };
});
System.register("typeorm/util/DataTransformationUtils", [], function (exports_28, context_28) {
    "use strict";
    var __moduleName = context_28 && context_28.id;
    var DataTransformationUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides utilities to transform hydrated and persisted data.
             */
            DataTransformationUtils = (function () {
                function DataTransformationUtils() {
                }
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Normalizes date object hydrated from the database.
                 */
                DataTransformationUtils.normalizeHydratedDate = function (mixedDate, storedInLocal) {
                    if (!mixedDate)
                        return mixedDate;
                    var date = typeof mixedDate === "string" ? new Date(mixedDate) : mixedDate;
                    if (!storedInLocal) {
                        // else if it was not stored in local timezone, means it was stored in UTC
                        // because driver hydrates it with timezone applied why we need to add timezone hours to match a local timezone
                        var correctedDate = new Date();
                        correctedDate.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                        correctedDate.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                        return correctedDate;
                    }
                    return date;
                };
                /**
                 * Converts given value into date string in a "YYYY-MM-DD" format.
                 */
                DataTransformationUtils.mixedDateToDateString = function (value) {
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getFullYear()) + "-" + this.formatZerolessValue(value.getMonth() + 1) + "-" + this.formatZerolessValue(value.getDate());
                    return value;
                };
                /**
                 * Converts given value into time string in a "HH:mm:ss" format.
                 */
                DataTransformationUtils.mixedDateToTimeString = function (value) {
                    if (value instanceof Date)
                        return this.formatZerolessValue(value.getHours()) + ":" + this.formatZerolessValue(value.getMinutes()) + ":" + this.formatZerolessValue(value.getSeconds());
                    return value;
                };
                /**
                 * Converts given string value with "-" separator into a "HH:mm:ss" format.
                 */
                DataTransformationUtils.mixedTimeToString = function (value) {
                    value = value instanceof Date ? (value.getHours() + ":" + value.getMinutes() + ":" + value.getSeconds()) : value;
                    if (typeof value === "string") {
                        return value.split(":")
                            .map(function (v) { return v.length === 1 ? "0" + v : v; }) // append zero at beginning if we have a first-zero-less number
                            .join(":");
                    }
                    return value;
                };
                /**
                 * Converts given value into datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DataTransformationUtils.mixedDateToDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getFullYear()) + "-" +
                            this.formatZerolessValue(value.getMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getDate()) + " " +
                            this.formatZerolessValue(value.getHours()) + ":" +
                            this.formatZerolessValue(value.getMinutes()) + ":" +
                            this.formatZerolessValue(value.getSeconds());
                    }
                    return value;
                };
                /**
                 * Converts given value into utc datetime string in a "YYYY-MM-DD HH-mm-ss" format.
                 */
                DataTransformationUtils.mixedDateToUtcDatetimeString = function (value) {
                    if (typeof value === "string") {
                        value = new Date(value);
                    }
                    if (value instanceof Date) {
                        return this.formatZerolessValue(value.getUTCFullYear()) + "-" +
                            this.formatZerolessValue(value.getUTCMonth() + 1) + "-" +
                            this.formatZerolessValue(value.getUTCDate()) + " " +
                            this.formatZerolessValue(value.getUTCHours()) + ":" +
                            this.formatZerolessValue(value.getUTCMinutes()) + ":" +
                            this.formatZerolessValue(value.getUTCSeconds());
                    }
                    return value;
                };
                /**
                 * Converts each item in the given array to string joined by "," separator.
                 */
                DataTransformationUtils.simpleArrayToString = function (value) {
                    if (value instanceof Array) {
                        return value
                            .map(function (i) { return String(i); })
                            .join(",");
                    }
                    return value;
                };
                /**
                 * Converts given string to simple array split by "," separator.
                 */
                DataTransformationUtils.stringToSimpleArray = function (value) {
                    if (value instanceof String || typeof value === "string") {
                        return value.split(",");
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Private Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Formats given number to "0x" format, e.g. if it is 1 then it will return "01".
                 */
                DataTransformationUtils.formatZerolessValue = function (value) {
                    if (value < 10)
                        return "0" + value;
                    return String(value);
                };
                return DataTransformationUtils;
            }());
            exports_28("DataTransformationUtils", DataTransformationUtils);
        }
    };
});
System.register("typeorm/lazy-loading/LazyRelationsWrapper", ["typeorm/query-builder/QueryBuilder"], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    var QueryBuilder_1, LazyRelationsWrapper;
    return {
        setters: [
            function (QueryBuilder_1_1) {
                QueryBuilder_1 = QueryBuilder_1_1;
            }
        ],
        execute: function () {
            /**
             * Wraps entities and creates getters/setters for their relations
             * to be able to lazily load relations when accessing these relations.
             */
            LazyRelationsWrapper = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function LazyRelationsWrapper(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Wraps given entity and creates getters/setters for its given relation
                 * to be able to lazily load data when accessing these relation.
                 */
                LazyRelationsWrapper.prototype.wrap = function (object, relation) {
                    var that = this;
                    var dataIndex = "__" + relation.propertyName + "__"; // in what property of the entity loaded data will be stored
                    var promiseIndex = "__promise_" + relation.propertyName + "__"; // in what property of the entity loading promise will be stored
                    var resolveIndex = "__has_" + relation.propertyName + "__"; // indicates if relation data already was loaded or not
                    Object.defineProperty(object, relation.propertyName, {
                        get: function () {
                            var _this = this;
                            if (this[resolveIndex] === true)
                                return Promise.resolve(this[dataIndex]);
                            if (this[promiseIndex])
                                return this[promiseIndex];
                            // nothing is loaded yet, load relation data and save it in the model once they are loaded
                            this[promiseIndex] = that.loadRelationResults(relation, this).then(function (result) {
                                _this[dataIndex] = result;
                                _this[resolveIndex] = true;
                                delete _this[promiseIndex];
                                return _this[dataIndex];
                            }); // .catch((err: any) => { throw err; });
                            return this[promiseIndex];
                        },
                        set: function (promise) {
                            var _this = this;
                            if (promise instanceof Promise) {
                                promise.then(function (result) {
                                    _this[dataIndex] = result;
                                    _this[resolveIndex] = true;
                                });
                            }
                            else {
                                this[dataIndex] = promise;
                                this[resolveIndex] = true;
                            }
                        },
                        configurable: true
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Loads relation data for the given entity and its relation.
                 */
                LazyRelationsWrapper.prototype.loadRelationResults = function (relation, entity) {
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        return this.loadManyToOneOrOneToOneOwner(relation, entity);
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        return this.loadOneToManyOrOneToOneNotOwner(relation, entity);
                    }
                    else if (relation.isManyToManyOwner) {
                        return this.loadManyToManyOwner(relation, entity);
                    }
                    else {
                        return this.loadManyToManyNotOwner(relation, entity);
                    }
                };
                /**
                 * Loads data for many-to-one and one-to-one owner relations.
                 *
                 * (ow) post.category<=>category.post
                 * loaded: category from post
                 * example: SELECT category.id AS category_id, category.name AS category_name FROM category category
                 *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1
                 */
                LazyRelationsWrapper.prototype.loadManyToOneOrOneToOneOwner = function (relation, entity) {
                    var joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
                    var conditions = joinColumns.map(function (joinColumn) {
                        return relation.entityMetadata.name + "." + relation.propertyName + " = " + relation.propertyName + "." + joinColumn.referencedColumn.propertyName;
                    }).join(" AND ");
                    var qb = new QueryBuilder_1.QueryBuilder(this.connection)
                        .select(relation.propertyName) // category
                        .from(relation.type, relation.propertyName) // Category, category
                        .innerJoin(relation.entityMetadata.target, relation.entityMetadata.name, conditions);
                    joinColumns.forEach(function (joinColumn) {
                        qb.andWhere(relation.entityMetadata.name + "." + joinColumn.referencedColumn.databaseName + " = :" + joinColumn.referencedColumn.databaseName)
                            .setParameter("" + joinColumn.referencedColumn.databaseName, joinColumn.referencedColumn.getEntityValue(entity));
                    });
                    return qb.getOne();
                };
                /**
                 * Loads data for one-to-many and one-to-one not owner relations.
                 *
                 * SELECT post
                 * FROM post post
                 * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]
                 */
                LazyRelationsWrapper.prototype.loadOneToManyOrOneToOneNotOwner = function (relation, entity) {
                    var qb = new QueryBuilder_1.QueryBuilder(this.connection)
                        .select(relation.propertyName)
                        .from(relation.inverseRelation.entityMetadata.target, relation.propertyName);
                    relation.inverseRelation.joinColumns.forEach(function (joinColumn) {
                        qb.andWhere(relation.propertyName + "." + joinColumn.propertyName + " = :" + joinColumn.referencedColumn.propertyName)
                            .setParameter("" + joinColumn.referencedColumn.propertyName, joinColumn.referencedColumn.getEntityValue(entity));
                    });
                    return relation.isOneToMany ? qb.getMany() : qb.getOne();
                };
                /**
                 * Loads data for many-to-many owner relations.
                 *
                 * SELECT category
                 * FROM category category
                 * INNER JOIN post_categories post_categories
                 * ON post_categories.postId = :postId
                 * AND post_categories.categoryId = category.id
                 */
                LazyRelationsWrapper.prototype.loadManyToManyOwner = function (relation, entity) {
                    var mainAlias = relation.propertyName;
                    var joinAlias = relation.junctionEntityMetadata.tableName;
                    var joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                        return joinAlias + "." + joinColumn.propertyName + " = :" + joinColumn.propertyName;
                    });
                    var inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                        return joinAlias + "." + inverseJoinColumn.propertyName + "=" + mainAlias + "." + inverseJoinColumn.referencedColumn.propertyName;
                    });
                    var parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(entity);
                        return parameters;
                    }, {});
                    return new QueryBuilder_1.QueryBuilder(this.connection)
                        .select(mainAlias)
                        .from(relation.type, mainAlias)
                        .innerJoin(joinAlias, joinAlias, joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND "))
                        .setParameters(parameters)
                        .getMany();
                };
                /**
                 * Loads data for many-to-many not owner relations.
                 *
                 * SELECT post
                 * FROM post post
                 * INNER JOIN post_categories post_categories
                 * ON post_categories.postId = post.id
                 * AND post_categories.categoryId = post_categories.categoryId
                 */
                LazyRelationsWrapper.prototype.loadManyToManyNotOwner = function (relation, entity) {
                    var mainAlias = relation.propertyName;
                    var joinAlias = relation.junctionEntityMetadata.tableName;
                    var joinColumnConditions = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                        return joinAlias + "." + joinColumn.propertyName + " = " + mainAlias + "." + joinColumn.referencedColumn.propertyName;
                    });
                    var inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(function (inverseJoinColumn) {
                        return joinAlias + "." + inverseJoinColumn.propertyName + " = :" + inverseJoinColumn.propertyName;
                    });
                    var parameters = relation.inverseRelation.inverseJoinColumns.reduce(function (parameters, joinColumn) {
                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(entity);
                        return parameters;
                    }, {});
                    return new QueryBuilder_1.QueryBuilder(this.connection)
                        .select(mainAlias)
                        .from(relation.type, mainAlias)
                        .innerJoin(joinAlias, joinAlias, joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND "))
                        .setParameters(parameters)
                        .getMany();
                };
                return LazyRelationsWrapper;
            }());
            exports_29("LazyRelationsWrapper", LazyRelationsWrapper);
        }
    };
});
System.register("typeorm/driver/oracle/OracleDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/oracle/OracleQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_30, context_30) {
    "use strict";
    var __moduleName = context_30 && context_30.id;
    var ConnectionIsNotSetError_1, DriverPackageNotInstalledError_1, DriverUtils_1, OracleQueryRunner_1, ColumnTypes_1, DriverOptionNotSetError_1, DataTransformationUtils_1, PlatformTools_2, OracleDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_1_1) {
                ConnectionIsNotSetError_1 = ConnectionIsNotSetError_1_1;
            },
            function (DriverPackageNotInstalledError_1_1) {
                DriverPackageNotInstalledError_1 = DriverPackageNotInstalledError_1_1;
            },
            function (DriverUtils_1_1) {
                DriverUtils_1 = DriverUtils_1_1;
            },
            function (OracleQueryRunner_1_1) {
                OracleQueryRunner_1 = OracleQueryRunner_1_1;
            },
            function (ColumnTypes_1_1) {
                ColumnTypes_1 = ColumnTypes_1_1;
            },
            function (DriverOptionNotSetError_1_1) {
                DriverOptionNotSetError_1 = DriverOptionNotSetError_1_1;
            },
            function (DataTransformationUtils_1_1) {
                DataTransformationUtils_1 = DataTransformationUtils_1_1;
            },
            function (PlatformTools_2_1) {
                PlatformTools_2 = PlatformTools_2_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with Oracle DBMS.
             *
             * todo: this driver is not 100% finished yet, need to fix all issues that are left
             */
            OracleDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function OracleDriver(options, logger, oracle) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_1.DriverUtils.buildDriverOptions(options, { useSid: true });
                    this.logger = logger;
                    this.oracle = oracle;
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("username");
                    if (!this.options.sid)
                        throw new DriverOptionNotSetError_1.DriverOptionNotSetError("sid");
                    // if oracle package instance was not set explicitly then try to load it
                    if (!oracle)
                        this.loadDependencies();
                    this.oracle.outFormat = this.oracle.OBJECT;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                OracleDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        user: this.options.username,
                        password: this.options.password,
                        connectString: this.options.host + ":" + this.options.port + "/" + this.options.sid,
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        return new Promise(function (ok, fail) {
                            _this.oracle.createPool(options, function (err, pool) {
                                if (err)
                                    return fail(err);
                                _this.pool = pool;
                                ok();
                            });
                        });
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            _this.oracle.getConnection(options, function (err, connection) {
                                if (err)
                                    return fail(err);
                                _this.databaseConnection = {
                                    id: 1,
                                    connection: connection,
                                    isTransactionActive: false
                                };
                                _this.databaseConnection.connection.connect(function (err) { return err ? fail(err) : ok(); });
                            });
                        });
                    }
                };
                /**
                 * Closes connection with the database.
                 */
                OracleDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("oracle");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        // if pooling is used, then disconnect from it
                        if (_this.pool) {
                            _this.pool.close(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        // if single connection is opened, then close it
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.close(handler);
                            _this.databaseConnection = undefined;
                        }
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                OracleDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_1.ConnectionIsNotSetError("oracle"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new OracleQueryRunner_1.OracleQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                OracleDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.oracle,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                OracleDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return key;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                OracleDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\""; // "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                OracleDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                OracleDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                OracleDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_1.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_1.ColumnTypes.DATE:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_1.ColumnTypes.TIME:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_1.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_1.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_1.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_1.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_1.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_1.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                OracleDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_1.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_1.ColumnTypes.DATETIME:
                            return DataTransformationUtils_1.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_1.ColumnTypes.DATE:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_1.ColumnTypes.TIME:
                            return DataTransformationUtils_1.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_1.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_1.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_1.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                OracleDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.getConnection(function (err, connection) {
                                if (err)
                                    return fail(err);
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    dbConnection.releaseCallback = function () {
                                        return new Promise(function (ok, fail) {
                                            connection.close(function (err) {
                                                if (err)
                                                    return fail(err);
                                                if (_this.pool && dbConnection) {
                                                    _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                                }
                                                ok();
                                            });
                                        });
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                ok(dbConnection);
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_1.ConnectionIsNotSetError("oracle");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                OracleDriver.prototype.loadDependencies = function () {
                    try {
                        this.oracle = PlatformTools_2.PlatformTools.load("oracledb");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_1.DriverPackageNotInstalledError("Oracle", "oracledb");
                    }
                };
                return OracleDriver;
            }());
            exports_30("OracleDriver", OracleDriver);
        }
    };
});
System.register("typeorm/query-builder/QueryBuilderUtils", [], function (exports_31, context_31) {
    "use strict";
    var __moduleName = context_31 && context_31.id;
    var QueryBuilderUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Helper utility functions for QueryBuilder.
             */
            QueryBuilderUtils = (function () {
                function QueryBuilderUtils() {
                }
                /**
                 * Checks if given value is a string representation of alias property,
                 * e.g. "post.category" or "post.id".
                 */
                QueryBuilderUtils.isAliasProperty = function (str) {
                    // alias property must be a string and must have a dot separator
                    if (typeof str !== "string" || str.indexOf(".") === -1)
                        return false;
                    // extra alias and its property relation
                    var _a = str.split("."), aliasName = _a[0], propertyName = _a[1]; // todo: what about relations in embedded?
                    if (!aliasName || !propertyName)
                        return false;
                    // alias and property must be represented in a special format
                    var aliasNameRegexp = /^[a-zA-Z0-9_-]+$/;
                    if (!aliasNameRegexp.test(aliasName) || !aliasNameRegexp.test(propertyName))
                        return false;
                    return true;
                };
                return QueryBuilderUtils;
            }());
            exports_31("QueryBuilderUtils", QueryBuilderUtils);
        }
    };
});
System.register("typeorm/query-builder/Alias", [], function (exports_32, context_32) {
    "use strict";
    var __moduleName = context_32 && context_32.id;
    var Alias;
    return {
        setters: [],
        execute: function () {
            /**
             */
            Alias = (function () {
                function Alias(alias) {
                    Object.assign(this, alias || {});
                }
                Object.defineProperty(Alias.prototype, "target", {
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Alias.prototype, "hasMetadata", {
                    get: function () {
                        return !!this._metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Alias.prototype, "metadata", {
                    get: function () {
                        if (!this._metadata)
                            throw new Error("Cannot get entity metadata for the given alias \"" + this.name + "\"");
                        return this._metadata;
                    },
                    set: function (metadata) {
                        this._metadata = metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Alias;
            }());
            exports_32("Alias", Alias);
        }
    };
});
System.register("typeorm/find-options/OrderByCondition", [], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/JoinOptions", [], function (exports_34, context_34) {
    "use strict";
    var __moduleName = context_34 && context_34.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/JoinAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    var QueryBuilderUtils_1, JoinAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_1_1) {
                QueryBuilderUtils_1 = QueryBuilderUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Stores all join attributes which will be used to build a JOIN query.
             */
            JoinAttribute = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function JoinAttribute(connection, queryExpressionMap, joinAttribute) {
                    this.connection = connection;
                    this.queryExpressionMap = queryExpressionMap;
                    this.joinAttribute = joinAttribute;
                    Object.assign(this, joinAttribute || {});
                }
                Object.defineProperty(JoinAttribute.prototype, "isMany", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        if (this.isMappingMany !== undefined)
                            return this.isMappingMany;
                        if (this.relation)
                            return this.relation.isManyToMany || this.relation.isOneToMany;
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "tableName", {
                    /**
                     * Name of the table which we should join.
                     */
                    get: function () {
                        return this.metadata ? this.metadata.tableName : this.entityOrProperty;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "relationPropertyPath", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     * Relation can be undefined if entityOrProperty is regular entity or custom table.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_1.QueryBuilderUtils.isAliasProperty(this.entityOrProperty))
                            return undefined;
                        var relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
                        var metadata = relationOwnerSelection.metadata.parentEntityMetadata
                            ? relationOwnerSelection.metadata.parentEntityMetadata
                            : relationOwnerSelection.metadata;
                        var relation = metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                        if (!relation)
                            throw new Error("Relation with property path " + this.relationPropertyPath + " in entity was not found.");
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "metadata", {
                    /**
                     * Metadata of the joined entity.
                     * If table without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        var _this = this;
                        // entityOrProperty is Entity class
                        if (this.entityOrProperty instanceof Function)
                            return this.connection.getMetadata(this.entityOrProperty);
                        // entityOrProperty is relation, e.g. "post.category"
                        if (this.relation)
                            return this.relation.inverseEntityMetadata;
                        if (typeof this.entityOrProperty === "string") {
                            // first try to find entity with such name, this is needed when entity does not have a target class,
                            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)
                            var metadata = this.connection.entityMetadatas.find(function (metadata) { return metadata.name === _this.entityOrProperty; });
                            if (metadata)
                                return metadata;
                            // check if we have entity with such table name, and use its metadata if found
                            return this.connection.entityMetadatas.find(function (metadata) { return metadata.tableName === _this.entityOrProperty; });
                        }
                        return undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "junctionAlias", {
                    /**
                     * Generates alias of junction table, whose ids we get.
                     */
                    get: function () {
                        if (!this.relation)
                            throw new Error("Cannot get junction table for join without relation.");
                        return this.relation.isOwning ? this.parentAlias + "_" + this.alias.name : this.alias.name + "_" + this.parentAlias;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "mapToPropertyParentAlias", {
                    get: function () {
                        if (!this.mapToProperty)
                            return undefined;
                        return this.mapToProperty.split(".")[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(JoinAttribute.prototype, "mapToPropertyPropertyName", {
                    get: function () {
                        if (!this.mapToProperty)
                            return undefined;
                        return this.mapToProperty.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                return JoinAttribute;
            }());
            exports_35("JoinAttribute", JoinAttribute);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    var QueryBuilderUtils_2, RelationCountAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_2_1) {
                QueryBuilderUtils_2 = QueryBuilderUtils_2_1;
            }
        ],
        execute: function () {
            RelationCountAttribute = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountAttribute(expressionMap, relationCountAttribute) {
                    this.expressionMap = expressionMap;
                    this.relationCountAttribute = relationCountAttribute;
                    Object.assign(this, relationCountAttribute || {});
                }
                Object.defineProperty(RelationCountAttribute.prototype, "joinInverseSideMetadata", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.relation.inverseEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.split(".")[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "relationProperty", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        return this.relationName.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "junctionAlias", {
                    get: function () {
                        var _a = this.relationName.split("."), parentAlias = _a[0], relationProperty = _a[1];
                        return parentAlias + "_" + relationProperty + "_relation_count";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        var _a = this.relationName.split("."), parentAlias = _a[0], propertyPath = _a[1];
                        var relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);
                        var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);
                        if (!relation)
                            throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "metadata", {
                    /**
                     * Metadata of the joined entity.
                     * If table without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_2.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value is a string representation of alias property");
                        var parentAlias = this.relationName.split(".")[0];
                        var selection = this.expressionMap.findAliasByName(parentAlias);
                        return selection.metadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationCountAttribute.prototype, "mapToPropertyPropertyName", {
                    get: function () {
                        return this.mapToProperty.split(".")[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                return RelationCountAttribute;
            }());
            exports_36("RelationCountAttribute", RelationCountAttribute);
        }
    };
});
System.register("typeorm/query-builder/SelectQuery", [], function (exports_37, context_37) {
    "use strict";
    var __moduleName = context_37 && context_37.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/QueryExpressionMap", ["typeorm/query-builder/Alias", "typeorm/query-builder/JoinAttribute", "typeorm/query-builder/relation-id/RelationIdAttribute", "typeorm/query-builder/relation-count/RelationCountAttribute"], function (exports_38, context_38) {
    "use strict";
    var __moduleName = context_38 && context_38.id;
    var Alias_1, JoinAttribute_1, RelationIdAttribute_1, RelationCountAttribute_1, QueryExpressionMap;
    return {
        setters: [
            function (Alias_1_1) {
                Alias_1 = Alias_1_1;
            },
            function (JoinAttribute_1_1) {
                JoinAttribute_1 = JoinAttribute_1_1;
            },
            function (RelationIdAttribute_1_1) {
                RelationIdAttribute_1 = RelationIdAttribute_1_1;
            },
            function (RelationCountAttribute_1_1) {
                RelationCountAttribute_1 = RelationCountAttribute_1_1;
            }
        ],
        execute: function () {
            /**
             * Contains all properties of the QueryBuilder that needs to be build a final query.
             */
            QueryExpressionMap = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryExpressionMap(connection) {
                    this.connection = connection;
                    /**
                     * All aliases (including main alias) used in the query.
                     */
                    this.aliases = [];
                    /**
                     * Represents query type. QueryBuilder is able to build SELECT, UPDATE and DELETE queries.
                     */
                    this.queryType = "select";
                    /**
                     * Data needs to be SELECT-ed.
                     */
                    this.selects = [];
                    /**
                     * JOIN queries.
                     */
                    this.joinAttributes = [];
                    /**
                     * RelationId queries.
                     */
                    this.relationIdAttributes = [];
                    /**
                     * Relation count queries.
                     */
                    this.relationCountAttributes = [];
                    /**
                     * WHERE queries.
                     */
                    this.wheres = [];
                    /**
                     * HAVING queries.
                     */
                    this.havings = [];
                    /**
                     * ORDER BY queries.
                     */
                    this.orderBys = {};
                    /**
                     * GROUP BY queries.
                     */
                    this.groupBys = [];
                    /**
                     * Parameters used to be escaped in final query.
                     */
                    this.parameters = {};
                    /**
                     * Indicates if alias, table names and column names will be ecaped by driver, or not.
                     *
                     * todo: rename to isQuotingDisabled, also think if it should be named "escaping"
                     */
                    this.disableEscaping = true;
                    /**
                     * todo: needs more information.
                     */
                    this.ignoreParentTablesJoins = false;
                    /**
                     * Indicates if virtual columns should be included in entity result.
                     *
                     * todo: what to do with it? is it properly used? what about persistence?
                     */
                    this.enableRelationIdValues = false;
                    /**
                     * Extra where condition appended to the end of original where conditions with AND keyword.
                     * Original condition will be wrapped into brackets.
                     */
                    this.extraAppendedAndWhereCondition = "";
                }
                /**
                 * Creates a main alias and adds it to the current expression map.
                 */
                QueryExpressionMap.prototype.createMainAlias = function (options) {
                    var alias = this.createAlias(options);
                    // if main alias is already set then remove it from the array
                    if (this.mainAlias)
                        this.aliases.splice(this.aliases.indexOf(this.mainAlias));
                    // set new main alias
                    this.mainAlias = alias;
                    return alias;
                };
                /**
                 * Creates a new alias and adds it to the current expression map.
                 */
                QueryExpressionMap.prototype.createAlias = function (options) {
                    var aliasName = options.name;
                    if (!aliasName && options.tableName)
                        aliasName = options.tableName;
                    if (!aliasName && options.target instanceof Function)
                        aliasName = options.target.name;
                    if (!aliasName && typeof options.target === "string")
                        aliasName = options.target;
                    var alias = new Alias_1.Alias();
                    if (aliasName)
                        alias.name = aliasName;
                    if (options.metadata)
                        alias.metadata = options.metadata;
                    if (options.target && !alias.hasMetadata)
                        alias.metadata = this.connection.getMetadata(options.target);
                    if (options.tableName)
                        alias.tableName = options.tableName;
                    this.aliases.push(alias);
                    return alias;
                };
                /**
                 * Finds alias with the given name.
                 * If alias was not found it throw an exception.
                 */
                QueryExpressionMap.prototype.findAliasByName = function (aliasName) {
                    var alias = this.aliases.find(function (alias) { return alias.name === aliasName; });
                    if (!alias)
                        throw new Error("\"" + aliasName + "\" alias was not found. Maybe you forgot to join it?");
                    return alias;
                };
                /**
                 * Copies all properties of the current QueryExpressionMap into a new one.
                 * Useful when QueryBuilder needs to create a copy of itself.
                 */
                QueryExpressionMap.prototype.clone = function () {
                    var _this = this;
                    var map = new QueryExpressionMap(this.connection);
                    map.queryType = this.queryType;
                    map.selects = this.selects.map(function (select) { return select; });
                    this.aliases.forEach(function (alias) { return map.aliases.push(new Alias_1.Alias(alias)); });
                    map.mainAlias = this.mainAlias;
                    map.updateSet = this.updateSet;
                    map.joinAttributes = this.joinAttributes.map(function (join) { return new JoinAttribute_1.JoinAttribute(_this.connection, _this, join); });
                    map.relationIdAttributes = this.relationIdAttributes.map(function (relationId) { return new RelationIdAttribute_1.RelationIdAttribute(_this, relationId); });
                    map.relationCountAttributes = this.relationCountAttributes.map(function (relationCount) { return new RelationCountAttribute_1.RelationCountAttribute(_this, relationCount); });
                    map.wheres = this.wheres.map(function (where) { return (__assign({}, where)); });
                    map.havings = this.havings.map(function (having) { return (__assign({}, having)); });
                    map.orderBys = Object.assign({}, this.orderBys);
                    map.groupBys = this.groupBys.map(function (groupBy) { return groupBy; });
                    map.limit = this.limit;
                    map.offset = this.offset;
                    map.skip = this.skip;
                    map.take = this.take;
                    map.lockMode = this.lockMode;
                    map.lockVersion = this.lockVersion;
                    map.parameters = Object.assign({}, this.parameters);
                    map.disableEscaping = this.disableEscaping;
                    map.ignoreParentTablesJoins = this.ignoreParentTablesJoins;
                    map.enableRelationIdValues = this.enableRelationIdValues;
                    return map;
                };
                return QueryExpressionMap;
            }());
            exports_38("QueryExpressionMap", QueryExpressionMap);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdAttribute", ["typeorm/query-builder/QueryBuilderUtils"], function (exports_39, context_39) {
    "use strict";
    var __moduleName = context_39 && context_39.id;
    var QueryBuilderUtils_3, RelationIdAttribute;
    return {
        setters: [
            function (QueryBuilderUtils_3_1) {
                QueryBuilderUtils_3 = QueryBuilderUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Stores all join relation id attributes which will be used to build a JOIN query.
             */
            RelationIdAttribute = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdAttribute(queryExpressionMap, relationIdAttribute) {
                    this.queryExpressionMap = queryExpressionMap;
                    /**
                     * Indicates if relation id should NOT be loaded as id map.
                     */
                    this.disableMixedMap = false;
                    Object.assign(this, relationIdAttribute || {});
                }
                Object.defineProperty(RelationIdAttribute.prototype, "joinInverseSideMetadata", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.relation.inverseEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "parentAlias", {
                    /**
                     * Alias of the parent of this join.
                     * For example, if we join ("post.category", "categoryAlias") then "post" is a parent alias.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.substr(0, this.relationName.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "relationPropertyPath", {
                    /**
                     * Relation property name of the parent.
                     * This is used to understand what is joined.
                     * For example, if we join ("post.category", "categoryAlias") then "category" is a relation property.
                     * This value is extracted from entityOrProperty value.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        return this.relationName.substr(this.relationName.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "relation", {
                    /**
                     * Relation of the parent.
                     * This is used to understand what is joined.
                     * This is available when join was made using "post.category" syntax.
                     */
                    get: function () {
                        if (!QueryBuilderUtils_3.QueryBuilderUtils.isAliasProperty(this.relationName))
                            throw new Error("Given value must be a string representation of alias property");
                        var relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);
                        var relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);
                        if (!relation)
                            throw new Error("Relation with property path " + this.relationPropertyPath + " in entity was not found.");
                        return relation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "junctionAlias", {
                    /**
                     * Generates alias of junction table, whose ids we get.
                     */
                    get: function () {
                        var _a = this.relationName.split("."), parentAlias = _a[0], relationProperty = _a[1];
                        return parentAlias + "_" + relationProperty + "_relation_id";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "junctionMetadata", {
                    /**
                     * Metadata of the joined entity.
                     * If extra condition without entity was joined, then it will return undefined.
                     */
                    get: function () {
                        return this.relation.junctionEntityMetadata;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "mapToPropertyParentAlias", {
                    get: function () {
                        return this.mapToProperty.substr(0, this.mapToProperty.indexOf("."));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(RelationIdAttribute.prototype, "mapToPropertyPropertyPath", {
                    get: function () {
                        return this.mapToProperty.substr(this.mapToProperty.indexOf(".") + 1);
                    },
                    enumerable: true,
                    configurable: true
                });
                return RelationIdAttribute;
            }());
            exports_39("RelationIdAttribute", RelationIdAttribute);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdLoadResult", [], function (exports_40, context_40) {
    "use strict";
    var __moduleName = context_40 && context_40.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountLoadResult", [], function (exports_41, context_41) {
    "use strict";
    var __moduleName = context_41 && context_41.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/util/OrmUtils", [], function (exports_42, context_42) {
    "use strict";
    var __moduleName = context_42 && context_42.id;
    var OrmUtils;
    return {
        setters: [],
        execute: function () {
            OrmUtils = (function () {
                function OrmUtils() {
                }
                OrmUtils.groupBy = function (array, propertyCallback) {
                    return array.reduce(function (groupedArray, value) {
                        var key = propertyCallback(value);
                        var grouped = groupedArray.find(function (i) { return i.id === key; });
                        if (!grouped) {
                            grouped = { id: key, items: [] };
                            groupedArray.push(grouped);
                        }
                        grouped.items.push(value);
                        return groupedArray;
                    }, []);
                };
                OrmUtils.isObject = function (item) {
                    return (item && typeof item === "object" && !Array.isArray(item));
                };
                /**
                 * Deep Object.assign.
                 *
                 * @see http://stackoverflow.com/a/34749873
                 */
                OrmUtils.mergeDeep = function (target) {
                    var sources = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        sources[_i - 1] = arguments[_i];
                    }
                    if (!sources.length)
                        return target;
                    var source = sources.shift();
                    if (this.isObject(target) && this.isObject(source)) {
                        for (var key in source) {
                            if (this.isObject(source[key])) {
                                if (!target[key])
                                    Object.assign(target, (_a = {}, _a[key] = {}, _a));
                                this.mergeDeep(target[key], source[key]);
                            }
                            else {
                                Object.assign(target, (_b = {}, _b[key] = source[key], _b));
                            }
                        }
                    }
                    return this.mergeDeep.apply(this, [target].concat(sources));
                    var _a, _b;
                };
                /**
                 * Deep compare objects.
                 *
                 * @see http://stackoverflow.com/a/1144249
                 */
                OrmUtils.deepCompare = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var i, l, leftChain, rightChain;
                    function compare2Objects(x, y) {
                        var p;
                        // remember that NaN === NaN returns false
                        // and isNaN(undefined) returns true
                        if (isNaN(x) && isNaN(y) && typeof x === "number" && typeof y === "number")
                            return true;
                        // Compare primitives and functions.
                        // Check if both arguments link to the same object.
                        // Especially useful on the step where we compare prototypes
                        if (x === y)
                            return true;
                        if (x.equals instanceof Function && x.equals(y))
                            return true;
                        // Works in case when functions are created in constructor.
                        // Comparing dates is a common scenario. Another built-ins?
                        // We can even handle functions passed across iframes
                        if ((typeof x === "function" && typeof y === "function") ||
                            (x instanceof Date && y instanceof Date) ||
                            (x instanceof RegExp && y instanceof RegExp) ||
                            (x instanceof String && y instanceof String) ||
                            (x instanceof Number && y instanceof Number))
                            return x.toString() === y.toString();
                        // At last checking prototypes as good as we can
                        if (!(x instanceof Object && y instanceof Object))
                            return false;
                        if (x.isPrototypeOf(y) || y.isPrototypeOf(x))
                            return false;
                        if (x.constructor !== y.constructor)
                            return false;
                        if (x.prototype !== y.prototype)
                            return false;
                        // Check for infinitive linking loops
                        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1)
                            return false;
                        // Quick checking of one object being a subset of another.
                        // todo: cache the structure of arguments[0] for performance
                        for (p in y) {
                            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                return false;
                            }
                            else if (typeof y[p] !== typeof x[p]) {
                                return false;
                            }
                        }
                        for (p in x) {
                            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                                return false;
                            }
                            else if (typeof y[p] !== typeof x[p]) {
                                return false;
                            }
                            switch (typeof (x[p])) {
                                case "object":
                                case "function":
                                    leftChain.push(x);
                                    rightChain.push(y);
                                    if (!compare2Objects(x[p], y[p])) {
                                        return false;
                                    }
                                    leftChain.pop();
                                    rightChain.pop();
                                    break;
                                default:
                                    if (x[p] !== y[p]) {
                                        return false;
                                    }
                                    break;
                            }
                        }
                        return true;
                    }
                    if (arguments.length < 1) {
                        return true; // Die silently? Don't know how to handle such case, please help...
                        // throw "Need two or more arguments to compare";
                    }
                    for (i = 1, l = arguments.length; i < l; i++) {
                        leftChain = []; // Todo: this can be cached
                        rightChain = [];
                        if (!compare2Objects(arguments[0], arguments[i])) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Transforms given value into boolean value.
                 */
                OrmUtils.toBoolean = function (value) {
                    if (typeof value === "boolean")
                        return value;
                    if (typeof value === "string")
                        return value === "true" || value === "1";
                    if (typeof value === "number")
                        return value > 0;
                    return false;
                };
                /**
                 * Composes an object from the given array of keys and values.
                 */
                OrmUtils.zipObject = function (keys, values) {
                    return keys.reduce(function (object, column, index) {
                        object[column] = values[index];
                        return object;
                    }, {});
                };
                return OrmUtils;
            }());
            exports_42("OrmUtils", OrmUtils);
        }
    };
});
System.register("typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", ["typeorm/util/OrmUtils"], function (exports_43, context_43) {
    "use strict";
    var __moduleName = context_43 && context_43.id;
    var OrmUtils_1, RawSqlResultsToEntityTransformer;
    return {
        setters: [
            function (OrmUtils_1_1) {
                OrmUtils_1 = OrmUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Transforms raw sql results returned from the database into entity object.
             * Entity is constructed based on its entity metadata.
             */
            RawSqlResultsToEntityTransformer = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RawSqlResultsToEntityTransformer(driver, joinAttributes, rawRelationIdResults, rawRelationCountResults) {
                    this.driver = driver;
                    this.joinAttributes = joinAttributes;
                    this.rawRelationIdResults = rawRelationIdResults;
                    this.rawRelationCountResults = rawRelationCountResults;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                RawSqlResultsToEntityTransformer.prototype.transform = function (rawResults, alias) {
                    var _this = this;
                    return this.group(rawResults, alias)
                        .map(function (group) { return _this.transformRawResultsGroup(group, alias); })
                        .filter(function (res) { return !!res; });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Groups given raw results by ids of given alias.
                 */
                RawSqlResultsToEntityTransformer.prototype.group = function (rawResults, alias) {
                    var groupedResults = [];
                    rawResults.forEach(function (rawResult) {
                        var id = alias.metadata.primaryColumns.map(function (column) { return rawResult[alias.name + "_" + column.databaseName]; }).join("_"); // todo: check partial
                        if (!id)
                            return;
                        var group = groupedResults.find(function (groupedResult) { return groupedResult.id === id; });
                        if (!group) {
                            group = { id: id, items: [] };
                            groupedResults.push(group);
                        }
                        group.items.push(rawResult);
                    });
                    return groupedResults.map(function (group) { return group.items; });
                };
                /**
                 * Transforms set of data results into single entity.
                 */
                RawSqlResultsToEntityTransformer.prototype.transformRawResultsGroup = function (rawResults, alias) {
                    var hasColumns = false, hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false, hasRelations = false, hasRelationIds = false, hasRelationCounts = false;
                    var entity = alias.metadata.create();
                    if (alias.metadata.discriminatorColumn) {
                        var discriminatorValues_1 = rawResults.map(function (result) { return result[alias.name + "_" + alias.metadata.discriminatorColumn.databaseName]; });
                        var metadata = alias.metadata.childEntityMetadatas.find(function (childEntityMetadata) {
                            return !!discriminatorValues_1.find(function (value) { return value === childEntityMetadata.discriminatorValue; });
                        });
                        if (metadata)
                            entity = metadata.create();
                    }
                    // get value from columns selections and put them into newly created entity
                    hasColumns = this.transformColumns(rawResults, alias, entity, alias.metadata.columns);
                    // add columns tables metadata
                    if (alias.metadata.parentEntityMetadata)
                        hasParentColumns = this.transformColumns(rawResults, alias, entity, alias.metadata.parentEntityMetadata.columns);
                    hasRelations = this.transformJoins(rawResults, entity, alias);
                    hasRelationIds = this.transformRelationIds(rawResults, alias, entity);
                    hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);
                    return (hasColumns || hasEmbeddedColumns || hasParentColumns || hasParentEmbeddedColumns || hasRelations || hasRelationIds || hasRelationCounts) ? entity : undefined;
                };
                // get value from columns selections and put them into object
                RawSqlResultsToEntityTransformer.prototype.transformColumns = function (rawResults, alias, entity, columns) {
                    var _this = this;
                    var hasData = false;
                    columns.forEach(function (column) {
                        var value = rawResults[0][alias.name + "_" + column.databaseName];
                        if (value === undefined || value === null || column.isVirtual || column.isParentId || column.isDiscriminator)
                            return;
                        column.setEntityValue(entity, _this.driver.prepareHydratedValue(value, column));
                        hasData = true;
                    });
                    return hasData;
                };
                /**
                 * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity,l
                 */
                RawSqlResultsToEntityTransformer.prototype.transformJoins = function (rawResults, entity, alias) {
                    var _this = this;
                    var hasData = false;
                    var discriminatorValue = "";
                    if (alias.metadata.discriminatorColumn)
                        discriminatorValue = rawResults[0][alias.name + "_" + alias.metadata.discriminatorColumn.databaseName];
                    this.joinAttributes.forEach(function (join) {
                        // skip joins without metadata
                        if (!join.metadata)
                            return;
                        // this check need to avoid setting properties than not belong to entity when single table inheritance used.
                        var metadata = alias.metadata.childEntityMetadatas.find(function (childEntityMetadata) { return discriminatorValue === childEntityMetadata.discriminatorValue; });
                        if (metadata && join.relation && metadata.target !== join.relation.target)
                            return;
                        // some checks to make sure this join is for current alias
                        if (join.mapToProperty) {
                            if (join.mapToPropertyParentAlias !== alias.name)
                                return;
                        }
                        else {
                            if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath)
                                return;
                        }
                        // transform joined data into entities
                        var mappedEntities = _this.transform(rawResults, join.alias);
                        var result = !join.isMany ? mappedEntities[0] : mappedEntities;
                        if (!result)
                            return;
                        // if join was mapped to some property then save result to that property
                        if (join.mapToPropertyPropertyName) {
                            entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds
                        }
                        else {
                            // console.log(result);
                            join.relation.setEntityValue(entity, result);
                        }
                        hasData = true;
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.transformRelationIds = function (rawSqlResults, alias, entity) {
                    var _this = this;
                    var hasData = false;
                    this.rawRelationIdResults.forEach(function (rawRelationIdResult) {
                        if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name)
                            return;
                        var relation = rawRelationIdResult.relationIdAttribute.relation;
                        var valueMap = _this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);
                        if (valueMap === undefined || valueMap === null)
                            return;
                        var idMaps = rawRelationIdResult.results.map(function (result) {
                            var entityPrimaryIds = _this.extractEntityPrimaryIds(relation, result);
                            if (!alias.metadata.compareIds(entityPrimaryIds, valueMap))
                                return;
                            var columns;
                            if (relation.isManyToOne || relation.isOneToOneOwner) {
                                columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                            }
                            else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                columns = relation.inverseEntityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                            }
                            else {
                                if (relation.isOwning) {
                                    columns = relation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                                }
                                else {
                                    columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                                }
                            }
                            // const idMapColumns = (relation.isOneToMany || relation.isOneToOneNotOwner) ? columns : columns.map(column => column.referencedColumn!);
                            // const idMap = idMapColumns.reduce((idMap, column) => {
                            //     return OrmUtils.mergeDeep(idMap, column.createValueMap(result[column.databaseName]));
                            // }, {} as ObjectLiteral); // need to create reusable function for this process
                            var idMap = columns.reduce(function (idMap, column) {
                                if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                    return OrmUtils_1.OrmUtils.mergeDeep(idMap, column.createValueMap(result[column.databaseName]));
                                }
                                else {
                                    return OrmUtils_1.OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(result[column.databaseName]));
                                }
                            }, {});
                            if (columns.length === 1 && rawRelationIdResult.relationIdAttribute.disableMixedMap === false) {
                                if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                                    return columns[0].getEntityValue(idMap);
                                }
                                else {
                                    return columns[0].referencedColumn.getEntityValue(idMap);
                                }
                            }
                            return idMap;
                        }).filter(function (result) { return result; });
                        var properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(".");
                        var mapToProperty = function (properties, map, value) {
                            var property = properties.shift();
                            if (property && properties.length === 0) {
                                map[property] = value;
                                return map;
                            }
                            else if (property && properties.length > 0) {
                                mapToProperty(properties, map[property], value);
                            }
                            else {
                                return map;
                            }
                        };
                        if (relation.isOneToOne || relation.isManyToOne) {
                            mapToProperty(properties, entity, idMaps[0]);
                        }
                        else {
                            mapToProperty(properties, entity, idMaps);
                        }
                        hasData = true;
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.transformRelationCounts = function (rawSqlResults, alias, entity) {
                    var hasData = false;
                    this.rawRelationCountResults
                        .filter(function (rawRelationCountResult) { return rawRelationCountResult.relationCountAttribute.parentAlias === alias.name; })
                        .forEach(function (rawRelationCountResult) {
                        var relation = rawRelationCountResult.relationCountAttribute.relation;
                        var referenceColumnName;
                        if (relation.isOneToMany) {
                            referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]
                        }
                        else {
                            referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
                        }
                        var referenceColumnValue = rawSqlResults[0][alias.name + "_" + referenceColumnName]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work
                        if (referenceColumnValue !== undefined && referenceColumnValue !== null) {
                            entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;
                            rawRelationCountResult.results
                                .filter(function (result) { return result["parentId"] === referenceColumnValue; })
                                .forEach(function (result) {
                                entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result["cnt"]);
                                hasData = true;
                            });
                        }
                    });
                    return hasData;
                };
                RawSqlResultsToEntityTransformer.prototype.createValueMapFromJoinColumns = function (relation, parentAlias, rawSqlResults) {
                    var columns;
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else {
                        if (relation.isOwning) {
                            columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                        else {
                            columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                    }
                    return columns.reduce(function (valueMap, column) {
                        rawSqlResults.forEach(function (rawSqlResult) {
                            if (relation.isManyToOne || relation.isOneToOneOwner) {
                                valueMap[column.databaseName] = rawSqlResult[parentAlias + "_" + column.databaseName];
                            }
                            else {
                                valueMap[column.databaseName] = rawSqlResult[parentAlias + "_" + column.referencedColumn.databaseName];
                            }
                        });
                        return valueMap;
                    }, {});
                };
                RawSqlResultsToEntityTransformer.prototype.extractEntityPrimaryIds = function (relation, relationIdRawResult) {
                    var columns;
                    if (relation.isManyToOne || relation.isOneToOneOwner) {
                        columns = relation.entityMetadata.primaryColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                        columns = relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn; });
                    }
                    else {
                        if (relation.isOwning) {
                            columns = relation.joinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                        else {
                            columns = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) { return joinColumn; });
                        }
                    }
                    return columns.reduce(function (data, column) {
                        data[column.databaseName] = relationIdRawResult[column.databaseName];
                        return data;
                    }, {});
                };
                return RawSqlResultsToEntityTransformer;
            }());
            exports_43("RawSqlResultsToEntityTransformer", RawSqlResultsToEntityTransformer);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_44, context_44) {
    "use strict";
    var __moduleName = context_44 && context_44.id;
    var TransactionAlreadyStartedError_2, TransactionNotStartedError_2, DataTypeNotSupportedByDriverError_2, ColumnSchema_3, TableSchema_2, ForeignKeySchema_2, PrimaryKeySchema_2, IndexSchema_1, QueryRunnerAlreadyReleasedError_2, SqlServerQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_2_1) {
                TransactionAlreadyStartedError_2 = TransactionAlreadyStartedError_2_1;
            },
            function (TransactionNotStartedError_2_1) {
                TransactionNotStartedError_2 = TransactionNotStartedError_2_1;
            },
            function (DataTypeNotSupportedByDriverError_2_1) {
                DataTypeNotSupportedByDriverError_2 = DataTypeNotSupportedByDriverError_2_1;
            },
            function (ColumnSchema_3_1) {
                ColumnSchema_3 = ColumnSchema_3_1;
            },
            function (TableSchema_2_1) {
                TableSchema_2 = TableSchema_2_1;
            },
            function (ForeignKeySchema_2_1) {
                ForeignKeySchema_2 = ForeignKeySchema_2_1;
            },
            function (PrimaryKeySchema_2_1) {
                PrimaryKeySchema_2 = PrimaryKeySchema_2_1;
            },
            function (IndexSchema_1_1) {
                IndexSchema_1 = IndexSchema_1_1;
            },
            function (QueryRunnerAlreadyReleasedError_2_1) {
                QueryRunnerAlreadyReleasedError_2 = QueryRunnerAlreadyReleasedError_2_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            SqlServerQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                SqlServerQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                SqlServerQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var allTablesSql, allTablesResults, tableNames, error_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 7, 9, 11]);
                                    allTablesSql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'";
                                    return [4 /*yield*/, this.query(allTablesSql)];
                                case 3:
                                    allTablesResults = _a.sent();
                                    tableNames = allTablesResults.map(function (result) { return result["TABLE_NAME"]; });
                                    return [4 /*yield*/, Promise.all(tableNames.map(function (tableName) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var dropForeignKeySql, dropFkQueries;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        dropForeignKeySql = "SELECT 'ALTER TABLE ' +  OBJECT_SCHEMA_NAME(parent_object_id) + '.[' + OBJECT_NAME(parent_object_id) + '] DROP CONSTRAINT ' + name as query FROM sys.foreign_keys WHERE referenced_object_id = object_id('" + tableName + "')";
                                                        return [4 /*yield*/, this.query(dropForeignKeySql)];
                                                    case 1:
                                                        dropFkQueries = _a.sent();
                                                        return [2 /*return*/, Promise.all(dropFkQueries.map(function (result) { return result["query"]; }).map(function (dropQuery) {
                                                                return _this.query(dropQuery);
                                                            }))];
                                                }
                                            });
                                        }); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(tableNames.map(function (tableName) {
                                            var dropTableSql = "DROP TABLE \"" + tableName + "\"";
                                            return _this.query(dropTableSql);
                                        }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 7:
                                    error_2 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    throw error_2;
                                case 9: return [4 /*yield*/, this.release()];
                                case 10:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                SqlServerQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_2.TransactionAlreadyStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.isTransactionActive = true;
                                    _this.databaseConnection.transaction = _this.databaseConnection.connection.transaction();
                                    _this.databaseConnection.transaction.begin(function (err) {
                                        if (err) {
                                            _this.databaseConnection.isTransactionActive = false;
                                            return fail(err);
                                        }
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                SqlServerQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_2.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.transaction.commit(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.databaseConnection.isTransactionActive = false;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                SqlServerQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_2.TransactionNotStartedError();
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.databaseConnection.transaction.rollback(function (err) {
                                        if (err)
                                            return fail(err);
                                        _this.databaseConnection.isTransactionActive = false;
                                        ok();
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                SqlServerQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                SqlServerQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var request = new _this.driver.mssql.Request(_this.isTransactionActive() ? _this.databaseConnection.transaction : _this.databaseConnection.connection);
                        if (parameters && parameters.length) {
                            parameters.forEach(function (parameter, index) {
                                request.input(index, parameters[index]);
                            });
                        }
                        request.query(query, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result);
                        });
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                SqlServerQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key, index) { return "@" + index; }).join(",");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") " + (generatedColumn ? "OUTPUT INSERTED." + generatedColumn.databaseName + " " : "") + "VALUES (" + values + ")"
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " " + (generatedColumn ? "OUTPUT INSERTED." + generatedColumn.databaseName + " " : "") + "DEFAULT VALUES ";
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, generatedColumn ? result instanceof Array ? result[0][generatedColumn.databaseName] : result[generatedColumn.databaseName] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                SqlServerQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionParams, updateParams, allParameters, updateValues, conditionString, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, updateParams.length).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                SqlServerQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                SqlServerQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                SqlServerQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                SqlServerQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, tablesSql, columnsSql, constraintsSql, identityColumnsSql, indicesSql, _a, dbTables, dbColumns, dbConstraints, dbIdentityColumns, dbIndices;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_CATALOG = '" + this.dbName + "'";
                                    constraintsSql = "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages " +
                                        "LEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME " +
                                        ("WHERE columnUsages.TABLE_CATALOG = '" + this.dbName + "' AND tableConstraints.TABLE_CATALOG = '" + this.dbName + "'");
                                    identityColumnsSql = "SELECT COLUMN_NAME, TABLE_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_CATALOG = '" + this.dbName + "' AND COLUMNPROPERTY(object_id(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1;";
                                    indicesSql = "SELECT TABLE_NAME = t.name, INDEX_NAME = ind.name, IndexId = ind.index_id, ColumnId = ic.index_column_id, COLUMN_NAME = col.name, ind.*, ic.*, col.* " +
                                        "FROM sys.indexes ind INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id " +
                                        "INNER JOIN sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0 ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(constraintsSql),
                                            this.query(identityColumnsSql),
                                            this.query(indicesSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbConstraints = _a[2], dbIdentityColumns = _a[3], dbIndices = _a[4];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema;
                                            return __generator(this, function (_a) {
                                                tableSchema = new TableSchema_2.TableSchema(dbTable["TABLE_NAME"]);
                                                // create column schemas from the loaded columns
                                                tableSchema.columns = dbColumns
                                                    .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                    .map(function (dbColumn) {
                                                    var isPrimary = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                    });
                                                    var isGenerated = !!dbIdentityColumns.find(function (column) {
                                                        return column["TABLE_NAME"] === tableSchema.name &&
                                                            column["COLUMN_NAME"] === dbColumn["COLUMN_NAME"];
                                                    });
                                                    var isUnique = !!dbConstraints.find(function (dbConstraint) {
                                                        return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                            dbConstraint["COLUMN_NAME"] === dbColumn["COLUMN_NAME"] &&
                                                            dbConstraint["CONSTRAINT_TYPE"] === "UNIQUE";
                                                    });
                                                    var columnSchema = new ColumnSchema_3.ColumnSchema();
                                                    columnSchema.name = dbColumn["COLUMN_NAME"];
                                                    columnSchema.type = dbColumn["DATA_TYPE"].toLowerCase() + (dbColumn["CHARACTER_MAXIMUM_LENGTH"] ? "(" + dbColumn["CHARACTER_MAXIMUM_LENGTH"] + ")" : ""); // todo: use normalize type?
                                                    columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                    columnSchema.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                    columnSchema.isPrimary = isPrimary;
                                                    columnSchema.isGenerated = isGenerated;
                                                    columnSchema.isUnique = isUnique;
                                                    columnSchema.comment = ""; // todo: less priority, implement this later
                                                    return columnSchema;
                                                });
                                                // create primary key schema
                                                tableSchema.primaryKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "PRIMARY KEY";
                                                })
                                                    .map(function (keyColumnUsage) {
                                                    return new PrimaryKeySchema_2.PrimaryKeySchema(keyColumnUsage["CONSTRAINT_NAME"], keyColumnUsage["COLUMN_NAME"]);
                                                });
                                                // create foreign key schemas from the loaded indices
                                                tableSchema.foreignKeys = dbConstraints
                                                    .filter(function (dbConstraint) {
                                                    return dbConstraint["TABLE_NAME"] === tableSchema.name &&
                                                        dbConstraint["CONSTRAINT_TYPE"] === "FOREIGN KEY";
                                                })
                                                    .map(function (dbConstraint) { return new ForeignKeySchema_2.ForeignKeySchema(dbConstraint["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                // create index schemas from the loaded indices
                                                tableSchema.indices = dbIndices
                                                    .filter(function (dbIndex) {
                                                    return dbIndex["TABLE_NAME"] === tableSchema.name &&
                                                        (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                        (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                })
                                                    .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                    .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                    .map(function (dbIndexName) {
                                                    var columnNames = dbIndices
                                                        .filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName; })
                                                        .map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                    return new IndexSchema_1.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness? */);
                                                });
                                                return [2 /*return*/, tableSchema];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                SqlServerQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                SqlServerQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    sql += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) { return ", CONSTRAINT \"uk_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")"; })
                                        .join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                SqlServerQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_CATALOG = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                SqlServerQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_2.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                SqlServerQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                SqlServerQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_2.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_3.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_3.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_2.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_3.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isGenerated !== oldColumn.isGenerated)) return [3 /*break*/, 6];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP COLUMN \"" + newColumn.name + "\"")];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD " + this.buildCreateColumnSql(newColumn))];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6:
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN " + this.buildCreateColumnSql(newColumn, true);
                                    return [4 /*yield*/, this.query(sql)];
                                case 7:
                                    _a.sent();
                                    if (!(newColumn.isUnique !== oldColumn.isUnique)) return [3 /*break*/, 11];
                                    if (!(newColumn.isUnique === true)) return [3 /*break*/, 9];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD CONSTRAINT \"uk_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")")];
                                case 8:
                                    _a.sent();
                                    return [3 /*break*/, 11];
                                case 9:
                                    if (!(newColumn.isUnique === false)) return [3 /*break*/, 11];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"uk_" + newColumn.name + "\"")];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqlServerQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_2.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_3.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP COLUMN \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                SqlServerQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                SqlServerQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var oldPrimaryKeySql, oldPrimaryKey, primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    oldPrimaryKeySql = "SELECT columnUsages.*, tableConstraints.CONSTRAINT_TYPE FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE columnUsages\nLEFT JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS tableConstraints ON tableConstraints.CONSTRAINT_NAME = columnUsages.CONSTRAINT_NAME AND tableConstraints.CONSTRAINT_TYPE = 'PRIMARY KEY'\nWHERE columnUsages.TABLE_CATALOG = '" + this.dbName + "' AND tableConstraints.TABLE_CATALOG = '" + this.dbName + "'";
                                    return [4 /*yield*/, this.query(oldPrimaryKeySql)];
                                case 1:
                                    oldPrimaryKey = _a.sent();
                                    if (!(oldPrimaryKey.length > 0)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT \"" + oldPrimaryKey[0]["CONSTRAINT_NAME"] + "\"")];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                SqlServerQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_2.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "\"" + column + "\""; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "\"" + column + "\""; }).join(",");
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                SqlServerQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_2.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                SqlServerQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                SqlServerQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                SqlServerQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_2.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + tableName + "\".\"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                SqlServerQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            if (typeOptions.fixedLength) {
                                return "nchar(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                            else {
                                return "nvarchar(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                        case "text":
                            return "ntext";
                        case "boolean":
                            return "bit";
                        case "integer":
                        case "int":
                            return "int";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "float";
                        case "double":
                        case "number":
                            return "real";
                        case "decimal":
                            // if (column.precision && column.scale) {
                            //     return `decimal(${column.precision},${column.scale})`;
                            //
                            // } else if (column.scale) {
                            //     return `decimal(${column.scale})`;
                            //
                            // } else if (column.precision) {
                            //     return `decimal(${column.precision})`;
                            //
                            // } else {
                            return "decimal";
                        // }
                        case "date":
                            return "date";
                        case "time":
                            return "time";
                        case "datetime":
                            return "datetime";
                        case "json":
                            return "text";
                        case "simple_array":
                            return typeOptions.length ? "nvarchar(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_2.DataTypeNotSupportedByDriverError(typeOptions.type, "SQLServer");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                SqlServerQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                SqlServerQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(SqlServerQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                SqlServerQueryRunner.prototype.parametrize = function (objectLiteral, startFrom) {
                    var _this = this;
                    if (startFrom === void 0) { startFrom = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) {
                        return _this.driver.escapeColumnName(key) + "=@" + (startFrom + index);
                    });
                };
                /**
                 * Builds a query for create column.
                 */
                SqlServerQueryRunner.prototype.buildCreateColumnSql = function (column, skipIdentity) {
                    if (skipIdentity === void 0) { skipIdentity = false; }
                    var c = "\"" + column.name + "\" " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isGenerated === true && !skipIdentity)
                        c += " IDENTITY(1,1)";
                    // if (column.isPrimary === true && !skipPrimary)
                    //     c += " PRIMARY KEY";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "1" : "0") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return SqlServerQueryRunner;
            }());
            exports_44("SqlServerQueryRunner", SqlServerQueryRunner);
        }
    };
});
System.register("typeorm/driver/sqlserver/SqlServerDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/sqlserver/SqlServerQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_45, context_45) {
    "use strict";
    var __moduleName = context_45 && context_45.id;
    var ConnectionIsNotSetError_2, DriverPackageNotInstalledError_2, DriverUtils_2, SqlServerQueryRunner_1, ColumnTypes_2, DriverOptionNotSetError_2, DataTransformationUtils_2, PlatformTools_3, SqlServerDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_2_1) {
                ConnectionIsNotSetError_2 = ConnectionIsNotSetError_2_1;
            },
            function (DriverPackageNotInstalledError_2_1) {
                DriverPackageNotInstalledError_2 = DriverPackageNotInstalledError_2_1;
            },
            function (DriverUtils_2_1) {
                DriverUtils_2 = DriverUtils_2_1;
            },
            function (SqlServerQueryRunner_1_1) {
                SqlServerQueryRunner_1 = SqlServerQueryRunner_1_1;
            },
            function (ColumnTypes_2_1) {
                ColumnTypes_2 = ColumnTypes_2_1;
            },
            function (DriverOptionNotSetError_2_1) {
                DriverOptionNotSetError_2 = DriverOptionNotSetError_2_1;
            },
            function (DataTransformationUtils_2_1) {
                DataTransformationUtils_2 = DataTransformationUtils_2_1;
            },
            function (PlatformTools_3_1) {
                PlatformTools_3 = PlatformTools_3_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with SQL Server DBMS.
             */
            SqlServerDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqlServerDriver(options, logger, mssql) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_2.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    this.mssql = mssql;
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_2.DriverOptionNotSetError("database");
                    // if mssql package instance was not set explicitly then try to load it
                    if (!mssql)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                SqlServerDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        server: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // set default useUTC option if it hasn't been set
                    if (!options.options)
                        options.options = { useUTC: false };
                    else if (!options.options.useUTC)
                        options.options.useUTC = false;
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    return new Promise(function (ok, fail) {
                        var connection = new _this.mssql.Connection(options).connect(function (err) {
                            if (err)
                                return fail(err);
                            _this.connection = connection;
                            if (_this.options.usePool === false) {
                                _this.databaseConnection = {
                                    id: 1,
                                    connection: new _this.mssql.Request(connection),
                                    isTransactionActive: false
                                };
                            }
                            ok();
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                SqlServerDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.connection)
                                throw new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mssql");
                            this.connection.close();
                            this.connection = undefined;
                            this.databaseConnection = undefined;
                            this.databaseConnectionPool = [];
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                SqlServerDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.connection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mssql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new SqlServerQueryRunner_1.SqlServerQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                SqlServerDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.mssql,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.connection
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                SqlServerDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                escapedParameters.push(v);
                                return "@" + (escapedParameters.length - 1);
                            }).join(", ");
                        }
                        else {
                            escapedParameters.push(value);
                        }
                        return "@" + (escapedParameters.length - 1);
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                SqlServerDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                SqlServerDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                SqlServerDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                SqlServerDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_2.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_2.ColumnTypes.DATE:
                            return DataTransformationUtils_2.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_2.ColumnTypes.TIME:
                            return DataTransformationUtils_2.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_2.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_2.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_2.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_2.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_2.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_2.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                SqlServerDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_2.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_2.ColumnTypes.DATETIME:
                            return DataTransformationUtils_2.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_2.ColumnTypes.DATE:
                            return DataTransformationUtils_2.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_2.ColumnTypes.TIME:
                            return DataTransformationUtils_2.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_2.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_2.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_2.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                SqlServerDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (!this.connection)
                        throw new ConnectionIsNotSetError_2.ConnectionIsNotSetError("mssql");
                    return new Promise(function (ok, fail) {
                        if (_this.databaseConnection)
                            return ok(_this.databaseConnection);
                        // let dbConnection: DatabaseConnection|undefined;
                        // const connection = this.pool.connect((err: any) => {
                        //     if (err)
                        //         return fail(err);
                        //     ok(dbConnection);
                        // });
                        //
                        // console.log(connection);
                        // console.log(this.pool);
                        // console.log(this.pool === connection);
                        // const request = new this.mssql.Request(this.connection);
                        // console.log("request:", request);
                        // let dbConnection = this.databaseConnectionPool.find(dbConnection => dbConnection.connection === connection);
                        // if (!dbConnection) {
                        var dbConnection = {
                            id: _this.databaseConnectionPool.length,
                            connection: _this.connection,
                            isTransactionActive: false
                        };
                        dbConnection.releaseCallback = function () {
                            // }
                            // if (this.connection && dbConnection) {
                            // request.release();
                            _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                            return Promise.resolve();
                        };
                        _this.databaseConnectionPool.push(dbConnection);
                        ok(dbConnection);
                        // }
                    });
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqlServerDriver.prototype.loadDependencies = function () {
                    try {
                        this.mssql = PlatformTools_3.PlatformTools.load("mssql");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_2.DriverPackageNotInstalledError("SQL Server", "mssql");
                    }
                };
                return SqlServerDriver;
            }());
            exports_45("SqlServerDriver", SqlServerDriver);
        }
    };
});
System.register("typeorm/query-runner/QueryRunnerProvider", [], function (exports_46, context_46) {
    "use strict";
    var __moduleName = context_46 && context_46.id;
    var QueryRunnerProvider;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents functionality to provide a new query runners, and release old ones.
             * Also can provide always same query runner.
             */
            QueryRunnerProvider = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryRunnerProvider(driver, useSingleQueryRunner) {
                    if (useSingleQueryRunner === void 0) { useSingleQueryRunner = false; }
                    this.driver = driver;
                    this.useSingleQueryRunner = useSingleQueryRunner;
                }
                Object.defineProperty(QueryRunnerProvider.prototype, "isReleased", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this._isReleased;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Provides a new query runner used to run repository queries.
                 * If use useSingleQueryRunner mode is enabled then reusable query runner will be provided instead.
                 */
                QueryRunnerProvider.prototype.provide = function () {
                    var _this = this;
                    if (this.useSingleQueryRunner) {
                        if (!this.reusableQueryRunner) {
                            if (!this.reusableQueryRunnerPromise) {
                                // we do this because this method can be created multiple times
                                // this will lead to multiple query runner creations
                                this.reusableQueryRunnerPromise = this.driver
                                    .createQueryRunner()
                                    .then(function (reusableQueryRunner) {
                                    _this.reusableQueryRunner = reusableQueryRunner;
                                    return reusableQueryRunner;
                                });
                            }
                            return this.reusableQueryRunnerPromise;
                        }
                        return Promise.resolve(this.reusableQueryRunner);
                    }
                    return this.driver.createQueryRunner();
                };
                /**
                 * Query runner release logic extracted into separated methods intently,
                 * to make possible to create a subclass with its own release query runner logic.
                 * Note: release only query runners that provided by a provide() method.
                 * This is important and by design.
                 */
                QueryRunnerProvider.prototype.release = function (queryRunner) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (queryRunner === this.reusableQueryRunner)
                                return [2 /*return*/];
                            return [2 /*return*/, queryRunner.release()];
                        });
                    });
                };
                /**
                 * Releases reused query runner.
                 */
                QueryRunnerProvider.prototype.releaseReused = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this._isReleased = true;
                            if (this.reusableQueryRunner)
                                return [2 /*return*/, this.reusableQueryRunner.release()];
                            return [2 /*return*/];
                        });
                    });
                };
                return QueryRunnerProvider;
            }());
            exports_46("QueryRunnerProvider", QueryRunnerProvider);
        }
    };
});
System.register("typeorm/query-builder/error/PessimisticLockTransactionRequiredError", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    var PessimisticLockTransactionRequiredError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when a transaction is required for the current operation, but there is none open.
             */
            PessimisticLockTransactionRequiredError = (function (_super) {
                __extends(PessimisticLockTransactionRequiredError, _super);
                function PessimisticLockTransactionRequiredError() {
                    var _this = _super.call(this) || this;
                    _this.name = "PessimisticLockTransactionRequiredError";
                    Object.setPrototypeOf(_this, PessimisticLockTransactionRequiredError.prototype);
                    _this.message = "An open transaction is required for pessimistic lock.";
                    return _this;
                }
                return PessimisticLockTransactionRequiredError;
            }(Error));
            exports_47("PessimisticLockTransactionRequiredError", PessimisticLockTransactionRequiredError);
        }
    };
});
System.register("typeorm/query-builder/error/NoVersionOrUpdateDateColumnError", [], function (exports_48, context_48) {
    "use strict";
    var __moduleName = context_48 && context_48.id;
    var NoVersionOrUpdateDateColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when an entity does not have no version and no update date column.
             */
            NoVersionOrUpdateDateColumnError = (function (_super) {
                __extends(NoVersionOrUpdateDateColumnError, _super);
                function NoVersionOrUpdateDateColumnError(entity) {
                    var _this = _super.call(this) || this;
                    _this.name = "NoVersionOrUpdateDateColumnError";
                    Object.setPrototypeOf(_this, NoVersionOrUpdateDateColumnError.prototype);
                    _this.message = "Entity " + entity + " does not have version or update date columns.";
                    return _this;
                }
                return NoVersionOrUpdateDateColumnError;
            }(Error));
            exports_48("NoVersionOrUpdateDateColumnError", NoVersionOrUpdateDateColumnError);
        }
    };
});
System.register("typeorm/query-builder/error/OptimisticLockVersionMismatchError", [], function (exports_49, context_49) {
    "use strict";
    var __moduleName = context_49 && context_49.id;
    var OptimisticLockVersionMismatchError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when a version check on an object that uses optimistic locking through a version field fails.
             */
            OptimisticLockVersionMismatchError = (function (_super) {
                __extends(OptimisticLockVersionMismatchError, _super);
                function OptimisticLockVersionMismatchError(entity, expectedVersion, actualVersion) {
                    var _this = _super.call(this) || this;
                    _this.name = "OptimisticLockVersionMismatchError";
                    Object.setPrototypeOf(_this, OptimisticLockVersionMismatchError.prototype);
                    _this.message = "The optimistic lock on entity " + entity + " failed, version " + expectedVersion + " was expected, but is actually " + actualVersion + ".";
                    return _this;
                }
                return OptimisticLockVersionMismatchError;
            }(Error));
            exports_49("OptimisticLockVersionMismatchError", OptimisticLockVersionMismatchError);
        }
    };
});
System.register("typeorm/query-builder/error/OptimisticLockCanNotBeUsedError", [], function (exports_50, context_50) {
    "use strict";
    var __moduleName = context_50 && context_50.id;
    var OptimisticLockCanNotBeUsedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when an optimistic lock cannot be used in query builder.
             */
            OptimisticLockCanNotBeUsedError = (function (_super) {
                __extends(OptimisticLockCanNotBeUsedError, _super);
                function OptimisticLockCanNotBeUsedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "OptimisticLockCanNotBeUsedError";
                    Object.setPrototypeOf(_this, OptimisticLockCanNotBeUsedError.prototype);
                    _this.message = "The optimistic lock can be used only with getOne() method.";
                    return _this;
                }
                return OptimisticLockCanNotBeUsedError;
            }(Error));
            exports_50("OptimisticLockCanNotBeUsedError", OptimisticLockCanNotBeUsedError);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_51, context_51) {
    "use strict";
    var __moduleName = context_51 && context_51.id;
    var TransactionAlreadyStartedError_3, TransactionNotStartedError_3, DataTypeNotSupportedByDriverError_3, ColumnSchema_4, TableSchema_3, IndexSchema_2, ForeignKeySchema_3, PrimaryKeySchema_3, QueryRunnerAlreadyReleasedError_3, PostgresQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_3_1) {
                TransactionAlreadyStartedError_3 = TransactionAlreadyStartedError_3_1;
            },
            function (TransactionNotStartedError_3_1) {
                TransactionNotStartedError_3 = TransactionNotStartedError_3_1;
            },
            function (DataTypeNotSupportedByDriverError_3_1) {
                DataTypeNotSupportedByDriverError_3 = DataTypeNotSupportedByDriverError_3_1;
            },
            function (ColumnSchema_4_1) {
                ColumnSchema_4 = ColumnSchema_4_1;
            },
            function (TableSchema_3_1) {
                TableSchema_3 = TableSchema_3_1;
            },
            function (IndexSchema_2_1) {
                IndexSchema_2 = IndexSchema_2_1;
            },
            function (ForeignKeySchema_3_1) {
                ForeignKeySchema_3 = ForeignKeySchema_3_1;
            },
            function (PrimaryKeySchema_3_1) {
                PrimaryKeySchema_3 = PrimaryKeySchema_3_1;
            },
            function (QueryRunnerAlreadyReleasedError_3_1) {
                QueryRunnerAlreadyReleasedError_3 = QueryRunnerAlreadyReleasedError_3_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single postgres database connection.
             */
            PostgresQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                    this.schemaName = driver.schemaName || "public";
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 */
                PostgresQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                PostgresQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 10]);
                                    selectDropsQuery = "SELECT 'DROP TABLE IF EXISTS \"' || tablename || '\" CASCADE;' as query FROM pg_tables WHERE schemaname = '" + this.schemaName + "'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 6:
                                    error_3 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw error_3;
                                case 8: return [4 /*yield*/, this.release()];
                                case 9:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 10: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                PostgresQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_3.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                PostgresQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                PostgresQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_3.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                PostgresQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                PostgresQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                    // console.log("query: ", query);
                    // console.log("parameters: ", parameters);
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.query(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                fail(err);
                            }
                            else {
                                ok(result.rows);
                            }
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                PostgresQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                                    sql = columns.length > 0
                                        ? "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ") " + (generatedColumn ? " RETURNING " + this.driver.escapeColumnName(generatedColumn.databaseName) : "")
                                        : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES " + (generatedColumn ? " RETURNING " + this.driver.escapeColumnName(generatedColumn.databaseName) : "");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    if (generatedColumn)
                                        return [2 /*return*/, result[0][generatedColumn.databaseName]];
                                    return [2 /*return*/, result];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                PostgresQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                PostgresQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                PostgresQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                PostgresQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                PostgresQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, uniqueKeysSql, primaryKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys, dbUniqueKeys, primaryKeys;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (name) { return "'" + name + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM information_schema.tables WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM information_schema.columns WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "'";
                                    indicesSql = "SELECT t.relname AS table_name, i.relname AS index_name, a.attname AS column_name  FROM pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_namespace ns\nWHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid\nAND a.attnum = ANY(ix.indkey) AND t.relkind = 'r' AND t.relname IN (" + tableNamesString + ") AND t.relnamespace = ns.OID AND ns.nspname ='" + this.schemaName + "' ORDER BY t.relname, i.relname";
                                    foreignKeysSql = "SELECT table_name, constraint_name FROM information_schema.table_constraints WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND constraint_type = 'FOREIGN KEY'";
                                    uniqueKeysSql = "SELECT * FROM information_schema.table_constraints WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND constraint_type = 'UNIQUE'";
                                    primaryKeysSql = "SELECT c.column_name, tc.table_name, tc.constraint_name FROM information_schema.table_constraints tc\nJOIN information_schema.constraint_column_usage AS ccu USING (constraint_schema, constraint_name)\nJOIN information_schema.columns AS c ON c.table_schema = tc.constraint_schema AND tc.table_name = c.table_name AND ccu.column_name = c.column_name\nwhere constraint_type = 'PRIMARY KEY' AND c.table_schema = '" + this.schemaName + "' and tc.table_catalog = '" + this.dbName + "'";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql),
                                            this.query(uniqueKeysSql),
                                            this.query(primaryKeysSql),
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3], dbUniqueKeys = _a[4], primaryKeys = _a[5];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, dbTables.map(function (dbTable) {
                                            var tableSchema = new TableSchema_3.TableSchema(dbTable["table_name"]);
                                            // create column schemas from the loaded columns
                                            tableSchema.columns = dbColumns
                                                .filter(function (dbColumn) { return dbColumn["table_name"] === tableSchema.name; })
                                                .map(function (dbColumn) {
                                                var columnType = dbColumn["data_type"].toLowerCase() + (dbColumn["character_maximum_length"] !== undefined && dbColumn["character_maximum_length"] !== null ? ("(" + dbColumn["character_maximum_length"] + ")") : "");
                                                var isGenerated = dbColumn["column_default"] === "nextval('" + dbColumn["table_name"] + "_id_seq'::regclass)"
                                                    || dbColumn["column_default"] === "nextval('\"" + dbColumn["table_name"] + "_id_seq\"'::regclass)"
                                                    || /^uuid\_generate\_v\d\(\)/.test(dbColumn["column_default"]);
                                                var columnSchema = new ColumnSchema_4.ColumnSchema();
                                                columnSchema.name = dbColumn["column_name"];
                                                columnSchema.type = columnType;
                                                columnSchema.default = dbColumn["column_default"] !== null && dbColumn["column_default"] !== undefined ? dbColumn["column_default"] : undefined;
                                                columnSchema.isNullable = dbColumn["is_nullable"] === "YES";
                                                // columnSchema.isPrimary = dbColumn["column_key"].indexOf("PRI") !== -1;
                                                columnSchema.isGenerated = isGenerated;
                                                columnSchema.comment = ""; // dbColumn["COLUMN_COMMENT"];
                                                columnSchema.isUnique = !!dbUniqueKeys.find(function (key) { return key["constraint_name"] === "uk_" + dbColumn["table_name"] + "_" + dbColumn["column_name"]; });
                                                return columnSchema;
                                            });
                                            // create primary key schema
                                            tableSchema.primaryKeys = primaryKeys
                                                .filter(function (primaryKey) { return primaryKey["table_name"] === tableSchema.name; })
                                                .map(function (primaryKey) { return new PrimaryKeySchema_3.PrimaryKeySchema(primaryKey["constraint_name"], primaryKey["column_name"]); });
                                            // create foreign key schemas from the loaded indices
                                            tableSchema.foreignKeys = dbForeignKeys
                                                .filter(function (dbForeignKey) { return dbForeignKey["table_name"] === tableSchema.name; })
                                                .map(function (dbForeignKey) { return new ForeignKeySchema_3.ForeignKeySchema(dbForeignKey["constraint_name"], [], [], "", ""); }); // todo: fix missing params
                                            // create unique key schemas from the loaded indices
                                            /*tableSchema.uniqueKeys = dbUniqueKeys
                                                .filter(dbUniqueKey => dbUniqueKey["table_name"] === tableSchema.name)
                                                .map(dbUniqueKey => {
                                                    return new UniqueKeySchema(dbUniqueKey["TABLE_NAME"], dbUniqueKey["CONSTRAINT_NAME"], [/!* todo *!/]);
                                                });*/
                                            // create index schemas from the loaded indices
                                            tableSchema.indices = dbIndices
                                                .filter(function (dbIndex) {
                                                return dbIndex["table_name"] === tableSchema.name &&
                                                    (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["index_name"]; })) &&
                                                    (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["index_name"]; })) &&
                                                    (!dbUniqueKeys.find(function (key) { return key["constraint_name"] === dbIndex["index_name"]; }));
                                            })
                                                .map(function (dbIndex) { return dbIndex["index_name"]; })
                                                .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                .map(function (dbIndexName) {
                                                var columnNames = dbIndices
                                                    .filter(function (dbIndex) { return dbIndex["table_name"] === tableSchema.name && dbIndex["index_name"] === dbIndexName; })
                                                    .map(function (dbIndex) { return dbIndex["column_name"]; });
                                                return new IndexSchema_2.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                            });
                                            return tableSchema;
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                PostgresQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM information_schema.tables WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                PostgresQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    return [4 /*yield*/, this.query("CREATE SCHEMA IF NOT EXISTS \"" + this.schemaName + "\"")];
                                case 1:
                                    _a.sent();
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    sql += table.columns
                                        .filter(function (column) { return column.isUnique; })
                                        .map(function (column) { return ", CONSTRAINT \"uk_" + table.name + "_" + column.name + "\" UNIQUE (\"" + column.name + "\")"; })
                                        .join(" ");
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") + ")";
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                PostgresQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM information_schema.columns WHERE table_catalog = '" + this.dbName + "' AND table_schema = '" + this.schemaName + "' AND table_name = '" + tableName + "' AND column_name = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                PostgresQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_3.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                PostgresQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                PostgresQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_3.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_4.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_4.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, sql, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_3.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_4.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(oldColumn.type !== newColumn.type ||
                                        oldColumn.name !== newColumn.name)) return [3 /*break*/, 5];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\"";
                                    if (oldColumn.type !== newColumn.type) {
                                        sql += " TYPE " + newColumn.type;
                                    }
                                    if (oldColumn.name !== newColumn.name) {
                                        sql += " RENAME TO " + newColumn.name;
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (!(oldColumn.isNullable !== newColumn.isNullable)) return [3 /*break*/, 7];
                                    sql = "ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\"";
                                    if (newColumn.isNullable) {
                                        sql += " DROP NOT NULL";
                                    }
                                    else {
                                        sql += " SET NOT NULL";
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7:
                                    if (!(oldColumn.isGenerated !== newColumn.isGenerated)) return [3 /*break*/, 13];
                                    if (!(!oldColumn.isGenerated && newColumn.type !== "uuid")) return [3 /*break*/, 10];
                                    return [4 /*yield*/, this.query("CREATE SEQUENCE \"" + tableSchema.name + "_id_seq\" OWNED BY \"" + tableSchema.name + "\".\"" + oldColumn.name + "\"")];
                                case 8:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\" SET DEFAULT nextval('\"" + tableSchema.name + "_id_seq\"')")];
                                case 9:
                                    _a.sent();
                                    return [3 /*break*/, 13];
                                case 10: return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ALTER COLUMN \"" + oldColumn.name + "\" DROP DEFAULT")];
                                case 11:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("DROP SEQUENCE \"" + tableSchema.name + "_id_seq\"")];
                                case 12:
                                    _a.sent();
                                    _a.label = 13;
                                case 13:
                                    if (!(oldColumn.comment !== newColumn.comment)) return [3 /*break*/, 15];
                                    return [4 /*yield*/, this.query("COMMENT ON COLUMN \"" + tableSchema.name + "\".\"" + oldColumn.name + "\" is '" + newColumn.comment + "'")];
                                case 14:
                                    _a.sent();
                                    _a.label = 15;
                                case 15:
                                    if (!(oldColumn.isUnique !== newColumn.isUnique)) return [3 /*break*/, 19];
                                    if (!(newColumn.isUnique === true)) return [3 /*break*/, 17];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" ADD CONSTRAINT \"uk_" + newColumn.name + "\" UNIQUE (\"" + newColumn.name + "\")")];
                                case 16:
                                    _a.sent();
                                    return [3 /*break*/, 19];
                                case 17:
                                    if (!(newColumn.isUnique === false)) return [3 /*break*/, 19];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + tableSchema.name + "\" DROP CONSTRAINT \"uk_" + newColumn.name + "\"")];
                                case 18:
                                    _a.sent();
                                    _a.label = 19;
                                case 19: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                PostgresQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                PostgresQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_3.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_4.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE \"" + tableName + "\" DROP \"" + columnName + "\"")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                PostgresQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                PostgresQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    primaryColumnNames = dbTable.primaryKeys.map(function (primaryKey) { return "\"" + primaryKey.columnName + "\""; });
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" DROP CONSTRAINT IF EXISTS \"" + dbTable.name + "_pkey\"")];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("DROP INDEX IF EXISTS \"" + dbTable.name + "_pkey\"")];
                                case 2:
                                    _a.sent();
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE \"" + dbTable.name + "\" ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                PostgresQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_3.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" ADD CONSTRAINT \"" + foreignKey.name + "\" " +
                                ("FOREIGN KEY (\"" + foreignKey.columnNames.join("\", \"") + "\") ") +
                                ("REFERENCES \"" + foreignKey.referencedTableName + "\"(\"" + foreignKey.referencedColumnNames.join("\", \"") + "\")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                PostgresQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_3.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE \"" + tableName + "\" DROP CONSTRAINT \"" + foreignKey.name + "\"";
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                PostgresQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                PostgresQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                PostgresQueryRunner.prototype.dropIndex = function (tableName, indexName, isGenerated) {
                    if (isGenerated === void 0) { isGenerated = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_3.QueryRunnerAlreadyReleasedError();
                                    if (!isGenerated) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER SEQUENCE \"" + tableName + "_id_seq\" OWNED BY NONE")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                PostgresQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            if (typeOptions.fixedLength) {
                                return "character(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                            else {
                                return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "jsonb":
                            return "jsonb";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                        case "uuid":
                            return "uuid";
                    }
                    throw new DataTypeNotSupportedByDriverError_3.DataTypeNotSupportedByDriverError(typeOptions.type, "Postgres");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                PostgresQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                PostgresQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(PostgresQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                PostgresQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                PostgresQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "\"" + column.name + "\"";
                    if (column.isGenerated === true && column.type !== "uuid")
                        c += " SERIAL";
                    if (!column.isGenerated || column.type === "uuid")
                        c += " " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isGenerated)
                        c += " PRIMARY KEY";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    if (column.isGenerated && column.type === "uuid" && !column.default)
                        c += " DEFAULT uuid_generate_v4()";
                    return c;
                };
                return PostgresQueryRunner;
            }());
            exports_51("PostgresQueryRunner", PostgresQueryRunner);
        }
    };
});
System.register("typeorm/driver/postgres/PostgresDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/postgres/PostgresQueryRunner", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_52, context_52) {
    "use strict";
    var __moduleName = context_52 && context_52.id;
    var ConnectionIsNotSetError_3, DriverPackageNotInstalledError_3, DriverUtils_3, ColumnTypes_3, PostgresQueryRunner_1, DriverOptionNotSetError_3, DataTransformationUtils_3, PlatformTools_4, PostgresDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_3_1) {
                ConnectionIsNotSetError_3 = ConnectionIsNotSetError_3_1;
            },
            function (DriverPackageNotInstalledError_3_1) {
                DriverPackageNotInstalledError_3 = DriverPackageNotInstalledError_3_1;
            },
            function (DriverUtils_3_1) {
                DriverUtils_3 = DriverUtils_3_1;
            },
            function (ColumnTypes_3_1) {
                ColumnTypes_3 = ColumnTypes_3_1;
            },
            function (PostgresQueryRunner_1_1) {
                PostgresQueryRunner_1 = PostgresQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_3_1) {
                DriverOptionNotSetError_3 = DriverOptionNotSetError_3_1;
            },
            function (DataTransformationUtils_3_1) {
                DataTransformationUtils_3 = DataTransformationUtils_3_1;
            },
            function (PlatformTools_4_1) {
                PlatformTools_4 = PlatformTools_4_1;
            }
        ],
        execute: function () {
            // todo(tests):
            // check connection with url
            // check if any of required option is not set exception to be thrown
            //
            /**
             * Organizes communication with PostgreSQL DBMS.
             */
            PostgresDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function PostgresDriver(connectionOptions, logger, postgres) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_3.DriverUtils.buildDriverOptions(connectionOptions);
                    this.logger = logger;
                    this.postgres = postgres;
                    this.schemaName = connectionOptions.schemaName || "public";
                    // validate options to make sure everything is set
                    if (!this.options.host)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_3.DriverOptionNotSetError("database");
                    // if postgres package instance was not set explicitly then try to load it
                    if (!postgres)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                PostgresDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        host: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        this.pool = new this.postgres.Pool(options);
                        return Promise.resolve();
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            _this.databaseConnection = {
                                id: 1,
                                connection: new _this.postgres.Client(options),
                                isTransactionActive: false
                            };
                            _this.databaseConnection.connection.connect(function (err) {
                                if (err) {
                                    fail(err);
                                }
                                else {
                                    _this.databaseConnection.connection.query("SET search_path TO '" + _this.schemaName + "', 'public';", function (err, result) {
                                        if (err) {
                                            _this.logger.logFailedQuery("SET search_path TO '" + _this.schemaName + "', 'public';");
                                            _this.logger.logQueryError(err);
                                            fail(err);
                                        }
                                        else {
                                            ok();
                                        }
                                    });
                                }
                            });
                        });
                    }
                };
                /**
                 * Closes connection with database.
                 */
                PostgresDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.end(); // todo: check if it can emit errors
                            _this.databaseConnection = undefined;
                        }
                        if (_this.pool) {
                            _this.databaseConnectionPool.forEach(function (dbConnection) {
                                if (dbConnection && dbConnection.releaseCallback) {
                                    dbConnection.releaseCallback();
                                }
                            });
                            _this.pool.end(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        ok();
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                PostgresDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new PostgresQueryRunner_1.PostgresQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                PostgresDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.postgres,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                PostgresDriver.prototype.preparePersistentValue = function (value, column) {
                    if (value === null || value === undefined)
                        return null;
                    switch (column.type) {
                        case ColumnTypes_3.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_3.ColumnTypes.DATE:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_3.ColumnTypes.TIME:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_3.ColumnTypes.DATETIME:
                            if (column.localTimezone) {
                                return DataTransformationUtils_3.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_3.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_3.ColumnTypes.JSON:
                        case ColumnTypes_3.ColumnTypes.JSONB:
                            return JSON.stringify(value);
                        case ColumnTypes_3.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_3.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                PostgresDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_3.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_3.ColumnTypes.DATETIME:
                            return DataTransformationUtils_3.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_3.ColumnTypes.DATE:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_3.ColumnTypes.TIME:
                            return DataTransformationUtils_3.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_3.ColumnTypes.JSON:
                        case ColumnTypes_3.ColumnTypes.JSONB:
                            // pg(pg-types) have done JSON.parse conversion
                            // https://github.com/brianc/node-pg-types/blob/ed2d0e36e33217b34530727a98d20b325389e73a/lib/textParsers.js#L170
                            return value;
                        case ColumnTypes_3.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_3.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                PostgresDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else {
                            builtParameters.push(value);
                        }
                        return "$" + builtParameters.length;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                PostgresDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                PostgresDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                PostgresDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                PostgresDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.connect(function (err, connection, release) {
                                if (err) {
                                    fail(err);
                                    return;
                                }
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                dbConnection.releaseCallback = function () {
                                    if (dbConnection) {
                                        _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                    }
                                    release();
                                    return Promise.resolve();
                                };
                                dbConnection.connection.query("SET search_path TO '" + _this.schemaName + "', 'public';", function (err) {
                                    if (err) {
                                        _this.logger.logFailedQuery("SET search_path TO '" + _this.schemaName + "', 'public';");
                                        _this.logger.logQueryError(err);
                                        fail(err);
                                    }
                                    else {
                                        ok(dbConnection);
                                    }
                                });
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_3.ConnectionIsNotSetError("postgres");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                PostgresDriver.prototype.loadDependencies = function () {
                    try {
                        this.postgres = PlatformTools_4.PlatformTools.load("pg");
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_3.DriverPackageNotInstalledError("Postgres", "pg");
                    }
                };
                return PostgresDriver;
            }());
            exports_52("PostgresDriver", PostgresDriver);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_53, context_53) {
    "use strict";
    var __moduleName = context_53 && context_53.id;
    var TransactionAlreadyStartedError_4, TransactionNotStartedError_4, DataTypeNotSupportedByDriverError_4, ColumnSchema_5, TableSchema_4, ForeignKeySchema_4, PrimaryKeySchema_4, IndexSchema_3, QueryRunnerAlreadyReleasedError_4, MysqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_4_1) {
                TransactionAlreadyStartedError_4 = TransactionAlreadyStartedError_4_1;
            },
            function (TransactionNotStartedError_4_1) {
                TransactionNotStartedError_4 = TransactionNotStartedError_4_1;
            },
            function (DataTypeNotSupportedByDriverError_4_1) {
                DataTypeNotSupportedByDriverError_4 = DataTypeNotSupportedByDriverError_4_1;
            },
            function (ColumnSchema_5_1) {
                ColumnSchema_5 = ColumnSchema_5_1;
            },
            function (TableSchema_4_1) {
                TableSchema_4 = TableSchema_4_1;
            },
            function (ForeignKeySchema_4_1) {
                ForeignKeySchema_4 = ForeignKeySchema_4_1;
            },
            function (PrimaryKeySchema_4_1) {
                PrimaryKeySchema_4 = PrimaryKeySchema_4_1;
            },
            function (IndexSchema_3_1) {
                IndexSchema_3 = IndexSchema_3_1;
            },
            function (QueryRunnerAlreadyReleasedError_4_1) {
                QueryRunnerAlreadyReleasedError_4 = QueryRunnerAlreadyReleasedError_4_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single mysql database connection.
             */
            MysqlQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                MysqlQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 * Be careful with using this method and avoid using it in production or migrations
                 * (because it can clear all your database).
                 */
                MysqlQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var disableForeignKeysCheckQuery, dropTablesQuery, enableForeignKeysCheckQuery, dropQueries, error_4;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 8, 10, 12]);
                                    disableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 0;";
                                    dropTablesQuery = "SELECT concat('DROP TABLE IF EXISTS ', table_name, ';') AS query FROM information_schema.tables WHERE table_schema = '" + this.dbName + "'";
                                    enableForeignKeysCheckQuery = "SET FOREIGN_KEY_CHECKS = 1;";
                                    return [4 /*yield*/, this.query(disableForeignKeysCheckQuery)];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(dropTablesQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (query) { return _this.query(query["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.query(enableForeignKeysCheckQuery)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 8:
                                    error_4 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 9:
                                    _a.sent();
                                    throw error_4;
                                case 10: return [4 /*yield*/, this.release()];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                MysqlQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_4.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("START TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                MysqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_4.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                MysqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_4.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                MysqlQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                MysqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.query(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            }
                            ok(result);
                        });
                    });
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                MysqlQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, parameters, sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    keys = Object.keys(keyValues);
                                    columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                                    values = keys.map(function (key) { return "?"; }).join(",");
                                    parameters = keys.map(function (key) { return keyValues[key]; });
                                    sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")";
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, generatedColumn ? result.insertId : undefined];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                MysqlQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, sql, conditionParams, updateParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions).join(" AND ");
                                    sql = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(sql, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                MysqlQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                MysqlQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                MysqlQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                MysqlQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, tablesSql, columnsSql, indicesSql, foreignKeysSql, _a, dbTables, dbColumns, dbIndices, dbForeignKeys;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    tablesSql = "SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME IN (" + tableNamesString + ")";
                                    columnsSql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "'";
                                    indicesSql = "SELECT * FROM INFORMATION_SCHEMA.STATISTICS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND INDEX_NAME != 'PRIMARY'";
                                    foreignKeysSql = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_SCHEMA = '" + this.dbName + "' AND REFERENCED_COLUMN_NAME IS NOT NULL";
                                    return [4 /*yield*/, Promise.all([
                                            this.query(tablesSql),
                                            this.query(columnsSql),
                                            this.query(indicesSql),
                                            this.query(foreignKeysSql)
                                        ])];
                                case 1:
                                    _a = _b.sent(), dbTables = _a[0], dbColumns = _a[1], dbIndices = _a[2], dbForeignKeys = _a[3];
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema, primaryKeys;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        tableSchema = new TableSchema_4.TableSchema(dbTable["TABLE_NAME"]);
                                                        return [4 /*yield*/, this.query("SHOW INDEX FROM `" + dbTable["TABLE_NAME"] + "` WHERE Key_name = 'PRIMARY'")];
                                                    case 1:
                                                        primaryKeys = _a.sent();
                                                        // create column schemas from the loaded columns
                                                        tableSchema.columns = dbColumns
                                                            .filter(function (dbColumn) { return dbColumn["TABLE_NAME"] === tableSchema.name; })
                                                            .map(function (dbColumn) {
                                                            var columnSchema = new ColumnSchema_5.ColumnSchema();
                                                            columnSchema.name = dbColumn["COLUMN_NAME"];
                                                            columnSchema.type = dbColumn["COLUMN_TYPE"].toLowerCase();
                                                            columnSchema.default = dbColumn["COLUMN_DEFAULT"] !== null && dbColumn["COLUMN_DEFAULT"] !== undefined ? dbColumn["COLUMN_DEFAULT"] : undefined;
                                                            columnSchema.isNullable = dbColumn["IS_NULLABLE"] === "YES";
                                                            columnSchema.isPrimary = dbColumn["COLUMN_KEY"].indexOf("PRI") !== -1;
                                                            columnSchema.isUnique = dbColumn["COLUMN_KEY"].indexOf("UNI") !== -1;
                                                            columnSchema.isGenerated = dbColumn["EXTRA"].indexOf("auto_increment") !== -1;
                                                            columnSchema.comment = dbColumn["COLUMN_COMMENT"];
                                                            return columnSchema;
                                                        });
                                                        // create primary keys
                                                        tableSchema.primaryKeys = primaryKeys.map(function (primaryKey) {
                                                            return new PrimaryKeySchema_4.PrimaryKeySchema(primaryKey["Key_name"], primaryKey["Column_name"]);
                                                        });
                                                        // create foreign key schemas from the loaded indices
                                                        tableSchema.foreignKeys = dbForeignKeys
                                                            .filter(function (dbForeignKey) { return dbForeignKey["TABLE_NAME"] === tableSchema.name; })
                                                            .map(function (dbForeignKey) { return new ForeignKeySchema_4.ForeignKeySchema(dbForeignKey["CONSTRAINT_NAME"], [], [], "", ""); }); // todo: fix missing params
                                                        // create index schemas from the loaded indices
                                                        tableSchema.indices = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["TABLE_NAME"] === tableSchema.name &&
                                                                (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["INDEX_NAME"]; })) &&
                                                                (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["INDEX_NAME"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["INDEX_NAME"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) {
                                                            var currentDbIndices = dbIndices.filter(function (dbIndex) { return dbIndex["TABLE_NAME"] === tableSchema.name && dbIndex["INDEX_NAME"] === dbIndexName; });
                                                            var columnNames = currentDbIndices.map(function (dbIndex) { return dbIndex["COLUMN_NAME"]; });
                                                            // find a special index - unique index and
                                                            if (currentDbIndices.length === 1 && currentDbIndices[0]["NON_UNIQUE"] === 0) {
                                                                var column = tableSchema.columns.find(function (column) { return column.name === currentDbIndices[0]["INDEX_NAME"] && column.name === currentDbIndices[0]["COLUMN_NAME"]; });
                                                                if (column) {
                                                                    column.isUnique = true;
                                                                    return;
                                                                }
                                                            }
                                                            return new IndexSchema_3.IndexSchema(dbTable["TABLE_NAME"], dbIndexName, columnNames, false /* todo: uniqueness */);
                                                        })
                                                            .filter(function (index) { return !!index; }); // remove empty returns
                                                        return [2 /*return*/, tableSchema];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                MysqlQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table schema and column schemas inside it.
                 */
                MysqlQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column, false); }).join(", ");
                                    sql = "CREATE TABLE `" + table.name + "` (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "`" + column.name + "`"; }).join(", ") + ")";
                                    sql += ") ENGINE=InnoDB;"; // todo: remove engine from here
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                MysqlQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = '" + this.dbName + "' AND TABLE_NAME = '" + tableName + "' AND COLUMN_NAME = '" + columnName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                MysqlQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            sql = "ALTER TABLE `" + tableName + "` ADD " + this.buildCreateColumnSql(column, false);
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                MysqlQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    queries = columns.map(function (column) { return _this.addColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(queries)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                MysqlQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_4.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_4.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_5.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    if (!(newColumn.isUnique === false && oldColumn.isUnique === true)) return [3 /*break*/, 5];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + tableSchema.name + "` DROP INDEX `" + oldColumn.name + "`")];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/, this.query("ALTER TABLE `" + tableSchema.name + "` CHANGE `" + oldColumn.name + "` " + this.buildCreateColumnSql(newColumn, oldColumn.isPrimary))];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MysqlQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    updatePromises = changedColumns.map(function (changedColumn) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            return [2 /*return*/, this.changeColumn(tableSchema, changedColumn.oldColumn, changedColumn.newColumn)];
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                MysqlQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnName;
                        return __generator(this, function (_a) {
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnName = columnSchemaOrName instanceof ColumnSchema_5.ColumnSchema ? columnSchemaOrName.name : columnSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE `" + tableName + "` DROP `" + columnName + "`")];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                MysqlQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    dropPromises = columnSchemasOrNames.map(function (column) { return _this.dropColumn(tableSchemaOrName, column); });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                MysqlQueryRunner.prototype.updatePrimaryKeys = function (tableSchema) {
                    return __awaiter(this, void 0, void 0, function () {
                        var primaryColumnNames;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    if (!!tableSchema.hasGeneratedColumn) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + tableSchema.name + "` DROP PRIMARY KEY")];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    primaryColumnNames = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; }).map(function (column) { return "`" + column.name + "`"; });
                                    if (!(primaryColumnNames.length > 0)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.query("ALTER TABLE `" + tableSchema.name + "` ADD PRIMARY KEY (" + primaryColumnNames.join(", ") + ")")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                MysqlQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, columnNames, referencedColumnNames, sql;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            columnNames = foreignKey.columnNames.map(function (column) { return "`" + column + "`"; }).join(", ");
                            referencedColumnNames = foreignKey.referencedColumnNames.map(function (column) { return "`" + column + "`"; }).join(",");
                            sql = "ALTER TABLE `" + tableName + "` ADD CONSTRAINT `" + foreignKey.name + "` " +
                                ("FOREIGN KEY (" + columnNames + ") ") +
                                ("REFERENCES `" + foreignKey.referencedTableName + "`(" + referencedColumnNames + ")");
                            if (foreignKey.onDelete)
                                sql += " ON DELETE " + foreignKey.onDelete;
                            return [2 /*return*/, this.query(sql)];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                MysqlQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.createForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                            tableName = tableSchemaOrName instanceof TableSchema_4.TableSchema ? tableSchemaOrName.name : tableSchemaOrName;
                            return [2 /*return*/, this.query("ALTER TABLE `" + tableName + "` DROP FOREIGN KEY `" + foreignKey.name + "`")];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                MysqlQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    promises = foreignKeys.map(function (foreignKey) { return _this.dropForeignKey(tableSchemaOrName, foreignKey); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                MysqlQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columns, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    columns = index.columnNames.map(function (columnName) { return "`" + columnName + "`"; }).join(", ");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX `" + index.name + "` ON `" + tableName + "`(" + columns + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                MysqlQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_4.QueryRunnerAlreadyReleasedError();
                                    sql = "ALTER TABLE `" + tableName + "` DROP INDEX `" + indexName + "`";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                MysqlQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            if (typeOptions.fixedLength) {
                                return "char(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                            else {
                                return "varchar(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                            }
                        case "text":
                            return "text";
                        case "boolean":
                            return "tinyint(1)";
                        case "integer":
                        case "int":
                            return "int(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "smallint":
                            return "smallint(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "bigint":
                            return "bigint(" + (typeOptions.length ? typeOptions.length : 11) + ")";
                        case "float":
                            return "float";
                        case "double":
                        case "number":
                            return "double";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            return "time";
                        case "datetime":
                            return "datetime";
                        case "json":
                            return "text";
                        case "simple_array":
                            return typeOptions.length ? "varchar(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_4.DataTypeNotSupportedByDriverError(typeOptions.type, "MySQL/MariaDB");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                MysqlQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                MysqlQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("TRUNCATE TABLE " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(MysqlQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                MysqlQueryRunner.prototype.parametrize = function (objectLiteral) {
                    var _this = this;
                    return Object.keys(objectLiteral).map(function (key) { return _this.driver.escapeColumnName(key) + "=?"; });
                };
                /**
                 * Builds a query for create column.
                 */
                MysqlQueryRunner.prototype.buildCreateColumnSql = function (column, skipPrimary) {
                    var c = "`" + column.name + "` " + column.type;
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated && column.isPrimary && !skipPrimary)
                        c += " PRIMARY KEY";
                    if (column.isGenerated === true)
                        c += " AUTO_INCREMENT";
                    if (column.comment)
                        c += " COMMENT '" + column.comment + "'";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                return MysqlQueryRunner;
            }());
            exports_53("MysqlQueryRunner", MysqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/mysql/MysqlDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/DriverUtils", "typeorm/driver/mysql/MysqlQueryRunner", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_54, context_54) {
    "use strict";
    var __moduleName = context_54 && context_54.id;
    var ConnectionIsNotSetError_4, DriverPackageNotInstalledError_4, DriverUtils_4, MysqlQueryRunner_1, ColumnTypes_4, DriverOptionNotSetError_4, DataTransformationUtils_4, PlatformTools_5, MysqlDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_4_1) {
                ConnectionIsNotSetError_4 = ConnectionIsNotSetError_4_1;
            },
            function (DriverPackageNotInstalledError_4_1) {
                DriverPackageNotInstalledError_4 = DriverPackageNotInstalledError_4_1;
            },
            function (DriverUtils_4_1) {
                DriverUtils_4 = DriverUtils_4_1;
            },
            function (MysqlQueryRunner_1_1) {
                MysqlQueryRunner_1 = MysqlQueryRunner_1_1;
            },
            function (ColumnTypes_4_1) {
                ColumnTypes_4 = ColumnTypes_4_1;
            },
            function (DriverOptionNotSetError_4_1) {
                DriverOptionNotSetError_4 = DriverOptionNotSetError_4_1;
            },
            function (DataTransformationUtils_4_1) {
                DataTransformationUtils_4 = DataTransformationUtils_4_1;
            },
            function (PlatformTools_5_1) {
                PlatformTools_5 = PlatformTools_5_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with MySQL DBMS.
             */
            MysqlDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MysqlDriver(options, logger, mysql) {
                    /**
                     * Pool of database connections.
                     */
                    this.databaseConnectionPool = [];
                    this.options = DriverUtils_4.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    this.mysql = mysql;
                    // validate options to make sure everything is set
                    if (!(this.options.host || (this.options.extra && this.options.extra.socketPath)))
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("socketPath and host");
                    if (!this.options.username)
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_4.DriverOptionNotSetError("database");
                    // if mysql package instance was not set explicitly then try to load it
                    if (!mysql)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                MysqlDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        host: this.options.host,
                        user: this.options.username,
                        password: this.options.password,
                        database: this.options.database,
                        port: this.options.port
                    }, this.options.extra || {});
                    // pooling is enabled either when its set explicitly to true,
                    // either when its not defined at all (e.g. enabled by default)
                    if (this.options.usePool === undefined || this.options.usePool === true) {
                        this.pool = this.mysql.createPool(options);
                        return Promise.resolve();
                    }
                    else {
                        return new Promise(function (ok, fail) {
                            var connection = _this.mysql.createConnection(options);
                            _this.databaseConnection = {
                                id: 1,
                                connection: connection,
                                isTransactionActive: false
                            };
                            _this.databaseConnection.connection.connect(function (err) { return err ? fail(err) : ok(); });
                        });
                    }
                };
                /**
                 * Closes connection with the database.
                 */
                MysqlDriver.prototype.disconnect = function () {
                    var _this = this;
                    if (!this.databaseConnection && !this.pool)
                        throw new ConnectionIsNotSetError_4.ConnectionIsNotSetError("mysql");
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        // if pooling is used, then disconnect from it
                        if (_this.pool) {
                            _this.pool.end(handler);
                            _this.pool = undefined;
                            _this.databaseConnectionPool = [];
                        }
                        // if single connection is opened, then close it
                        if (_this.databaseConnection) {
                            _this.databaseConnection.connection.end(handler);
                            _this.databaseConnection = undefined;
                        }
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                MysqlDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection && !this.pool)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_4.ConnectionIsNotSetError("mysql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new MysqlQueryRunner_1.MysqlQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                MysqlDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.mysql,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined,
                        pool: this.pool
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                MysqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return "?";
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                MysqlDriver.prototype.escapeColumnName = function (columnName) {
                    return "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                MysqlDriver.prototype.escapeAliasName = function (aliasName) {
                    return "`" + aliasName + "`";
                };
                /**
                 * Escapes a table name.
                 */
                MysqlDriver.prototype.escapeTableName = function (tableName) {
                    return "`" + tableName + "`";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                MysqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_4.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_4.ColumnTypes.DATE:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_4.ColumnTypes.TIME:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_4.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_4.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_4.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_4.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_4.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_4.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                MysqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_4.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_4.ColumnTypes.DATETIME:
                            return DataTransformationUtils_4.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_4.ColumnTypes.DATE:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_4.ColumnTypes.TIME:
                            return DataTransformationUtils_4.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_4.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_4.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_4.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                MysqlDriver.prototype.retrieveDatabaseConnection = function () {
                    var _this = this;
                    if (this.pool) {
                        return new Promise(function (ok, fail) {
                            _this.pool.getConnection(function (err, connection) {
                                if (err)
                                    return fail(err);
                                var dbConnection = _this.databaseConnectionPool.find(function (dbConnection) { return dbConnection.connection === connection; });
                                if (!dbConnection) {
                                    dbConnection = {
                                        id: _this.databaseConnectionPool.length,
                                        connection: connection,
                                        isTransactionActive: false
                                    };
                                    dbConnection.releaseCallback = function () {
                                        if (_this.pool && dbConnection) {
                                            connection.release();
                                            _this.databaseConnectionPool.splice(_this.databaseConnectionPool.indexOf(dbConnection), 1);
                                        }
                                        return Promise.resolve();
                                    };
                                    _this.databaseConnectionPool.push(dbConnection);
                                }
                                ok(dbConnection);
                            });
                        });
                    }
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_4.ConnectionIsNotSetError("mysql");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                MysqlDriver.prototype.loadDependencies = function () {
                    try {
                        this.mysql = PlatformTools_5.PlatformTools.load("mysql"); // try to load first supported package
                    }
                    catch (e) {
                        try {
                            this.mysql = PlatformTools_5.PlatformTools.load("mysql2"); // try to load second supported package
                        }
                        catch (e) {
                            throw new DriverPackageNotInstalledError_4.DriverPackageNotInstalledError("Mysql", "mysql");
                        }
                    }
                };
                return MysqlDriver;
            }());
            exports_54("MysqlDriver", MysqlDriver);
        }
    };
});
System.register("typeorm/query-builder/error/LockNotSupportedOnGivenDriverError", [], function (exports_55, context_55) {
    "use strict";
    var __moduleName = context_55 && context_55.id;
    var LockNotSupportedOnGivenDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when selected sql driver does not supports locking.
             */
            LockNotSupportedOnGivenDriverError = (function (_super) {
                __extends(LockNotSupportedOnGivenDriverError, _super);
                function LockNotSupportedOnGivenDriverError() {
                    var _this = _super.call(this) || this;
                    _this.name = "LockNotSupportedOnGivenDriverError";
                    Object.setPrototypeOf(_this, LockNotSupportedOnGivenDriverError.prototype);
                    _this.message = "Locking not supported on giver driver.";
                    return _this;
                }
                return LockNotSupportedOnGivenDriverError;
            }(Error));
            exports_55("LockNotSupportedOnGivenDriverError", LockNotSupportedOnGivenDriverError);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdLoader", ["typeorm/query-builder/QueryBuilder"], function (exports_56, context_56) {
    "use strict";
    var __moduleName = context_56 && context_56.id;
    var QueryBuilder_2, RelationIdLoader;
    return {
        setters: [
            function (QueryBuilder_2_1) {
                QueryBuilder_2 = QueryBuilder_2_1;
            }
        ],
        execute: function () {
            RelationIdLoader = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdLoader(connection, queryRunnerProvider, relationIdAttributes) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    this.relationIdAttributes = relationIdAttributes;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationIdLoader.prototype.load = function (rawEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            promises = this.relationIdAttributes.map(function (relationIdAttr) { return __awaiter(_this, void 0, void 0, function () {
                                var results, relation, joinColumns_1, table, tableName, tableAlias_1, parameters_1, condition, qb_1, _a, relation, joinColumns_2, inverseJoinColumns, junctionAlias_1, inverseSideTableName, inverseSideTableAlias_1, junctionTableName, mappedColumns, parameters_2, joinColumnConditions, inverseJoinColumnCondition_1, condition, qb_2, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            if (!(relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner)) return [3 /*break*/, 1];
                                            // example: Post and Tag
                                            // loadRelationIdAndMap("post.tagId", "post.tag")
                                            // we expect it to load id of tag
                                            if (relationIdAttr.queryBuilderFactory)
                                                throw new Error("Additional condition can not be used with ManyToOne or OneToOne owner relations.");
                                            results = rawEntities.map(function (rawEntity) {
                                                var result = {};
                                                relationIdAttr.relation.joinColumns.forEach(function (joinColumn) {
                                                    result[joinColumn.databaseName] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.databaseName];
                                                });
                                                relationIdAttr.relation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {
                                                    result[primaryColumn.databaseName] = rawEntity[relationIdAttr.parentAlias + "_" + primaryColumn.databaseName];
                                                });
                                                return result;
                                            });
                                            return [2 /*return*/, {
                                                    relationIdAttribute: relationIdAttr,
                                                    results: results
                                                }];
                                        case 1:
                                            if (!(relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner)) return [3 /*break*/, 3];
                                            relation = relationIdAttr.relation;
                                            joinColumns_1 = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;
                                            table = relation.inverseEntityMetadata.target;
                                            tableName = relation.inverseEntityMetadata.tableName;
                                            tableAlias_1 = relationIdAttr.alias || tableName;
                                            parameters_1 = {};
                                            condition = rawEntities.map(function (rawEntity, index) {
                                                return joinColumns_1.map(function (joinColumn) {
                                                    var parameterName = joinColumn.databaseName + index;
                                                    parameters_1[parameterName] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.referencedColumn.databaseName];
                                                    return tableAlias_1 + "." + joinColumn.propertyPath + " = :" + parameterName;
                                                }).join(" AND ");
                                            }).map(function (condition) { return "(" + condition + ")"; })
                                                .join(" OR ");
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (!condition)
                                                return [2 /*return*/, { relationIdAttribute: relationIdAttr, results: [] }];
                                            qb_1 = new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider);
                                            joinColumns_1.forEach(function (joinColumn) {
                                                qb_1.addSelect(tableAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName);
                                            });
                                            relation.inverseRelation.entityMetadata.primaryColumns.forEach(function (primaryColumn) {
                                                qb_1.addSelect(tableAlias_1 + "." + primaryColumn.propertyPath, primaryColumn.databaseName);
                                            });
                                            qb_1.from(table, tableAlias_1)
                                                .where("(" + condition + ")") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect
                                                .setParameters(parameters_1);
                                            // apply condition (custom query builder factory)
                                            if (relationIdAttr.queryBuilderFactory)
                                                relationIdAttr.queryBuilderFactory(qb_1);
                                            _a = {
                                                relationIdAttribute: relationIdAttr
                                            };
                                            return [4 /*yield*/, qb_1.getRawMany()];
                                        case 2: return [2 /*return*/, (_a.results = _c.sent(),
                                                _a)];
                                        case 3:
                                            relation = relationIdAttr.relation;
                                            joinColumns_2 = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                                            inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                            junctionAlias_1 = relationIdAttr.junctionAlias;
                                            inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;
                                            inverseSideTableAlias_1 = relationIdAttr.alias || inverseSideTableName;
                                            junctionTableName = relation.junctionEntityMetadata.tableName;
                                            mappedColumns = rawEntities.map(function (rawEntity) {
                                                return joinColumns_2.reduce(function (map, joinColumn) {
                                                    map[joinColumn.propertyPath] = rawEntity[relationIdAttr.parentAlias + "_" + joinColumn.referencedColumn.databaseName];
                                                    return map;
                                                }, {});
                                            });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (mappedColumns.length === 0)
                                                return [2 /*return*/, { relationIdAttribute: relationIdAttr, results: [] }];
                                            parameters_2 = {};
                                            joinColumnConditions = mappedColumns.map(function (mappedColumn, index) {
                                                return Object.keys(mappedColumn).map(function (key) {
                                                    var parameterName = key + index;
                                                    parameters_2[parameterName] = mappedColumn[key];
                                                    return junctionAlias_1 + "." + key + " = :" + parameterName;
                                                }).join(" AND ");
                                            });
                                            inverseJoinColumnCondition_1 = inverseJoinColumns.map(function (joinColumn) {
                                                return junctionAlias_1 + "." + joinColumn.propertyPath + " = " + inverseSideTableAlias_1 + "." + joinColumn.referencedColumn.propertyPath;
                                            }).join(" AND ");
                                            condition = joinColumnConditions.map(function (condition) {
                                                return "(" + condition + " AND " + inverseJoinColumnCondition_1 + ")";
                                            }).join(" OR ");
                                            qb_2 = new QueryBuilder_2.QueryBuilder(this.connection, this.queryRunnerProvider);
                                            inverseJoinColumns.forEach(function (joinColumn) {
                                                qb_2.addSelect(junctionAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName)
                                                    .addOrderBy(junctionAlias_1 + "." + joinColumn.propertyPath);
                                            });
                                            joinColumns_2.forEach(function (joinColumn) {
                                                qb_2.addSelect(junctionAlias_1 + "." + joinColumn.propertyPath, joinColumn.databaseName)
                                                    .addOrderBy(junctionAlias_1 + "." + joinColumn.propertyPath);
                                            });
                                            qb_2.fromTable(inverseSideTableName, inverseSideTableAlias_1)
                                                .innerJoin(junctionTableName, junctionAlias_1, condition)
                                                .setParameters(parameters_2);
                                            // apply condition (custom query builder factory)
                                            if (relationIdAttr.queryBuilderFactory)
                                                relationIdAttr.queryBuilderFactory(qb_2);
                                            _b = {
                                                relationIdAttribute: relationIdAttr
                                            };
                                            return [4 /*yield*/, qb_2.getRawMany()];
                                        case 4: return [2 /*return*/, (_b.results = _c.sent(),
                                                _b)];
                                    }
                                });
                            }); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                return RelationIdLoader;
            }());
            exports_56("RelationIdLoader", RelationIdLoader);
        }
    };
});
System.register("typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer", ["typeorm/query-builder/relation-id/RelationIdAttribute"], function (exports_57, context_57) {
    "use strict";
    var __moduleName = context_57 && context_57.id;
    var RelationIdAttribute_2, RelationIdMetadataToAttributeTransformer;
    return {
        setters: [
            function (RelationIdAttribute_2_1) {
                RelationIdAttribute_2 = RelationIdAttribute_2_1;
            }
        ],
        execute: function () {
            RelationIdMetadataToAttributeTransformer = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationIdMetadataToAttributeTransformer(expressionMap) {
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationIdMetadataToAttributeTransformer.prototype.transform = function () {
                    // by example:
                    // post has relation id:
                    // @RelationId(post => post.categories) categoryIds
                    // category has relation id
                    // @RelationId(category => category.images) imageIds
                    // we load post and join category
                    // we expect post.categoryIds and post.category.imageIds to have relation ids
                    var _this = this;
                    // first create relation id attributes for all relation id metadatas of the main selected object (post from example)
                    if (this.expressionMap.mainAlias) {
                        this.expressionMap.mainAlias.metadata.relationIds.forEach(function (relationId) {
                            var attribute = _this.metadataToAttribute(_this.expressionMap.mainAlias.name, relationId);
                            _this.expressionMap.relationIdAttributes.push(attribute);
                        });
                    }
                    // second create relation id attributes for all relation id metadatas of all joined objects (category from example)
                    this.expressionMap.joinAttributes.forEach(function (join) {
                        // ensure this join has a metadata, because relation id can only work for real orm entities
                        if (!join.metadata || join.metadata.isJunction)
                            return;
                        join.metadata.relationIds.forEach(function (relationId) {
                            var attribute = _this.metadataToAttribute(join.alias.name, relationId);
                            _this.expressionMap.relationIdAttributes.push(attribute);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                RelationIdMetadataToAttributeTransformer.prototype.metadataToAttribute = function (parentAliasName, relationId) {
                    return new RelationIdAttribute_2.RelationIdAttribute(this.expressionMap, {
                        relationName: parentAliasName + "." + relationId.relation.propertyName,
                        mapToProperty: parentAliasName + "." + relationId.propertyName,
                        alias: relationId.alias,
                        queryBuilderFactory: relationId.queryBuilderFactory
                    });
                };
                return RelationIdMetadataToAttributeTransformer;
            }());
            exports_57("RelationIdMetadataToAttributeTransformer", RelationIdMetadataToAttributeTransformer);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountLoader", ["typeorm/query-builder/QueryBuilder"], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    var QueryBuilder_3, RelationCountLoader;
    return {
        setters: [
            function (QueryBuilder_3_1) {
                QueryBuilder_3 = QueryBuilder_3_1;
            }
        ],
        execute: function () {
            RelationCountLoader = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountLoader(connection, queryRunnerProvider, relationCountAttributes) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    this.relationCountAttributes = relationCountAttributes;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationCountLoader.prototype.load = function (rawEntities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            promises = this.relationCountAttributes.map(function (relationCountAttr) { return __awaiter(_this, void 0, void 0, function () {
                                var relation, inverseRelation, referenceColumnName_1, inverseSideTable, inverseSideTableName, inverseSideTableAlias, inverseSidePropertyName, referenceColumnValues, qb, _a, joinTableColumnName_1, inverseJoinColumnName, firstJunctionColumn, secondJunctionColumn, referenceColumnValues, junctionAlias, inverseSideTableName, inverseSideTableAlias, junctionTableName, condition, qb, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            if (!relationCountAttr.relation.isOneToMany) return [3 /*break*/, 2];
                                            relation = relationCountAttr.relation;
                                            inverseRelation = relation.inverseRelation;
                                            referenceColumnName_1 = inverseRelation.joinColumns[0].referencedColumn.propertyName;
                                            inverseSideTable = relation.inverseEntityMetadata.target;
                                            inverseSideTableName = relation.inverseEntityMetadata.tableName;
                                            inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
                                            inverseSidePropertyName = inverseRelation.propertyName;
                                            referenceColumnValues = rawEntities
                                                .map(function (rawEntity) { return rawEntity[relationCountAttr.parentAlias + "_" + referenceColumnName_1]; })
                                                .filter(function (value) { return !!value; });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (referenceColumnValues.length === 0)
                                                return [2 /*return*/, { relationCountAttribute: relationCountAttr, results: [] }];
                                            qb = new QueryBuilder_3.QueryBuilder(this.connection, this.queryRunnerProvider);
                                            qb.select(inverseSideTableAlias + "." + inverseSidePropertyName, "parentId")
                                                .addSelect("COUNT(" + qb.escapeAlias(inverseSideTableAlias) + "." + qb.escapeColumn(referenceColumnName_1) + ")", "cnt")
                                                .from(inverseSideTable, inverseSideTableAlias)
                                                .where(inverseSideTableAlias + "." + inverseSidePropertyName + " IN (:ids)")
                                                .addGroupBy(inverseSideTableAlias + "." + inverseSidePropertyName)
                                                .setParameter("ids", referenceColumnValues);
                                            // apply condition (custom query builder factory)
                                            if (relationCountAttr.queryBuilderFactory)
                                                relationCountAttr.queryBuilderFactory(qb);
                                            _a = {
                                                relationCountAttribute: relationCountAttr
                                            };
                                            return [4 /*yield*/, qb.getRawMany()];
                                        case 1: return [2 /*return*/, (_a.results = _c.sent(),
                                                _a)];
                                        case 2:
                                            inverseJoinColumnName = void 0;
                                            firstJunctionColumn = void 0;
                                            secondJunctionColumn = void 0;
                                            if (relationCountAttr.relation.isOwning) {
                                                joinTableColumnName_1 = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;
                                                inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;
                                                firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                                                secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                                            }
                                            else {
                                                joinTableColumnName_1 = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;
                                                inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;
                                                firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];
                                                secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];
                                            }
                                            referenceColumnValues = rawEntities
                                                .map(function (rawEntity) { return rawEntity[relationCountAttr.parentAlias + "_" + joinTableColumnName_1]; })
                                                .filter(function (value) { return value; });
                                            // ensure we won't perform redundant queries for joined data which was not found in selection
                                            // example: if post.category was not found in db then no need to execute query for category.imageIds
                                            if (referenceColumnValues.length === 0)
                                                return [2 /*return*/, { relationCountAttribute: relationCountAttr, results: [] }];
                                            junctionAlias = relationCountAttr.junctionAlias;
                                            inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;
                                            inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;
                                            junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;
                                            condition = junctionAlias + "." + firstJunctionColumn.propertyName + " IN (" + referenceColumnValues + ")" +
                                                " AND " + junctionAlias + "." + secondJunctionColumn.propertyName + " = " + inverseSideTableAlias + "." + inverseJoinColumnName;
                                            qb = new QueryBuilder_3.QueryBuilder(this.connection, this.queryRunnerProvider);
                                            qb.select(junctionAlias + "." + firstJunctionColumn.propertyName, "parentId")
                                                .addSelect("COUNT(" + qb.escapeAlias(inverseSideTableAlias) + "." + qb.escapeColumn(inverseJoinColumnName) + ")", "cnt")
                                                .fromTable(inverseSideTableName, inverseSideTableAlias)
                                                .innerJoin(junctionTableName, junctionAlias, condition)
                                                .addGroupBy(junctionAlias + "." + firstJunctionColumn.propertyName);
                                            // apply condition (custom query builder factory)
                                            if (relationCountAttr.queryBuilderFactory)
                                                relationCountAttr.queryBuilderFactory(qb);
                                            _b = {
                                                relationCountAttribute: relationCountAttr
                                            };
                                            return [4 /*yield*/, qb.getRawMany()];
                                        case 3: return [2 /*return*/, (_b.results = _c.sent(),
                                                _b)];
                                    }
                                });
                            }); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                return RelationCountLoader;
            }());
            exports_58("RelationCountLoader", RelationCountLoader);
        }
    };
});
System.register("typeorm/metadata-args/RelationCountMetadataArgs", [], function (exports_59, context_59) {
    "use strict";
    var __moduleName = context_59 && context_59.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationCountMetadata", [], function (exports_60, context_60) {
    "use strict";
    var __moduleName = context_60 && context_60.id;
    var RelationCountMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's relation count.
             */
            RelationCountMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationCountMetadata(options) {
                    this.entityMetadata = options.entityMetadata;
                    this.target = options.args.target;
                    this.propertyName = options.args.propertyName;
                    this.relationNameOrFactory = options.args.relation;
                    this.alias = options.args.alias;
                    this.queryBuilderFactory = options.args.queryBuilderFactory;
                }
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation count metadata properties.
                 * This builder method should be used only after entity metadata, its properties map and all relations are build.
                 */
                RelationCountMetadata.prototype.build = function () {
                    var propertyPath = this.relationNameOrFactory instanceof Function ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
                    var relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
                    if (!relation)
                        throw new Error("Cannot find relation " + propertyPath + ". Wrong relation specified for @RelationCount decorator.");
                    this.relation = relation;
                };
                return RelationCountMetadata;
            }());
            exports_60("RelationCountMetadata", RelationCountMetadata);
        }
    };
});
System.register("typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer", ["typeorm/query-builder/relation-count/RelationCountAttribute"], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    var RelationCountAttribute_2, RelationCountMetadataToAttributeTransformer;
    return {
        setters: [
            function (RelationCountAttribute_2_1) {
                RelationCountAttribute_2 = RelationCountAttribute_2_1;
            }
        ],
        execute: function () {
            RelationCountMetadataToAttributeTransformer = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationCountMetadataToAttributeTransformer(expressionMap) {
                    this.expressionMap = expressionMap;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                RelationCountMetadataToAttributeTransformer.prototype.transform = function () {
                    // by example:
                    // post has relation count:
                    // @RelationCount(post => post.categories) categoryCount
                    // category has relation count
                    // @RelationCount(category => category.images) imageCount
                    // we load post and join category
                    // we expect post.categoryCount and post.category.imageCount to have relation counts
                    var _this = this;
                    // first create relation count attributes for all relation count metadatas of the main selected object (post from example)
                    if (this.expressionMap.mainAlias) {
                        this.expressionMap.mainAlias.metadata.relationCounts.forEach(function (relationCount) {
                            var attribute = _this.metadataToAttribute(_this.expressionMap.mainAlias.name, relationCount);
                            _this.expressionMap.relationCountAttributes.push(attribute);
                        });
                    }
                    // second create relation count attributes for all relation count metadatas of all joined objects (category from example)
                    this.expressionMap.joinAttributes.forEach(function (join) {
                        // ensure this join has a metadata, because relation count can only work for real orm entities
                        if (!join.metadata || join.metadata.isJunction)
                            return;
                        join.metadata.relationCounts.forEach(function (relationCount) {
                            var attribute = _this.metadataToAttribute(join.alias.name, relationCount);
                            _this.expressionMap.relationCountAttributes.push(attribute);
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                RelationCountMetadataToAttributeTransformer.prototype.metadataToAttribute = function (parentAliasName, relationCount) {
                    return new RelationCountAttribute_2.RelationCountAttribute(this.expressionMap, {
                        relationName: parentAliasName + "." + relationCount.relation.propertyName,
                        mapToProperty: parentAliasName + "." + relationCount.propertyName,
                        alias: relationCount.alias,
                        queryBuilderFactory: relationCount.queryBuilderFactory
                    });
                };
                return RelationCountMetadataToAttributeTransformer;
            }());
            exports_61("RelationCountMetadataToAttributeTransformer", RelationCountMetadataToAttributeTransformer);
        }
    };
});
System.register("typeorm/query-builder/QueryBuilder", ["typeorm/driver/oracle/OracleDriver", "typeorm/query-builder/transformer/RawSqlResultsToEntityTransformer", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/query-runner/QueryRunnerProvider", "typeorm/query-builder/error/PessimisticLockTransactionRequiredError", "typeorm/query-builder/error/NoVersionOrUpdateDateColumnError", "typeorm/query-builder/error/OptimisticLockVersionMismatchError", "typeorm/query-builder/error/OptimisticLockCanNotBeUsedError", "typeorm/driver/postgres/PostgresDriver", "typeorm/driver/mysql/MysqlDriver", "typeorm/query-builder/error/LockNotSupportedOnGivenDriverError", "typeorm/query-builder/JoinAttribute", "typeorm/query-builder/relation-id/RelationIdAttribute", "typeorm/query-builder/relation-count/RelationCountAttribute", "typeorm/query-builder/QueryExpressionMap", "typeorm/query-builder/relation-id/RelationIdLoader", "typeorm/query-builder/relation-id/RelationIdMetadataToAttributeTransformer", "typeorm/query-builder/relation-count/RelationCountLoader", "typeorm/query-builder/relation-count/RelationCountMetadataToAttributeTransformer"], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    var OracleDriver_1, RawSqlResultsToEntityTransformer_1, SqlServerDriver_1, QueryRunnerProvider_1, PessimisticLockTransactionRequiredError_1, NoVersionOrUpdateDateColumnError_1, OptimisticLockVersionMismatchError_1, OptimisticLockCanNotBeUsedError_1, PostgresDriver_1, MysqlDriver_1, LockNotSupportedOnGivenDriverError_1, JoinAttribute_2, RelationIdAttribute_3, RelationCountAttribute_3, QueryExpressionMap_1, RelationIdLoader_1, RelationIdMetadataToAttributeTransformer_1, RelationCountLoader_1, RelationCountMetadataToAttributeTransformer_1, QueryBuilder;
    return {
        setters: [
            function (OracleDriver_1_1) {
                OracleDriver_1 = OracleDriver_1_1;
            },
            function (RawSqlResultsToEntityTransformer_1_1) {
                RawSqlResultsToEntityTransformer_1 = RawSqlResultsToEntityTransformer_1_1;
            },
            function (SqlServerDriver_1_1) {
                SqlServerDriver_1 = SqlServerDriver_1_1;
            },
            function (QueryRunnerProvider_1_1) {
                QueryRunnerProvider_1 = QueryRunnerProvider_1_1;
            },
            function (PessimisticLockTransactionRequiredError_1_1) {
                PessimisticLockTransactionRequiredError_1 = PessimisticLockTransactionRequiredError_1_1;
            },
            function (NoVersionOrUpdateDateColumnError_1_1) {
                NoVersionOrUpdateDateColumnError_1 = NoVersionOrUpdateDateColumnError_1_1;
            },
            function (OptimisticLockVersionMismatchError_1_1) {
                OptimisticLockVersionMismatchError_1 = OptimisticLockVersionMismatchError_1_1;
            },
            function (OptimisticLockCanNotBeUsedError_1_1) {
                OptimisticLockCanNotBeUsedError_1 = OptimisticLockCanNotBeUsedError_1_1;
            },
            function (PostgresDriver_1_1) {
                PostgresDriver_1 = PostgresDriver_1_1;
            },
            function (MysqlDriver_1_1) {
                MysqlDriver_1 = MysqlDriver_1_1;
            },
            function (LockNotSupportedOnGivenDriverError_1_1) {
                LockNotSupportedOnGivenDriverError_1 = LockNotSupportedOnGivenDriverError_1_1;
            },
            function (JoinAttribute_2_1) {
                JoinAttribute_2 = JoinAttribute_2_1;
            },
            function (RelationIdAttribute_3_1) {
                RelationIdAttribute_3 = RelationIdAttribute_3_1;
            },
            function (RelationCountAttribute_3_1) {
                RelationCountAttribute_3 = RelationCountAttribute_3_1;
            },
            function (QueryExpressionMap_1_1) {
                QueryExpressionMap_1 = QueryExpressionMap_1_1;
            },
            function (RelationIdLoader_1_1) {
                RelationIdLoader_1 = RelationIdLoader_1_1;
            },
            function (RelationIdMetadataToAttributeTransformer_1_1) {
                RelationIdMetadataToAttributeTransformer_1 = RelationIdMetadataToAttributeTransformer_1_1;
            },
            function (RelationCountLoader_1_1) {
                RelationCountLoader_1 = RelationCountLoader_1_1;
            },
            function (RelationCountMetadataToAttributeTransformer_1_1) {
                RelationCountMetadataToAttributeTransformer_1 = RelationCountMetadataToAttributeTransformer_1_1;
            }
        ],
        execute: function () {
            // todo: fix problem with long aliases eg getMaxIdentifierLength
            // todo: fix replacing in .select("COUNT(post.id) AS cnt") statement
            // todo: implement joinAlways in relations and relationId
            // todo: implement @Select decorator
            // todo: add quoting functions
            // todo: .addCount and .addCountSelect()
            // todo: add selectAndMap
            // todo: tests for:
            // todo: entityOrProperty can be target name. implement proper behaviour if it is.
            // todo: think about subselect in joins syntax
            // todo: create multiple representations of QueryBuilder: UpdateQueryBuilder, DeleteQueryBuilder
            // qb.update() returns UpdateQueryBuilder
            // qb.delete() returns DeleteQueryBuilder
            // qb.select() returns SelectQueryBuilder
            // todo: COMPLETELY COVER QUERY BUILDER WITH TESTS
            // todo: SUBSELECT IMPLEMENTATION
            // .whereSubselect(qb => qb.select().from().where())
            // todo: also create qb.createSubQueryBuilder()
            // todo: check in persistment if id exist on object and throw exception (can be in partial selection?)
            // todo: STREAMING
            /**
             * Allows to build complex sql queries in a fashion way and execute those queries.
             */
            QueryBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function QueryBuilder(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    this.expressionMap = new QueryExpressionMap_1.QueryExpressionMap(connection);
                }
                Object.defineProperty(QueryBuilder.prototype, "alias", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the main alias string used in this query builder.
                     */
                    get: function () {
                        if (!this.expressionMap.mainAlias)
                            throw new Error("Main alias is not set"); // todo: better exception
                        return this.expressionMap.mainAlias.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Creates SELECT query and selects given data.
                 * Replaces all previous selections if they exist.
                 */
                QueryBuilder.prototype.select = function (selection, selectionAliasName) {
                    this.expressionMap.queryType = "select";
                    if (selection instanceof Array) {
                        this.expressionMap.selects = selection.map(function (selection) { return ({ selection: selection }); });
                    }
                    else if (selection) {
                        this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];
                    }
                    return this;
                };
                /**
                 * Adds new selection to the SELECT query.
                 */
                QueryBuilder.prototype.addSelect = function (selection, selectionAliasName) {
                    if (selection instanceof Array) {
                        this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(function (selection) { return ({ selection: selection }); }));
                    }
                    else {
                        this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });
                    }
                    return this;
                };
                /**
                 * Creates UPDATE query and applies given update values.
                 */
                QueryBuilder.prototype.update = function (entityOrTableNameUpdateSet, maybeUpdateSet) {
                    var updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;
                    if (entityOrTableNameUpdateSet instanceof Function) {
                        this.expressionMap.createMainAlias({
                            target: entityOrTableNameUpdateSet
                        });
                    }
                    else if (typeof entityOrTableNameUpdateSet === "string") {
                        this.expressionMap.createMainAlias({
                            tableName: entityOrTableNameUpdateSet
                        });
                    }
                    this.expressionMap.queryType = "update";
                    this.expressionMap.updateSet = updateSet;
                    return this;
                };
                /**
                 * Creates DELETE query.
                 */
                QueryBuilder.prototype.delete = function () {
                    this.expressionMap.queryType = "delete";
                    return this;
                };
                /**
                 * Specifies FROM which entity's table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                QueryBuilder.prototype.from = function (entityTarget, aliasName) {
                    this.expressionMap.createMainAlias({
                        name: aliasName,
                        target: entityTarget
                    });
                    return this;
                };
                /**
                 * Specifies FROM which table select/update/delete will be executed.
                 * Also sets a main string alias of the selection data.
                 */
                QueryBuilder.prototype.fromTable = function (tableName, aliasName) {
                    // if table has a metadata then find it to properly escape its properties
                    var metadata = this.connection.entityMetadatas.find(function (metadata) { return metadata.tableName === tableName; });
                    if (metadata) {
                        this.expressionMap.createMainAlias({
                            name: aliasName,
                            metadata: metadata,
                        });
                    }
                    else {
                        this.expressionMap.createMainAlias({
                            name: aliasName,
                            tableName: tableName,
                        });
                    }
                    return this;
                };
                /**
                 * INNER JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoin = function (entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.join("INNER", entityOrProperty, aliasName, condition, options);
                    return this;
                };
                /**
                 * LEFT JOINs (without selection).
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoin = function (entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.join("LEFT", entityOrProperty, aliasName, condition, options);
                    return this;
                };
                /**
                 * INNER JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndSelect = function (entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.innerJoin(entityOrProperty, aliasName, condition, options);
                    return this;
                };
                /**
                 * LEFT JOINs and adds all selection properties to SELECT.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndSelect = function (entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.leftJoin(entityOrProperty, aliasName, condition, options);
                    return this;
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndMapMany = function (mapToProperty, entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("INNER", entityOrProperty, aliasName, condition, options, mapToProperty, true);
                    return this;
                };
                /**
                 * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.innerJoinAndMapOne = function (mapToProperty, entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("INNER", entityOrProperty, aliasName, condition, options, mapToProperty, false);
                    return this;
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there are multiple rows of selecting data, and mapped result will be an array.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndMapMany = function (mapToProperty, entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("LEFT", entityOrProperty, aliasName, condition, options, mapToProperty, true);
                    return this;
                };
                /**
                 * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.
                 * This is extremely useful when you want to select some data and map it to some virtual property.
                 * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.
                 * You also need to specify an alias of the joined data.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.leftJoinAndMapOne = function (mapToProperty, entityOrProperty, aliasName, condition, options) {
                    if (condition === void 0) { condition = ""; }
                    this.addSelect(aliasName);
                    this.join("LEFT", entityOrProperty, aliasName, condition, options, mapToProperty, false);
                    return this;
                };
                /**
                 * LEFT JOINs relation id and maps it into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.loadRelationIdAndMap = function (mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {
                    var relationIdAttribute = new RelationIdAttribute_3.RelationIdAttribute(this.expressionMap);
                    relationIdAttribute.mapToProperty = mapToProperty;
                    relationIdAttribute.relationName = relationName;
                    if (typeof aliasNameOrOptions === "string")
                        relationIdAttribute.alias = aliasNameOrOptions;
                    if (aliasNameOrOptions instanceof Object && aliasNameOrOptions.disableMixedMap)
                        relationIdAttribute.disableMixedMap = true;
                    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;
                    this.expressionMap.relationIdAttributes.push(relationIdAttribute);
                    if (relationIdAttribute.relation.junctionEntityMetadata) {
                        this.expressionMap.createAlias({
                            name: relationIdAttribute.junctionAlias,
                            metadata: relationIdAttribute.relation.junctionEntityMetadata
                        });
                    }
                    return this;
                };
                /**
                 * Counts number of entities of entity's relation and maps the value into some entity's property.
                 * Optionally, you can add condition and parameters used in condition.
                 */
                QueryBuilder.prototype.loadRelationCountAndMap = function (mapToProperty, relationName, aliasName, queryBuilderFactory) {
                    var relationCountAttribute = new RelationCountAttribute_3.RelationCountAttribute(this.expressionMap);
                    relationCountAttribute.mapToProperty = mapToProperty;
                    relationCountAttribute.relationName = relationName;
                    relationCountAttribute.alias = aliasName;
                    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;
                    this.expressionMap.relationCountAttributes.push(relationCountAttribute);
                    this.expressionMap.createAlias({
                        name: relationCountAttribute.junctionAlias
                    });
                    if (relationCountAttribute.relation.junctionEntityMetadata) {
                        this.expressionMap.createAlias({
                            name: relationCountAttribute.junctionAlias,
                            metadata: relationCountAttribute.relation.junctionEntityMetadata
                        });
                    }
                    return this;
                };
                /**
                 * Sets WHERE condition in the query builder.
                 * If you had previously WHERE expression defined,
                 * calling this function will override previously set WHERE conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.where = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "simple", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.andWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "and", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.orWhere = function (where, parameters) {
                    this.expressionMap.wheres.push({ type: "or", condition: where });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Sets HAVING condition in the query builder.
                 * If you had previously HAVING expression defined,
                 * calling this function will override previously set HAVING conditions.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.having = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "simple", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new AND HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.andHaving = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "and", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Adds new OR HAVING condition in the query builder.
                 * Additionally you can add parameters used in where expression.
                 */
                QueryBuilder.prototype.orHaving = function (having, parameters) {
                    this.expressionMap.havings.push({ type: "or", condition: having });
                    if (parameters)
                        this.setParameters(parameters);
                    return this;
                };
                /**
                 * Sets GROUP BY condition in the query builder.
                 * If you had previously GROUP BY expression defined,
                 * calling this function will override previously set GROUP BY conditions.
                 */
                QueryBuilder.prototype.groupBy = function (groupBy) {
                    this.expressionMap.groupBys = [groupBy];
                    return this;
                };
                /**
                 * Adds GROUP BY condition in the query builder.
                 */
                QueryBuilder.prototype.addGroupBy = function (groupBy) {
                    this.expressionMap.groupBys.push(groupBy);
                    return this;
                };
                /**
                 * Sets ORDER BY condition in the query builder.
                 * If you had previously ORDER BY expression defined,
                 * calling this function will override previously set ORDER BY conditions.
                 */
                QueryBuilder.prototype.orderBy = function (sort, order) {
                    if (order === void 0) { order = "ASC"; }
                    if (sort) {
                        this.expressionMap.orderBys = (_a = {}, _a[sort] = order, _a);
                    }
                    else {
                        this.expressionMap.orderBys = {};
                    }
                    return this;
                    var _a;
                };
                /**
                 * Adds ORDER BY condition in the query builder.
                 */
                QueryBuilder.prototype.addOrderBy = function (sort, order) {
                    if (order === void 0) { order = "ASC"; }
                    this.expressionMap.orderBys[sort] = order;
                    return this;
                };
                /**
                 * Set's LIMIT - maximum number of rows to be selected.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead take method instead.
                 */
                QueryBuilder.prototype.setLimit = function (limit) {
                    this.expressionMap.limit = limit;
                    return this;
                };
                /**
                 * Set's OFFSET - selection offset.
                 * NOTE that it may not work as you expect if you are using joins.
                 * If you want to implement pagination, and you are having join in your query,
                 * then use instead skip method instead.
                 */
                QueryBuilder.prototype.setOffset = function (offset) {
                    this.expressionMap.offset = offset;
                    return this;
                };
                /**
                 * Sets maximal number of entities to take.
                 */
                QueryBuilder.prototype.take = function (take) {
                    this.expressionMap.take = take;
                    return this;
                };
                /**
                 * Sets number of entities to skip.
                 */
                QueryBuilder.prototype.skip = function (skip) {
                    this.expressionMap.skip = skip;
                    return this;
                };
                /**
                 * Sets maximal number of entities to take.
                 *
                 * @deprecated use take method instead
                 */
                QueryBuilder.prototype.setMaxResults = function (take) {
                    this.expressionMap.take = take;
                    return this;
                };
                /**
                 * Sets number of entities to skip.
                 *
                 * @deprecated use skip method instead
                 */
                QueryBuilder.prototype.setFirstResult = function (skip) {
                    this.expressionMap.skip = skip;
                    return this;
                };
                /**
                 * Sets locking mode.
                 */
                QueryBuilder.prototype.setLock = function (lockMode, lockVersion) {
                    this.expressionMap.lockMode = lockMode;
                    this.expressionMap.lockVersion = lockVersion;
                    return this;
                };
                /**
                 * Sets given parameter's value.
                 */
                QueryBuilder.prototype.setParameter = function (key, value) {
                    this.expressionMap.parameters[key] = value;
                    return this;
                };
                /**
                 * Adds all parameters from the given object.
                 */
                QueryBuilder.prototype.setParameters = function (parameters) {
                    var _this = this;
                    Object.keys(parameters).forEach(function (key) {
                        _this.expressionMap.parameters[key] = parameters[key];
                    });
                    return this;
                };
                /**
                 * Gets all parameters.
                 */
                QueryBuilder.prototype.getParameters = function () {
                    var parameters = Object.assign({}, this.expressionMap.parameters);
                    // add discriminator column parameter if it exist
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                            var values = metadata.childEntityMetadatas
                                .filter(function (childMetadata) { return childMetadata.discriminatorColumn; })
                                .map(function (childMetadata) { return childMetadata.discriminatorValue; });
                            values.push(metadata.discriminatorValue);
                            parameters["discriminatorColumnValues"] = values;
                        }
                    }
                    return parameters;
                };
                /**
                 * Gets generated sql that will be executed.
                 * Parameters in the query are escaped for the currently used driver.
                 */
                QueryBuilder.prototype.getSql = function () {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    sql += this.createLockExpression();
                    sql = this.createSpecificExpression(sql);
                    sql = this.connection.driver.escapeQueryWithParameters(sql, this.expressionMap.parameters)[0];
                    return sql.trim();
                };
                QueryBuilder.prototype.createSpecificExpression = function (sql) {
                    if ((this.expressionMap.offset || this.expressionMap.limit) && this.connection.driver instanceof OracleDriver_1.OracleDriver) {
                        sql = 'SELECT * FROM (' + sql + ') WHERE ';
                        if (this.expressionMap.offset) {
                            sql += "\"RN\" > " + this.expressionMap.offset;
                        }
                        if (this.expressionMap.limit) {
                            sql += (this.expressionMap.offset ? " AND " : "") + "\"RN\" < " + ((this.expressionMap.offset || 0) + this.expressionMap.limit);
                        }
                    }
                    return sql;
                };
                /**
                 * Gets generated sql without parameters being replaced.
                 */
                QueryBuilder.prototype.getGeneratedQuery = function () {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    sql += this.createLockExpression();
                    sql = this.createSpecificExpression(sql);
                    return sql.trim();
                };
                /**
                 * Gets sql to be executed with all parameters used in it.
                 */
                QueryBuilder.prototype.getSqlWithParameters = function (options) {
                    var sql = this.createSelectExpression();
                    sql += this.createJoinExpression();
                    sql += this.createWhereExpression();
                    sql += this.createGroupByExpression();
                    sql += this.createHavingExpression();
                    if (!options || !options.skipOrderBy)
                        sql += this.createOrderByExpression();
                    sql += this.createLimitExpression();
                    sql += this.createOffsetExpression();
                    sql += this.createLockExpression();
                    sql = this.createSpecificExpression(sql);
                    return this.connection.driver.escapeQueryWithParameters(sql, this.getParameters());
                };
                /**
                 * Executes sql generated by query builder and returns raw database results.
                 */
                QueryBuilder.prototype.execute = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, _a, sql, parameters;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0: return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _b.sent();
                                    _a = this.getSqlWithParameters(), sql = _a[0], parameters = _a[1];
                                    _b.label = 2;
                                case 2:
                                    _b.trys.push([2, , 4, 7]);
                                    return [4 /*yield*/, queryRunner.query(sql, parameters)];
                                case 3: return [2 /*return*/, _b.sent()]; // await is needed here because we are using finally
                                case 4:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _b.sent();
                                    _b.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Executes sql generated by query builder and returns object with raw results and entities created from them.
                 */
                QueryBuilder.prototype.getEntitiesAndRawResults = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, relationIdLoader, relationCountLoader, relationIdMetadataTransformer, relationCountMetadataTransformer, metadata, mainAliasName_1, _a, sql, parameters, _b, selects, orderBys, distinctAlias_1, metadata_1, idsQuery, entities, rawResults, condition, parameters_3, ids, areAllNumbers, clonnedQb, _c, queryWithIdsSql, queryWithIdsParameters, rawRelationIdResults, rawRelationCountResults, _d, sql, parameters, rawResults, rawRelationIdResults, rawRelationCountResults, entities;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0: return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _e.sent();
                                    relationIdLoader = new RelationIdLoader_1.RelationIdLoader(this.connection, this.queryRunnerProvider, this.expressionMap.relationIdAttributes);
                                    relationCountLoader = new RelationCountLoader_1.RelationCountLoader(this.connection, this.queryRunnerProvider, this.expressionMap.relationCountAttributes);
                                    relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer_1.RelationIdMetadataToAttributeTransformer(this.expressionMap);
                                    relationIdMetadataTransformer.transform();
                                    relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer_1.RelationCountMetadataToAttributeTransformer(this.expressionMap);
                                    relationCountMetadataTransformer.transform();
                                    _e.label = 2;
                                case 2:
                                    _e.trys.push([2, , 16, 19]);
                                    if (!this.expressionMap.mainAlias)
                                        throw new Error("Alias is not set. Looks like nothing is selected. Use select*, delete, update method to set an alias.");
                                    if ((this.expressionMap.lockMode === "pessimistic_read" || this.expressionMap.lockMode === "pessimistic_write") && !queryRunner.isTransactionActive())
                                        throw new PessimisticLockTransactionRequiredError_1.PessimisticLockTransactionRequiredError();
                                    if (this.expressionMap.lockMode === "optimistic") {
                                        metadata = this.expressionMap.mainAlias.metadata;
                                        if (!metadata.versionColumn && !metadata.updateDateColumn)
                                            throw new NoVersionOrUpdateDateColumnError_1.NoVersionOrUpdateDateColumnError(metadata.name);
                                    }
                                    mainAliasName_1 = this.expressionMap.mainAlias.name;
                                    if (!(this.expressionMap.skip || this.expressionMap.take)) return [3 /*break*/, 9];
                                    _a = this.getSqlWithParameters({ skipOrderBy: true }), sql = _a[0], parameters = _a[1];
                                    _b = this.createOrderByCombinedWithSelectExpression("distinctAlias"), selects = _b[0], orderBys = _b[1];
                                    distinctAlias_1 = this.escapeTable("distinctAlias");
                                    metadata_1 = this.expressionMap.mainAlias.metadata;
                                    idsQuery = "SELECT ";
                                    idsQuery += metadata_1.primaryColumns.map(function (primaryColumn, index) {
                                        var propertyName = _this.escapeAlias(mainAliasName_1 + "_" + primaryColumn.databaseName);
                                        if (index === 0) {
                                            return "DISTINCT(" + distinctAlias_1 + "." + propertyName + ") as ids_" + primaryColumn.databaseName;
                                        }
                                        else {
                                            return distinctAlias_1 + "." + propertyName + ") as ids_" + primaryColumn.databaseName;
                                        }
                                    }).join(", ");
                                    if (selects.length > 0)
                                        idsQuery += ", " + selects;
                                    idsQuery += " FROM (" + sql + ") " + distinctAlias_1; // TODO: WHAT TO DO WITH PARAMETERS HERE? DO THEY WORK?
                                    if (orderBys.length > 0) {
                                        idsQuery += " ORDER BY " + orderBys;
                                    }
                                    else {
                                        idsQuery += " ORDER BY \"ids_" + metadata_1.primaryColumns[0].databaseName + "\""; // this is required for mssql driver if firstResult is used. Other drivers don't care about it
                                    }
                                    if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                                        if (this.expressionMap.skip || this.expressionMap.take) {
                                            idsQuery += " OFFSET " + (this.expressionMap.skip || 0) + " ROWS";
                                            if (this.expressionMap.take)
                                                idsQuery += " FETCH NEXT " + this.expressionMap.take + " ROWS ONLY";
                                        }
                                    }
                                    else {
                                        if (this.expressionMap.take)
                                            idsQuery += " LIMIT " + this.expressionMap.take;
                                        if (this.expressionMap.skip)
                                            idsQuery += " OFFSET " + this.expressionMap.skip;
                                    }
                                    entities = [];
                                    return [4 /*yield*/, queryRunner.query(idsQuery, parameters)];
                                case 3:
                                    rawResults = _e.sent();
                                    if (!(rawResults.length > 0)) return [3 /*break*/, 8];
                                    condition = "";
                                    parameters_3 = {};
                                    if (metadata_1.hasMultiplePrimaryKeys) {
                                        condition = rawResults.map(function (result) {
                                            return metadata_1.primaryColumns.map(function (primaryColumn) {
                                                parameters_3["ids_" + primaryColumn.propertyName] = result["ids_" + primaryColumn.propertyName];
                                                return mainAliasName_1 + "." + primaryColumn.propertyName + "=:ids_" + primaryColumn.propertyName;
                                            }).join(" AND ");
                                        }).join(" OR ");
                                    }
                                    else {
                                        ids = rawResults.map(function (result) { return result["ids_" + metadata_1.primaryColumns[0].propertyName]; });
                                        areAllNumbers = ids.every(function (id) { return typeof id === "number"; });
                                        if (areAllNumbers) {
                                            // fixes #190. if all numbers then its safe to perform query without parameter
                                            condition = mainAliasName_1 + "." + metadata_1.primaryColumns[0].propertyName + " IN (" + ids.join(", ") + ")";
                                        }
                                        else {
                                            parameters_3["ids"] = ids;
                                            condition = mainAliasName_1 + "." + metadata_1.primaryColumns[0].propertyName + " IN (:ids)";
                                        }
                                    }
                                    clonnedQb = this.clone({ queryRunnerProvider: this.queryRunnerProvider });
                                    clonnedQb.expressionMap.extraAppendedAndWhereCondition = condition;
                                    _c = clonnedQb
                                        .setParameters(parameters_3)
                                        .getSqlWithParameters(), queryWithIdsSql = _c[0], queryWithIdsParameters = _c[1];
                                    return [4 /*yield*/, queryRunner.query(queryWithIdsSql, queryWithIdsParameters)];
                                case 4:
                                    rawResults = _e.sent();
                                    return [4 /*yield*/, relationIdLoader.load(rawResults)];
                                case 5:
                                    rawRelationIdResults = _e.sent();
                                    return [4 /*yield*/, relationCountLoader.load(rawResults)];
                                case 6:
                                    rawRelationCountResults = _e.sent();
                                    entities = this.rawResultsToEntities(rawResults, rawRelationIdResults, rawRelationCountResults);
                                    if (!this.expressionMap.mainAlias.hasMetadata) return [3 /*break*/, 8];
                                    return [4 /*yield*/, this.connection.broadcaster.broadcastLoadEventsForAll(this.expressionMap.mainAlias.target, rawResults)];
                                case 7:
                                    _e.sent();
                                    _e.label = 8;
                                case 8: return [2 /*return*/, {
                                        entities: entities,
                                        rawResults: rawResults
                                    }];
                                case 9:
                                    _d = this.getSqlWithParameters(), sql = _d[0], parameters = _d[1];
                                    return [4 /*yield*/, queryRunner.query(sql, parameters)];
                                case 10:
                                    rawResults = _e.sent();
                                    return [4 /*yield*/, relationIdLoader.load(rawResults)];
                                case 11:
                                    rawRelationIdResults = _e.sent();
                                    return [4 /*yield*/, relationCountLoader.load(rawResults)];
                                case 12:
                                    rawRelationCountResults = _e.sent();
                                    entities = this.rawResultsToEntities(rawResults, rawRelationIdResults, rawRelationCountResults);
                                    if (!this.expressionMap.mainAlias.hasMetadata) return [3 /*break*/, 14];
                                    return [4 /*yield*/, this.connection.broadcaster.broadcastLoadEventsForAll(this.expressionMap.mainAlias.target, rawResults)];
                                case 13:
                                    _e.sent();
                                    _e.label = 14;
                                case 14: return [2 /*return*/, {
                                        entities: entities,
                                        rawResults: rawResults
                                    }];
                                case 15: return [3 /*break*/, 19];
                                case 16:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 18];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 17:
                                    _e.sent();
                                    _e.label = 18;
                                case 18: return [7 /*endfinally*/];
                                case 19: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets count - number of entities selected by sql generated by this query builder.
                 * Count excludes all limitations set by setFirstResult and setMaxResults methods call.
                 */
                QueryBuilder.prototype.getCount = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, mainAlias, metadata, distinctAlias, countSql, countQueryBuilder, _a, countQuerySql, countQueryParameters, results;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    return [4 /*yield*/, this.getQueryRunner()];
                                case 1:
                                    queryRunner = _b.sent();
                                    mainAlias = this.expressionMap.mainAlias.name;
                                    metadata = this.expressionMap.mainAlias.metadata;
                                    distinctAlias = this.escapeAlias(mainAlias);
                                    countSql = "COUNT(" + metadata.primaryColumns.map(function (primaryColumn, index) {
                                        var propertyName = _this.escapeColumn(primaryColumn.databaseName);
                                        if (index === 0) {
                                            return "DISTINCT(" + distinctAlias + "." + propertyName + ")";
                                        }
                                        else {
                                            return distinctAlias + "." + propertyName + ")";
                                        }
                                    }).join(", ") + ") as \"cnt\"";
                                    countQueryBuilder = this
                                        .clone({ queryRunnerProvider: this.queryRunnerProvider })
                                        .orderBy(undefined)
                                        .setOffset(undefined)
                                        .setLimit(undefined)
                                        .select(countSql);
                                    countQueryBuilder.expressionMap.ignoreParentTablesJoins = true;
                                    _a = countQueryBuilder.getSqlWithParameters(), countQuerySql = _a[0], countQueryParameters = _a[1];
                                    _b.label = 2;
                                case 2:
                                    _b.trys.push([2, , 4, 7]);
                                    return [4 /*yield*/, queryRunner.query(countQuerySql, countQueryParameters)];
                                case 3:
                                    results = _b.sent();
                                    if (!results || !results[0] || !results[0]["cnt"])
                                        return [2 /*return*/, 0];
                                    return [2 /*return*/, parseInt(results[0]["cnt"])];
                                case 4:
                                    if (!this.hasOwnQueryRunner()) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunner.release()];
                                case 5:
                                    _b.sent();
                                    _b.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets all raw results returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getRawMany = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.expressionMap.lockMode === "optimistic")
                                throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                            return [2 /*return*/, this.execute()];
                        });
                    });
                };
                /**
                 * Gets first raw result returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getRawOne = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    return [4 /*yield*/, this.execute()];
                                case 1:
                                    results = _a.sent();
                                    return [2 /*return*/, results[0]];
                            }
                        });
                    });
                };
                /**
                 * Gets entities and count returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getManyAndCount = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.expressionMap.lockMode === "optimistic")
                                throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                            // todo: share database connection and counter
                            return [2 /*return*/, Promise.all([
                                    this.getMany(),
                                    this.getCount()
                                ])];
                        });
                    });
                };
                /**
                 * Gets entities returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getMany = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.expressionMap.lockMode === "optimistic")
                                        throw new OptimisticLockCanNotBeUsedError_1.OptimisticLockCanNotBeUsedError();
                                    return [4 /*yield*/, this.getEntitiesAndRawResults()];
                                case 1:
                                    results = _a.sent();
                                    return [2 /*return*/, results.entities];
                            }
                        });
                    });
                };
                /**
                 * Gets single entity returned by execution of generated query builder sql.
                 */
                QueryBuilder.prototype.getOne = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var results, result, metadata, actualVersion, actualVersion;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getEntitiesAndRawResults()];
                                case 1:
                                    results = _a.sent();
                                    result = results.entities[0];
                                    if (result && this.expressionMap.lockMode === "optimistic" && this.expressionMap.lockVersion) {
                                        metadata = this.expressionMap.mainAlias.metadata;
                                        if (this.expressionMap.lockVersion instanceof Date) {
                                            actualVersion = result[metadata.updateDateColumn.propertyName];
                                            this.expressionMap.lockVersion.setMilliseconds(0);
                                            if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())
                                                throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
                                        }
                                        else {
                                            actualVersion = result[metadata.versionColumn.propertyName];
                                            if (actualVersion !== this.expressionMap.lockVersion)
                                                throw new OptimisticLockVersionMismatchError_1.OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);
                                        }
                                    }
                                    return [2 /*return*/, result];
                            }
                        });
                    });
                };
                /**
                 * Clones query builder as it is.
                 */
                QueryBuilder.prototype.clone = function (options) {
                    var qb = new QueryBuilder(this.connection, options ? options.queryRunnerProvider : undefined);
                    qb.expressionMap = this.expressionMap.clone();
                    return qb;
                };
                /**
                 * Disables escaping.
                 */
                QueryBuilder.prototype.disableEscaping = function () {
                    this.expressionMap.disableEscaping = false;
                    return this;
                };
                /**
                 * Escapes alias name using current database's escaping character.
                 */
                QueryBuilder.prototype.escapeAlias = function (name) {
                    if (!this.expressionMap.disableEscaping)
                        return name;
                    return this.connection.driver.escapeAliasName(name);
                };
                /**
                 * Escapes column name using current database's escaping character.
                 */
                QueryBuilder.prototype.escapeColumn = function (name) {
                    if (!this.expressionMap.disableEscaping)
                        return name;
                    return this.connection.driver.escapeColumnName(name);
                };
                /**
                 * Escapes table name using current database's escaping character.
                 */
                QueryBuilder.prototype.escapeTable = function (name) {
                    if (!this.expressionMap.disableEscaping)
                        return name;
                    return this.connection.driver.escapeTableName(name);
                };
                /**
                 * Enables special query builder options.
                 *
                 * @deprecated looks like enableRelationIdValues is not used anymore. What to do? Remove this method? What about persistence?
                 */
                QueryBuilder.prototype.enableAutoRelationIdsLoad = function () {
                    var _this = this;
                    this.expressionMap.mainAlias.metadata.relations.forEach(function (relation) {
                        _this.loadRelationIdAndMap(_this.expressionMap.mainAlias.name + "." + relation.propertyPath, _this.expressionMap.mainAlias.name + "." + relation.propertyPath, { disableMixedMap: true });
                    });
                    return this;
                };
                /**
                 * Adds new AND WHERE with conditions for the given ids.
                 *
                 * @experimental Maybe this method should be moved to repository?
                 * @deprecated
                 */
                QueryBuilder.prototype.andWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.andWhere(whereExpression, parameters);
                    return this;
                };
                /**
                 * Adds new OR WHERE with conditions for the given ids.
                 *
                 * @experimental Maybe this method should be moved to repository?
                 * @deprecated
                 */
                QueryBuilder.prototype.orWhereInIds = function (ids) {
                    var _a = this.createWhereIdsExpression(ids), whereExpression = _a[0], parameters = _a[1];
                    this.orWhere(whereExpression, parameters);
                    return this;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                QueryBuilder.prototype.join = function (direction, entityOrProperty, aliasName, condition, options, mapToProperty, isMappingMany) {
                    var joinAttribute = new JoinAttribute_2.JoinAttribute(this.connection, this.expressionMap);
                    joinAttribute.direction = direction;
                    joinAttribute.mapToProperty = mapToProperty;
                    joinAttribute.options = options;
                    joinAttribute.isMappingMany = isMappingMany;
                    joinAttribute.entityOrProperty = entityOrProperty; // relationName
                    joinAttribute.condition = condition; // joinInverseSideCondition
                    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + "_" + destinationTableAlias : destinationTableAlias + "_" + parentAlias;
                    this.expressionMap.joinAttributes.push(joinAttribute);
                    // todo: find and set metadata right there?
                    joinAttribute.alias = this.expressionMap.createAlias({
                        name: aliasName,
                        metadata: joinAttribute.metadata
                    });
                    if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {
                        this.expressionMap.createAlias({
                            name: joinAttribute.junctionAlias,
                            metadata: joinAttribute.relation.junctionEntityMetadata
                        });
                    }
                };
                QueryBuilder.prototype.rawResultsToEntities = function (results, rawRelationIdResults, rawRelationCountResults) {
                    return new RawSqlResultsToEntityTransformer_1.RawSqlResultsToEntityTransformer(this.connection.driver, this.expressionMap.joinAttributes, rawRelationIdResults, rawRelationCountResults)
                        .transform(results, this.expressionMap.mainAlias);
                };
                QueryBuilder.prototype.buildEscapedEntityColumnSelects = function (aliasName, metadata) {
                    var _this = this;
                    var hasMainAlias = this.expressionMap.selects.some(function (select) { return select.selection === aliasName; });
                    var columns = hasMainAlias ? metadata.columns : metadata.columns.filter(function (column) {
                        return _this.expressionMap.selects.some(function (select) { return select.selection === aliasName + "." + column.propertyName; });
                    });
                    return columns.map(function (column) {
                        var selection = _this.expressionMap.selects.find(function (select) { return select.selection === aliasName + "." + column.propertyName; });
                        return {
                            selection: _this.escapeAlias(aliasName) + "." + _this.escapeColumn(column.databaseName),
                            aliasName: selection && selection.aliasName ? selection.aliasName : aliasName + "_" + column.databaseName,
                        };
                        // return this.escapeAlias(aliasName) + "." + this.escapeColumn(column.fullName) +
                        //     " AS " + this.escapeAlias(aliasName + "_" + column.fullName);
                    });
                };
                QueryBuilder.prototype.findEntityColumnSelects = function (aliasName, metadata) {
                    var mainSelect = this.expressionMap.selects.find(function (select) { return select.selection === aliasName; });
                    if (mainSelect)
                        return [mainSelect];
                    return this.expressionMap.selects.filter(function (select) {
                        return metadata.columns.some(function (column) { return select.selection === aliasName + "." + column.propertyName; });
                    });
                };
                // todo: extract all create expression methods to separate class QueryExpressionBuilder
                QueryBuilder.prototype.createSelectExpression = function () {
                    var _this = this;
                    if (!this.expressionMap.mainAlias)
                        throw new Error("Cannot build query because main alias is not set (call qb#from method)");
                    // separate escaping functions are used to reduce code size and complexity below
                    var et = function (aliasName) { return _this.escapeTable(aliasName); };
                    var ea = function (aliasName) { return _this.escapeAlias(aliasName); };
                    var ec = function (aliasName) { return _this.escapeColumn(aliasName); };
                    // todo throw exception if selects or from is missing
                    var tableName;
                    var allSelects = [];
                    var excludedSelects = [];
                    var aliasName = this.expressionMap.mainAlias.name;
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        tableName = metadata.tableName;
                        allSelects.push.apply(allSelects, this.buildEscapedEntityColumnSelects(aliasName, metadata));
                        excludedSelects.push.apply(excludedSelects, this.findEntityColumnSelects(aliasName, metadata));
                    }
                    else {
                        tableName = this.expressionMap.mainAlias.tableName;
                    }
                    // add selects from joins
                    this.expressionMap.joinAttributes
                        .forEach(function (join) {
                        if (join.metadata) {
                            allSelects.push.apply(allSelects, _this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));
                            excludedSelects.push.apply(excludedSelects, _this.findEntityColumnSelects(join.alias.name, join.metadata));
                        }
                        else {
                            var hasMainAlias = _this.expressionMap.selects.some(function (select) { return select.selection === join.alias.name; });
                            if (hasMainAlias) {
                                allSelects.push({ selection: ea(join.alias.name) + ".*" });
                                excludedSelects.push({ selection: ea(join.alias.name) });
                            }
                        }
                    });
                    if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === "class-table" && metadata.parentIdColumns) {
                            var alias_1 = "parentIdColumn_" + metadata.parentEntityMetadata.tableName;
                            metadata.parentEntityMetadata.columns.forEach(function (column) {
                                // TODO implement partial select
                                allSelects.push({ selection: ea(alias_1) + "." + ec(column.databaseName), aliasName: alias_1 + "_" + column.databaseName });
                            });
                        }
                    }
                    // add selects from relation id joins
                    // this.relationIdAttributes.forEach(relationIdAttr => {
                    // });
                    /*if (this.enableRelationIdValues) {
                        const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);
                        if (!parentMetadata)
                            throw new Error("Cannot get entity metadata for the given alias " + this.aliasMap.mainAlias.name);
            
                        const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);
                        metadata.manyToManyRelations.forEach(relation => {
            
                            const junctionMetadata = relation.junctionEntityMetadata;
                            junctionMetadata.columns.forEach(column => {
                                const select = ea(this.aliasMap.mainAlias.name + "_" + junctionMetadata.table.name + "_ids") + "." +
                                    ec(column.name) + " AS " +
                                    ea(this.aliasMap.mainAlias.name + "_" + relation.name + "_ids_" + column.name);
                                allSelects.push(select);
                            });
                        });
                    }*/
                    // add all other selects
                    this.expressionMap.selects
                        .filter(function (select) { return excludedSelects.indexOf(select) === -1; })
                        .forEach(function (select) { return allSelects.push({ selection: _this.replacePropertyNames(select.selection), aliasName: select.aliasName }); });
                    // if still selection is empty, then simply set it to all (*)
                    if (allSelects.length === 0)
                        allSelects.push({ selection: "*" });
                    var lock = "";
                    if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                        switch (this.expressionMap.lockMode) {
                            case "pessimistic_read":
                                lock = " WITH (HOLDLOCK, ROWLOCK)";
                                break;
                            case "pessimistic_write":
                                lock = " WITH (UPDLOCK, ROWLOCK)";
                                break;
                        }
                    }
                    // create a selection query
                    switch (this.expressionMap.queryType) {
                        case "select":
                            var selection = allSelects.map(function (select) { return select.selection + (select.aliasName ? " AS " + ea(select.aliasName) : ""); }).join(", ");
                            if ((this.expressionMap.limit || this.expressionMap.offset) && this.connection.driver instanceof OracleDriver_1.OracleDriver) {
                                return "SELECT ROWNUM \"RN\"," + selection + " FROM " + this.escapeTable(tableName) + " " + ea(aliasName) + lock;
                            }
                            return "SELECT " + selection + " FROM " + this.escapeTable(tableName) + " " + ea(aliasName) + lock;
                        case "delete":
                            return "DELETE FROM " + et(tableName);
                        // return "DELETE " + (alias ? ea(alias) : "") + " FROM " + this.escapeTable(tableName) + " " + (alias ? ea(alias) : ""); // TODO: only mysql supports aliasing, so what to do with aliases in DELETE queries? right now aliases are used however we are relaying that they will always match a table names
                        case "update":
                            var updateSet = Object.keys(this.expressionMap.updateSet).map(function (key) { return key + "=:updateSet__" + key; });
                            var params = Object.keys(this.expressionMap.updateSet).reduce(function (object, key) {
                                // todo: map propertyNames to names ?
                                object["updateSet_" + key] = _this.expressionMap.updateSet[key];
                                return object;
                            }, {});
                            this.setParameters(params);
                            return "UPDATE " + tableName + " " + (aliasName ? ea(aliasName) : "") + " SET " + updateSet;
                    }
                    throw new Error("No query builder type is specified.");
                };
                QueryBuilder.prototype.createHavingExpression = function () {
                    var _this = this;
                    if (!this.expressionMap.havings || !this.expressionMap.havings.length)
                        return "";
                    var conditions = this.expressionMap.havings.map(function (having, index) {
                        switch (having.type) {
                            case "and":
                                return (index > 0 ? "AND " : "") + _this.replacePropertyNames(having.condition);
                            case "or":
                                return (index > 0 ? "OR " : "") + _this.replacePropertyNames(having.condition);
                            default:
                                return _this.replacePropertyNames(having.condition);
                        }
                    }).join(" ");
                    if (!conditions.length)
                        return "";
                    return " HAVING " + conditions;
                };
                QueryBuilder.prototype.createWhereExpression = function () {
                    var _this = this;
                    var conditions = this.expressionMap.wheres.map(function (where, index) {
                        switch (where.type) {
                            case "and":
                                return (index > 0 ? "AND " : "") + _this.replacePropertyNames(where.condition);
                            case "or":
                                return (index > 0 ? "OR " : "") + _this.replacePropertyNames(where.condition);
                            default:
                                return _this.replacePropertyNames(where.condition);
                        }
                    }).join(" ");
                    if (this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {
                            var condition = this.replacePropertyNames(this.expressionMap.mainAlias.name + "." + metadata.discriminatorColumn.databaseName) + " IN (:discriminatorColumnValues)";
                            return " WHERE " + (conditions.length ? "(" + conditions + ") AND" : "") + " " + condition;
                        }
                    }
                    if (!conditions.length)
                        return this.expressionMap.extraAppendedAndWhereCondition ? " WHERE " + this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition) : "";
                    if (this.expressionMap.extraAppendedAndWhereCondition)
                        return " WHERE (" + conditions + ") AND " + this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);
                    return " WHERE " + conditions;
                };
                /**
                 * Replaces all entity's propertyName to name in the given statement.
                 */
                QueryBuilder.prototype.replacePropertyNames = function (statement) {
                    var _this = this;
                    this.expressionMap.aliases.forEach(function (alias) {
                        if (!alias.hasMetadata)
                            return;
                        alias.metadata.columns.forEach(function (column) {
                            var expression = "([ =\(]|^.{0})" + alias.name + "\\." + column.propertyPath + "([ =\)\,]|.{0}$)";
                            statement = statement.replace(new RegExp(expression, "gm"), "$1" + _this.escapeAlias(alias.name) + "." + _this.escapeColumn(column.databaseName) + "$2");
                            var expression2 = "([ =\(]|^.{0})" + alias.name + "\\." + column.propertyName + "([ =\)\,]|.{0}$)";
                            statement = statement.replace(new RegExp(expression2, "gm"), "$1" + _this.escapeAlias(alias.name) + "." + _this.escapeColumn(column.databaseName) + "$2");
                        });
                        alias.metadata.relations.forEach(function (relation) {
                            relation.joinColumns.concat(relation.inverseJoinColumns).forEach(function (joinColumn) {
                                var expression = "([ =\(]|^.{0})" + alias.name + "\\." + relation.propertyPath + "\\." + joinColumn.referencedColumn.propertyPath + "([ =\)\,]|.{0}$)";
                                statement = statement.replace(new RegExp(expression, "gm"), "$1" + _this.escapeAlias(alias.name) + "." + _this.escapeColumn(joinColumn.databaseName) + "$2"); // todo: fix relation.joinColumns[0], what if multiple columns
                            });
                            if (relation.joinColumns.length > 0) {
                                var expression = "([ =\(]|^.{0})" + alias.name + "\\." + relation.propertyPath + "([ =\)\,]|.{0}$)";
                                statement = statement.replace(new RegExp(expression, "gm"), "$1" + _this.escapeAlias(alias.name) + "." + _this.escapeColumn(relation.joinColumns[0].databaseName) + "$2"); // todo: fix relation.joinColumns[0], what if multiple columns
                            }
                        });
                    });
                    return statement;
                };
                QueryBuilder.prototype.createJoinExpression = function () {
                    var _this = this;
                    // separate escaping functions are used to reduce code size and complexity below
                    var et = function (aliasName) { return _this.escapeTable(aliasName); };
                    var ea = function (aliasName) { return _this.escapeAlias(aliasName); };
                    var ec = function (aliasName) { return _this.escapeColumn(aliasName); };
                    // examples:
                    // select from owning side
                    // qb.select("post")
                    //     .leftJoinAndSelect("post.category", "category");
                    // select from non-owning side
                    // qb.select("category")
                    //     .leftJoinAndSelect("category.post", "post");
                    var joins = this.expressionMap.joinAttributes.map(function (joinAttr) {
                        var relation = joinAttr.relation;
                        var destinationTableName = joinAttr.tableName;
                        var destinationTableAlias = joinAttr.alias.name;
                        var appendedCondition = joinAttr.condition ? " AND (" + joinAttr.condition + ")" : "";
                        var parentAlias = joinAttr.parentAlias;
                        // if join was build without relation (e.g. without "post.category") then it means that we have direct
                        // table to join, without junction table involved. This means we simply join direct table.
                        if (!parentAlias || !relation)
                            return " " + joinAttr.direction + " JOIN " + et(destinationTableName) + " " + ea(destinationTableAlias) +
                                (joinAttr.condition ? " ON " + _this.replacePropertyNames(joinAttr.condition) : "");
                        // if real entity relation is involved
                        if (relation.isManyToOne || relation.isOneToOneOwner) {
                            // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`
                            var condition = relation.joinColumns.map(function (joinColumn) {
                                return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" +
                                    parentAlias + "." + relation.propertyPath + "." + joinColumn.referencedColumn.propertyPath;
                            }).join(" AND ");
                            return " " + joinAttr.direction + " JOIN " + et(destinationTableName) + " " + ea(destinationTableAlias) + " ON " + _this.replacePropertyNames(condition + appendedCondition);
                        }
                        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {
                            // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`
                            var condition = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                                return destinationTableAlias + "." + relation.inverseRelation.propertyPath + "." + joinColumn.referencedColumn.propertyPath + "=" +
                                    parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                            }).join(" AND ");
                            return " " + joinAttr.direction + " JOIN " + et(destinationTableName) + " " + ea(destinationTableAlias) + " ON " + _this.replacePropertyNames(condition + appendedCondition);
                        }
                        else {
                            var junctionTableName = relation.junctionEntityMetadata.tableName;
                            var junctionAlias_2 = joinAttr.junctionAlias;
                            var junctionCondition = "", destinationCondition = "";
                            if (relation.isOwning) {
                                junctionCondition = relation.joinColumns.map(function (joinColumn) {
                                    // `post_category`.`postId` = `post`.`id`
                                    return junctionAlias_2 + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                                }).join(" AND ");
                                destinationCondition = relation.inverseJoinColumns.map(function (joinColumn) {
                                    // `category`.`id` = `post_category`.`categoryId`
                                    return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias_2 + "." + joinColumn.propertyPath;
                                }).join(" AND ");
                            }
                            else {
                                junctionCondition = relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) {
                                    // `post_category`.`categoryId` = `category`.`id`
                                    return junctionAlias_2 + "." + joinColumn.propertyPath + "=" + parentAlias + "." + joinColumn.referencedColumn.propertyPath;
                                }).join(" AND ");
                                destinationCondition = relation.inverseRelation.joinColumns.map(function (joinColumn) {
                                    // `post`.`id` = `post_category`.`postId`
                                    return destinationTableAlias + "." + joinColumn.referencedColumn.propertyPath + "=" + junctionAlias_2 + "." + joinColumn.propertyPath;
                                }).join(" AND ");
                            }
                            return " " + joinAttr.direction + " JOIN " + et(junctionTableName) + " " + ea(junctionAlias_2) + " ON " + _this.replacePropertyNames(junctionCondition) +
                                " " + joinAttr.direction + " JOIN " + et(destinationTableName) + " " + ea(destinationTableAlias) + " ON " + _this.replacePropertyNames(destinationCondition + appendedCondition);
                        }
                    });
                    if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {
                        var metadata = this.expressionMap.mainAlias.metadata;
                        if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === "class-table" && metadata.parentIdColumns) {
                            var alias_2 = "parentIdColumn_" + metadata.parentEntityMetadata.tableName;
                            var condition = metadata.parentIdColumns.map(function (parentIdColumn) {
                                return _this.expressionMap.mainAlias.name + "." + parentIdColumn.databaseName + "=" + ea(alias_2) + "." + parentIdColumn.propertyName;
                            }).join(" AND ");
                            var join = " JOIN " + et(metadata.parentEntityMetadata.tableName) + " " + ea(alias_2) + " ON " + condition;
                            joins.push(join);
                        }
                    }
                    return joins.join(" ");
                };
                QueryBuilder.prototype.createGroupByExpression = function () {
                    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)
                        return "";
                    return " GROUP BY " + this.replacePropertyNames(this.expressionMap.groupBys.join(", "));
                };
                QueryBuilder.prototype.createOrderByCombinedWithSelectExpression = function (parentAlias) {
                    var _this = this;
                    // if table has a default order then apply it
                    var orderBys = this.expressionMap.orderBys;
                    if (!Object.keys(orderBys).length && this.expressionMap.mainAlias.hasMetadata) {
                        orderBys = this.expressionMap.mainAlias.metadata.orderBy || {};
                    }
                    var selectString = Object.keys(orderBys)
                        .map(function (columnName) {
                        var _a = columnName.split("."), alias = _a[0], column = _a[1], embeddedProperties = _a.slice(2);
                        return _this.escapeAlias(parentAlias) + "." + _this.escapeColumn(alias + "_" + column + embeddedProperties.join("_"));
                    })
                        .join(", ");
                    var orderByString = Object.keys(orderBys)
                        .map(function (columnName) {
                        var _a = columnName.split("."), alias = _a[0], column = _a[1], embeddedProperties = _a.slice(2);
                        return _this.escapeAlias(parentAlias) + "." + _this.escapeColumn(alias + "_" + column + embeddedProperties.join("_")) + " " + _this.expressionMap.orderBys[columnName];
                    })
                        .join(", ");
                    return [selectString, orderByString];
                };
                QueryBuilder.prototype.createOrderByExpression = function () {
                    var _this = this;
                    var orderBys = this.expressionMap.orderBys;
                    // if table has a default order then apply it
                    if (!Object.keys(orderBys).length && this.expressionMap.mainAlias.hasMetadata) {
                        orderBys = this.expressionMap.mainAlias.metadata.orderBy || {};
                    }
                    // if user specified a custom order then apply it
                    if (Object.keys(orderBys).length > 0)
                        return " ORDER BY " + Object.keys(orderBys)
                            .map(function (columnName) {
                            return _this.replacePropertyNames(columnName) + " " + _this.expressionMap.orderBys[columnName];
                        })
                            .join(", ");
                    return "";
                };
                QueryBuilder.prototype.createLimitExpression = function () {
                    if (!this.expressionMap.limit || this.connection.driver instanceof OracleDriver_1.OracleDriver)
                        return "";
                    return " LIMIT " + this.expressionMap.limit;
                };
                QueryBuilder.prototype.createOffsetExpression = function () {
                    if (!this.expressionMap.offset || this.connection.driver instanceof OracleDriver_1.OracleDriver)
                        return "";
                    return " OFFSET " + this.expressionMap.offset;
                };
                QueryBuilder.prototype.createLockExpression = function () {
                    switch (this.expressionMap.lockMode) {
                        case "pessimistic_read":
                            if (this.connection.driver instanceof MysqlDriver_1.MysqlDriver) {
                                return " LOCK IN SHARE MODE";
                            }
                            else if (this.connection.driver instanceof PostgresDriver_1.PostgresDriver) {
                                return " FOR SHARE";
                            }
                            else if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                                return "";
                            }
                            else {
                                throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                            }
                        case "pessimistic_write":
                            if (this.connection.driver instanceof MysqlDriver_1.MysqlDriver || this.connection.driver instanceof PostgresDriver_1.PostgresDriver) {
                                return " FOR UPDATE";
                            }
                            else if (this.connection.driver instanceof SqlServerDriver_1.SqlServerDriver) {
                                return "";
                            }
                            else {
                                throw new LockNotSupportedOnGivenDriverError_1.LockNotSupportedOnGivenDriverError();
                            }
                        default:
                            return "";
                    }
                };
                /**
                 * Creates "WHERE" expression and variables for the given "ids".
                 */
                QueryBuilder.prototype.createWhereIdsExpression = function (ids) {
                    var _this = this;
                    var metadata = this.expressionMap.mainAlias.metadata;
                    // create shortcuts for better readability
                    var ea = function (aliasName) { return _this.escapeAlias(aliasName); };
                    var ec = function (columnName) { return _this.escapeColumn(columnName); };
                    var alias = this.expressionMap.mainAlias.name;
                    var parameters = {};
                    var whereStrings = ids.map(function (id, index) {
                        var whereSubStrings = [];
                        // if (metadata.hasMultiplePrimaryKeys) {
                        metadata.primaryColumns.forEach(function (primaryColumn, secondIndex) {
                            whereSubStrings.push(ea(alias) + "." + ec(primaryColumn.databaseName) + "=:id_" + index + "_" + secondIndex);
                            parameters["id_" + index + "_" + secondIndex] = primaryColumn.getEntityValue(id);
                        });
                        metadata.parentIdColumns.forEach(function (primaryColumn, secondIndex) {
                            whereSubStrings.push(ea(alias) + "." + ec(id[primaryColumn.databaseName]) + "=:parentId_" + index + "_" + secondIndex);
                            parameters["parentId_" + index + "_" + secondIndex] = primaryColumn.getEntityValue(id);
                        });
                        // } else {
                        //     if (metadata.primaryColumns.length > 0) {
                        //         whereSubStrings.push(ea(alias) + "." + ec(metadata.firstPrimaryColumn.fullName) + "=:id_" + index);
                        //         parameters["id_" + index] = id;
                        //
                        //     } else if (metadata.parentIdColumns.length > 0) {
                        //         whereSubStrings.push(ea(alias) + "." + ec(metadata.parentIdColumns[0].fullName) + "=:parentId_" + index);
                        //         parameters["parentId_" + index] = id;
                        //     }
                        // }
                        return whereSubStrings.join(" AND ");
                    });
                    var whereString = whereStrings.length > 1 ? "(" + whereStrings.join(" OR ") + ")" : whereStrings[0];
                    return [whereString, parameters];
                };
                QueryBuilder.prototype.getQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.queryRunnerProvider instanceof QueryRunnerProvider_1.QueryRunnerProvider) {
                                return [2 /*return*/, this.queryRunnerProvider.provide()];
                            }
                            else {
                                return [2 /*return*/, this.connection.driver.createQueryRunner()];
                            }
                            return [2 /*return*/];
                        });
                    });
                };
                QueryBuilder.prototype.hasOwnQueryRunner = function () {
                    return !this.queryRunnerProvider;
                };
                return QueryBuilder;
            }());
            exports_62("QueryBuilder", QueryBuilder);
        }
    };
});
System.register("typeorm/metadata-args/RelationIdMetadataArgs", [], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationIdMetadata", [], function (exports_64, context_64) {
    "use strict";
    var __moduleName = context_64 && context_64.id;
    var RelationIdMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's relation count.
             */
            RelationIdMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationIdMetadata(options) {
                    this.entityMetadata = options.entityMetadata;
                    this.target = options.args.target;
                    this.propertyName = options.args.propertyName;
                    this.relationNameOrFactory = options.args.relation;
                    this.alias = options.args.alias;
                    this.queryBuilderFactory = options.args.queryBuilderFactory;
                }
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation id properties.
                 * This builder method should be used only after entity metadata, its properties map and all relations are build.
                 */
                RelationIdMetadata.prototype.build = function () {
                    var propertyPath = this.relationNameOrFactory instanceof Function ? this.relationNameOrFactory(this.entityMetadata.propertiesMap) : this.relationNameOrFactory;
                    var relation = this.entityMetadata.findRelationWithPropertyPath(propertyPath);
                    if (!relation)
                        throw new Error("Cannot find relation " + propertyPath + ". Wrong relation specified for @RelationId decorator.");
                    this.relation = relation;
                };
                return RelationIdMetadata;
            }());
            exports_64("RelationIdMetadata", RelationIdMetadata);
        }
    };
});
System.register("typeorm/metadata/EmbeddedMetadata", [], function (exports_65, context_65) {
    "use strict";
    var __moduleName = context_65 && context_65.id;
    var EmbeddedMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about entity's embedded property.
             */
            EmbeddedMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EmbeddedMetadata(options) {
                    /**
                     * Columns inside this embed.
                     */
                    this.columns = [];
                    /**
                     * Relations inside this embed.
                     */
                    this.relations = [];
                    /**
                     * Nested embeddable in this embeddable (which has current embedded as parent embedded).
                     */
                    this.embeddeds = [];
                    /**
                     * Indicates if this embedded is in array mode.
                     *
                     * This option works only in monogodb.
                     */
                    this.isArray = false;
                    /**
                     * Returns array of property names of current embed and all its parent embeds.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * we need to get value of "id" column from the post real entity object.
                     * this method will return ["data", "information", "counters"]
                     */
                    this.parentPropertyNames = [];
                    /**
                     * Returns embed metadatas from all levels of the parent tree.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
                     */
                    this.embeddedMetadataTree = [];
                    /**
                     * Embed metadatas from all levels of the parent tree.
                     *
                     * example: post[data][information][counters].id where "data", "information" and "counters" are embeds
                     * this method will return [embed metadata of data, embed metadata of information, embed metadata of counters]
                     */
                    this.columnsFromTree = [];
                    /**
                     * Relations of this embed and all relations from its child embeds.
                     */
                    this.relationsFromTree = [];
                    /**
                     * Relation ids of this embed and all relation ids from its child embeds.
                     */
                    this.relationIdsFromTree = [];
                    /**
                     * Relation counts of this embed and all relation counts from its child embeds.
                     */
                    this.relationCountsFromTree = [];
                    this.entityMetadata = options.entityMetadata;
                    this.type = options.args.type();
                    this.propertyName = options.args.propertyName;
                    this.customPrefix = options.args.prefix;
                    this.isArray = options.args.isArray;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Creates a new embedded object.
                 */
                EmbeddedMetadata.prototype.create = function () {
                    return new this.type;
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                EmbeddedMetadata.prototype.build = function (namingStrategy) {
                    this.embeddeds.forEach(function (embedded) { return embedded.build(namingStrategy); });
                    this.prefix = this.buildPrefix();
                    this.parentPropertyNames = this.buildParentPropertyNames();
                    this.embeddedMetadataTree = this.buildEmbeddedMetadataTree();
                    this.columnsFromTree = this.buildColumnsFromTree();
                    this.relationsFromTree = this.buildRelationsFromTree();
                    return this;
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                EmbeddedMetadata.prototype.buildPrefix = function () {
                    var prefixes = [];
                    if (this.parentEmbeddedMetadata)
                        prefixes.push(this.parentEmbeddedMetadata.buildPrefix());
                    if (this.customPrefix === undefined) {
                        prefixes.push(this.propertyName);
                    }
                    else if (typeof this.customPrefix === "string") {
                        prefixes.push(this.customPrefix);
                    }
                    return prefixes.join("_"); // todo: use naming strategy instead of "_"  !!!
                };
                EmbeddedMetadata.prototype.buildParentPropertyNames = function () {
                    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildParentPropertyNames().concat(this.propertyName) : [this.propertyName];
                };
                EmbeddedMetadata.prototype.buildEmbeddedMetadataTree = function () {
                    return this.parentEmbeddedMetadata ? this.parentEmbeddedMetadata.buildEmbeddedMetadataTree().concat(this) : [this];
                };
                EmbeddedMetadata.prototype.buildColumnsFromTree = function () {
                    return this.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.buildColumnsFromTree()); }, this.columns);
                };
                EmbeddedMetadata.prototype.buildRelationsFromTree = function () {
                    return this.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.buildRelationsFromTree()); }, this.relations);
                };
                return EmbeddedMetadata;
            }());
            exports_65("EmbeddedMetadata", EmbeddedMetadata);
        }
    };
});
System.register("typeorm/decorator/options/RelationOptions", [], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/PropertyTypeInFunction", [], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/RelationTypeInFunction", [], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/RelationMetadataArgs", [], function (exports_69, context_69) {
    "use strict";
    var __moduleName = context_69 && context_69.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/RelationMetadata", [], function (exports_70, context_70) {
    "use strict";
    var __moduleName = context_70 && context_70.id;
    var RelationMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * Contains all information about some entity's relation.
             */
            RelationMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function RelationMetadata(options) {
                    /**
                     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.
                     */
                    this.isTreeParent = false;
                    /**
                     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.
                     */
                    this.isTreeChildren = false;
                    /**
                     * Indicates if this relation's column is a primary key.
                     * Can be used only for many-to-one and owner one-to-one relations.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if this relation is lazily loaded.
                     */
                    this.isLazy = false;
                    /**
                     * If set to true then related objects are allowed to be inserted to the database.
                     */
                    this.isCascadeInsert = false;
                    /**
                     * If set to true then related objects are allowed to be updated in the database.
                     */
                    this.isCascadeUpdate = false;
                    /**
                     * If set to true then related objects are allowed to be remove from the database.
                     */
                    this.isCascadeRemove = false;
                    /**
                     * Indicates if relation column value can be nullable or not.
                     */
                    this.isNullable = true;
                    /**
                     * Indicates if this side is an owner of this relation.
                     */
                    this.isOwning = false;
                    /**
                     * Checks if this relation's type is "one-to-one".
                     */
                    this.isOneToOne = false;
                    /**
                     * Checks if this relation is owner side of the "one-to-one" relation.
                     * Owner side means this side of relation has a join column in the table.
                     */
                    this.isOneToOneOwner = false;
                    /**
                     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).
                     */
                    this.isWithJoinColumn = false;
                    /**
                     * Checks if this relation is NOT owner side of the "one-to-one" relation.
                     * NOT owner side means this side of relation does not have a join column in the table.
                     */
                    this.isOneToOneNotOwner = false;
                    /**
                     * Checks if this relation's type is "one-to-many".
                     */
                    this.isOneToMany = false;
                    /**
                     * Checks if this relation's type is "many-to-one".
                     */
                    this.isManyToOne = false;
                    /**
                     * Checks if this relation's type is "many-to-many".
                     */
                    this.isManyToMany = false;
                    /**
                     * Checks if this relation's type is "many-to-many", and is owner side of the relationship.
                     * Owner side means this side of relation has a join table.
                     */
                    this.isManyToManyOwner = false;
                    /**
                     * Checks if this relation's type is "many-to-many", and is NOT owner side of the relationship.
                     * Not owner side means this side of relation does not have a join table.
                     */
                    this.isManyToManyNotOwner = false;
                    /**
                     * Foreign keys created for this relation.
                     */
                    this.foreignKeys = [];
                    /**
                     * Join table columns.
                     * Join columns can be obtained only from owner side of the relation.
                     * From non-owner side of the relation join columns will be empty.
                     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.
                     * If this relation is many-to-many then it takes all owner join columns from the junction entity.
                     */
                    this.joinColumns = [];
                    /**
                     * Inverse join table columns.
                     * Inverse join columns are supported only for many-to-many relations
                     * and can be obtained only from owner side of the relation.
                     * From non-owner side of the relation join columns will be undefined.
                     */
                    this.inverseJoinColumns = [];
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    var args = options.args;
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.relationType = args.relationType;
                    if (args.inverseSideProperty)
                        this.givenInverseSidePropertyFactory = args.inverseSideProperty;
                    this.isLazy = args.isLazy || false;
                    this.isCascadeInsert = args.options.cascadeInsert || args.options.cascadeAll || false;
                    this.isCascadeUpdate = args.options.cascadeUpdate || args.options.cascadeAll || false;
                    this.isCascadeRemove = args.options.cascadeRemove || args.options.cascadeAll || false;
                    this.isNullable = args.options.nullable !== false;
                    this.onDelete = args.options.onDelete;
                    this.isPrimary = args.options.primary || false;
                    this.isTreeParent = args.isTreeParent || false;
                    this.isTreeChildren = args.isTreeChildren || false;
                    this.type = args.type instanceof Function ? args.type() : args.type;
                    this.isOneToOne = this.relationType === "one-to-one";
                    this.isOneToMany = this.relationType === "one-to-many";
                    this.isManyToOne = this.relationType === "many-to-one";
                    this.isManyToMany = this.relationType === "many-to-many";
                    this.isOneToOneNotOwner = this.isOneToOne ? true : false;
                    this.isManyToManyNotOwner = this.isManyToMany ? true : false;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Extracts column value from the given entity.
                 * If column is in embedded (or recursive embedded) it extracts its value from there.
                 */
                RelationMetadata.prototype.getEntityValue = function (entity) {
                    // extract column value from embeddeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
                        // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
                        var extractEmbeddedColumnValue_1 = function (propertyNames, value) {
                            var propertyName = propertyNames.shift();
                            return propertyName ? extractEmbeddedColumnValue_1(propertyNames, value[propertyName]) : value;
                        };
                        // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
                        var embeddedObject = extractEmbeddedColumnValue_1(propertyNames, entity);
                        return embeddedObject ? embeddedObject[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName] : undefined;
                    }
                    else {
                        return entity[this.isLazy ? "__" + this.propertyName + "__" : this.propertyName];
                    }
                };
                /**
                 * Sets given entity's relation's value.
                 * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
                 */
                RelationMetadata.prototype.setEntityValue = function (entity, value) {
                    var propertyName = this.isLazy ? "__" + this.propertyName + "__" : this.propertyName;
                    if (this.embeddedMetadata) {
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var extractEmbeddedColumnValue_2 = function (embeddedMetadatas, map) {
                            // if (!object[embeddedMetadata.propertyName])
                            //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                            var embeddedMetadata = embeddedMetadatas.shift();
                            if (embeddedMetadata) {
                                if (!map[embeddedMetadata.propertyName])
                                    map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                                extractEmbeddedColumnValue_2(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                                return map;
                            }
                            map[propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_2(this.embeddedMetadata.embeddedMetadataTree.slice(), entity);
                    }
                    else {
                        entity[propertyName] = value;
                    }
                };
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                RelationMetadata.prototype.createValueMap = function (value) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_3 = function (propertyNames, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_3(propertyNames, map[propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_3(propertyNames, {});
                    }
                    else {
                        return _a = {}, _a[this.propertyName] = value, _a;
                    }
                    var _a;
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Builds some depend relation metadata properties.
                 * This builder method should be used only after embedded metadata tree was build.
                 */
                RelationMetadata.prototype.build = function () {
                    this.propertyPath = this.buildPropertyPath();
                };
                /**
                 * Registers given foreign keys in the relation.
                 * This builder method should be used to register foreign key in the relation.
                 */
                RelationMetadata.prototype.registerForeignKeys = function () {
                    var foreignKeys = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        foreignKeys[_i] = arguments[_i];
                    }
                    (_a = this.foreignKeys).push.apply(_a, foreignKeys);
                    this.joinColumns = this.foreignKeys[0] ? this.foreignKeys[0].columns : [];
                    this.inverseJoinColumns = this.foreignKeys[1] ? this.foreignKeys[1].columns : [];
                    this.isOwning = this.isManyToOne || ((this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0);
                    this.isOneToOneOwner = this.isOneToOne && this.isOwning;
                    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;
                    this.isManyToManyOwner = this.isManyToMany && this.isOwning;
                    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;
                    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;
                    var _a;
                };
                /**
                 * Registers a given junction entity metadata.
                 * This builder method can be called after junction entity metadata for the many-to-many relation was created.
                 */
                RelationMetadata.prototype.registerJunctionEntityMetadata = function (junctionEntityMetadata) {
                    this.junctionEntityMetadata = junctionEntityMetadata;
                    this.joinTableName = junctionEntityMetadata.tableName;
                    if (this.inverseRelation) {
                        this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;
                        this.joinTableName = junctionEntityMetadata.tableName;
                    }
                };
                /**
                 * Builds inverse side property path based on given inverse side property factory.
                 * This builder method should be used only after properties map of the inverse entity metadata was build.
                 */
                RelationMetadata.prototype.buildInverseSidePropertyPath = function () {
                    if (this.givenInverseSidePropertyFactory) {
                        var ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;
                        if (typeof this.givenInverseSidePropertyFactory === "function")
                            return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);
                        if (typeof this.givenInverseSidePropertyFactory === "string")
                            return this.givenInverseSidePropertyFactory;
                    }
                    else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {
                        return this.entityMetadata.treeChildrenRelation.propertyName;
                    }
                    else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {
                        return this.entityMetadata.treeParentRelation.propertyName;
                    }
                    return "";
                };
                /**
                 * Builds relation's property path based on its embedded tree.
                 */
                RelationMetadata.prototype.buildPropertyPath = function () {
                    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length)
                        return this.propertyName;
                    return this.embeddedMetadata.parentPropertyNames.join(".") + "." + this.propertyName;
                };
                return RelationMetadata;
            }());
            exports_70("RelationMetadata", RelationMetadata);
        }
    };
});
System.register("typeorm/metadata/types/TableTypes", [], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    var TableTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents a class with constants - list of all possible table types.
             *
             * todo: remove if only regular table will left here
             */
            TableTypes = (function () {
                function TableTypes() {
                }
                return TableTypes;
            }());
            /**
             * All non-specific tables are just regular tables. Its a default table type.
             */
            TableTypes.REGULAR = "regular";
            /**
             * This type is for the tables that does not exist in the database,
             * but provide columns and relations for the tables of the child classes who inherit them.
             *
             * @deprecated
             */
            TableTypes.ABSTRACT = "abstract";
            /**
             * Junction table is a table automatically created by many-to-many relationship.
             *
             * todo: remove and isJunction condition is enough in entity metadata?
             */
            TableTypes.JUNCTION = "junction";
            /**
             * Closure table is one of the tree-specific tables that supports closure database pattern.
             *
             * todo: maybe we can determine if it is closure if it has some closure-specific decorator?
             * todo: or if its not possible then maybe create a separate decorator for closure?
             */
            TableTypes.CLOSURE = "closure";
            /**
             * This type is for tables that contain junction metadata of the closure tables.
             *
             * todo: remove and isClosureJunction condition is enough in entity metadata?
             */
            TableTypes.CLOSURE_JUNCTION = "closure-junction";
            /**
             * Embeddable tables are not stored in the database as separate tables.
             * Instead their columns are embed into tables who owns them.
             *
             * @deprecated
             */
            TableTypes.EMBEDDABLE = "embeddable";
            /**
             * Special table type for tables that are mapped into single table using Single Table Inheritance pattern.
             *
             * todo: create separate decorators?
             */
            TableTypes.SINGLE_TABLE_CHILD = "single-table-child";
            /**
             * Special table type for tables that are mapped into multiple tables using Class Table Inheritance pattern.
             *
             * todo: create separate decorators?
             */
            TableTypes.CLASS_TABLE_CHILD = "class-table-child";
            exports_71("TableTypes", TableTypes);
        }
    };
});
System.register("typeorm/metadata-args/TableMetadataArgs", [], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/types/EventListenerTypes", [], function (exports_73, context_73) {
    "use strict";
    var __moduleName = context_73 && context_73.id;
    var EventListenerTypes;
    return {
        setters: [],
        execute: function () {
            /**
             * Provides a constants for each entity listener type.
             */
            EventListenerTypes = (function () {
                function EventListenerTypes() {
                }
                return EventListenerTypes;
            }());
            EventListenerTypes.AFTER_LOAD = "after-load";
            EventListenerTypes.BEFORE_INSERT = "before-insert";
            EventListenerTypes.AFTER_INSERT = "after-insert";
            EventListenerTypes.BEFORE_UPDATE = "before-update";
            EventListenerTypes.AFTER_UPDATE = "after-update";
            EventListenerTypes.BEFORE_REMOVE = "before-remove";
            EventListenerTypes.AFTER_REMOVE = "after-remove";
            exports_73("EventListenerTypes", EventListenerTypes);
        }
    };
});
System.register("typeorm/metadata-args/EntityListenerMetadataArgs", [], function (exports_74, context_74) {
    "use strict";
    var __moduleName = context_74 && context_74.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/EntityListenerMetadata", [], function (exports_75, context_75) {
    "use strict";
    var __moduleName = context_75 && context_75.id;
    var EntityListenerMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * This metadata contains all information about entity's listeners.
             */
            EntityListenerMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EntityListenerMetadata(args) {
                    this.target = args.target;
                    this.propertyName = args.propertyName;
                    this.type = args.type;
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Checks if entity listener is allowed to be executed on the given entity.
                 */
                EntityListenerMetadata.prototype.isAllowed = function (entity) {
                    return this.target === entity.constructor ||
                        (this.target instanceof Function && entity.constructor.prototype instanceof this.target); // todo: also need to implement entity schema inheritance
                };
                return EntityListenerMetadata;
            }());
            exports_75("EntityListenerMetadata", EntityListenerMetadata);
        }
    };
});
System.register("typeorm/metadata/EntityMetadata", ["typeorm/util/OrmUtils"], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    var OrmUtils_2, EntityMetadata;
    return {
        setters: [
            function (OrmUtils_2_1) {
                OrmUtils_2 = OrmUtils_2_1;
            }
        ],
        execute: function () {
            /**
             * Contains all entity metadata.
             */
            EntityMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function EntityMetadata(options) {
                    /**
                     * Children entity metadatas. Used in inheritance patterns.
                     */
                    this.childEntityMetadatas = [];
                    /**
                     * Table type. Tables can be abstract, closure, junction, embedded, etc.
                     */
                    this.tableType = "regular";
                    /**
                     * Indicates if this entity metadata of a junction table, or not.
                     * Junction table is a table created by many-to-many relationship.
                     *
                     * Its also possible to understand if entity is junction via tableType.
                     */
                    this.isJunction = false;
                    /**
                     * Entity's column metadatas defined by user.
                     */
                    this.ownColumns = [];
                    /**
                     * Entity's relation metadatas.
                     */
                    this.ownRelations = [];
                    /**
                     * Relations of the entity, including relations that are coming from the embeddeds of this entity.
                     */
                    this.relations = [];
                    /**
                     * Columns of the entity, including columns that are coming from the embeddeds of this entity.
                     */
                    this.columns = [];
                    /**
                     * Entity's relation id metadatas.
                     */
                    this.relationIds = [];
                    /**
                     * Entity's relation id metadatas.
                     */
                    this.relationCounts = [];
                    /**
                     * Entity's index metadatas.
                     */
                    this.indices = [];
                    /**
                     * Entity's foreign key metadatas.
                     */
                    this.foreignKeys = [];
                    /**
                     * Entity's embedded metadatas.
                     */
                    this.embeddeds = [];
                    /**
                     * Entity listener metadatas.
                     */
                    this.listeners = [];
                    /**
                     * Gets the primary columns.
                     */
                    this.primaryColumns = [];
                    /**
                     * Id columns in the parent table (used in table inheritance).
                     */
                    this.parentIdColumns = [];
                    /**
                     * Gets only one-to-one relations of the entity.
                     */
                    this.oneToOneRelations = [];
                    /**
                     * Gets only owner one-to-one relations of the entity.
                     */
                    this.ownerOneToOneRelations = [];
                    /**
                     * Gets only one-to-many relations of the entity.
                     */
                    this.oneToManyRelations = [];
                    /**
                     * Gets only many-to-one relations of the entity.
                     */
                    this.manyToOneRelations = [];
                    /**
                     * Gets only many-to-many relations of the entity.
                     */
                    this.manyToManyRelations = [];
                    /**
                     * Gets only owner many-to-many relations of the entity.
                     */
                    this.ownerManyToManyRelations = [];
                    /**
                     * Gets only owner one-to-one and many-to-one relations.
                     */
                    this.relationsWithJoinColumns = [];
                    var namingStrategy = options.connection.driver.namingStrategy;
                    var tablesPrefix = options.connection.driver.options.tablesPrefix;
                    this.lazyRelationsWrapper = options.connection.driver.lazyRelationsWrapper;
                    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;
                    this.target = options.args.target;
                    this.tableType = options.args.type;
                    this.engine = options.args.engine;
                    this.givenTableName = options.args.name;
                    this.skipSchemaSync = options.args.skipSchemaSync || false;
                    this.targetName = options.args.target instanceof Function ? options.args.target.name : options.args.target;
                    this.tableNameWithoutPrefix = this.tableType === "closure-junction" ? namingStrategy.closureJunctionTableName(this.givenTableName) : namingStrategy.tableName(this.targetName, this.givenTableName);
                    this.tableName = tablesPrefix ? namingStrategy.prefixTableName(tablesPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;
                    this.target = this.target ? this.target : this.tableName;
                    this.name = this.targetName ? this.targetName : this.tableName;
                    this.isClassTableChild = this.tableType === "class-table-child";
                    this.isSingleTableChild = this.tableType === "single-table-child";
                    this.isEmbeddable = this.tableType === "embeddable";
                    this.isJunction = this.tableType === "closure-junction" || this.tableType === "junction";
                    this.isClosureJunction = this.tableType === "closure-junction";
                    this.isClosure = this.tableType === "closure";
                    this.isAbstract = this.tableType === "abstract";
                    this.isRegular = this.tableType === "regular";
                    this.orderBy = (options.args.orderBy instanceof Function) ? options.args.orderBy(this.propertiesMap) : options.args.orderBy;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new entity.
                 */
                EntityMetadata.prototype.create = function () {
                    var _this = this;
                    // if target is set to a function (e.g. class) that can be created then create it
                    if (this.target instanceof Function)
                        return new this.target();
                    // otherwise simply return a new empty object
                    var newObject = {};
                    this.relations
                        .filter(function (relation) { return relation.isLazy; })
                        .forEach(function (relation) { return _this.lazyRelationsWrapper.wrap(newObject, relation); });
                    return newObject;
                };
                /**
                 * Checks if given entity has an id.
                 */
                EntityMetadata.prototype.hasId = function (entity) {
                    if (!entity)
                        return false;
                    return this.primaryColumns.every(function (primaryColumn) {
                        var value = primaryColumn.getEntityValue(entity);
                        return value !== null && value !== undefined && value !== "";
                    });
                };
                /**
                 * Compares ids of the two entities.
                 * Returns true if they match, false otherwise.
                 */
                EntityMetadata.prototype.compareIds = function (firstId, secondId) {
                    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)
                        return false;
                    return OrmUtils_2.OrmUtils.deepCompare(firstId, secondId);
                };
                /**
                 * Compares two different entity instances by their ids.
                 * Returns true if they match, false otherwise.
                 */
                EntityMetadata.prototype.compareEntities = function (firstEntity, secondEntity) {
                    // if any entity ids are empty then they aren't equal
                    var isFirstEntityEmpty = this.isEntityMapEmpty(firstEntity);
                    var isSecondEntityEmpty = this.isEntityMapEmpty(secondEntity);
                    if (isFirstEntityEmpty || isSecondEntityEmpty)
                        return false;
                    var firstEntityIds = this.getEntityIdMap(firstEntity);
                    var secondEntityIds = this.getEntityIdMap(secondEntity);
                    return this.compareIds(firstEntityIds, secondEntityIds);
                };
                /**
                 * Finds relation with the given name.
                 */
                EntityMetadata.prototype.findRelationWithDbName = function (dbName) {
                    return this.relationsWithJoinColumns.find(function (relation) {
                        return !!relation.joinColumns.find(function (column) { return column.databaseName === dbName; });
                    });
                };
                /**
                 * Finds relation with the given property path.
                 */
                EntityMetadata.prototype.findRelationWithPropertyPath = function (propertyPath) {
                    return this.relations.find(function (relation) { return relation.propertyPath === propertyPath; });
                };
                /**
                 * Computes property name of the entity using given PropertyTypeInFunction.
                 */
                EntityMetadata.prototype.computePropertyPath = function (nameOrFn) {
                    return typeof nameOrFn === "string" ? nameOrFn : nameOrFn(this.propertiesMap);
                };
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                EntityMetadata.prototype.createEntityIdMap = function (ids) {
                    var primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;
                    return primaryColumns.reduce(function (map, column, index) { return Object.assign(map, column.createValueMap(ids[index])); }, {});
                };
                /**
                 * Checks each id in the given entity id map if they all aren't empty.
                 * If they all aren't empty it returns true.
                 * If at least one id in the given map is empty it returns false.
                 */
                EntityMetadata.prototype.isEntityMapEmpty = function (entity) {
                    var primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;
                    return !primaryColumns.every(function (column) {
                        var value = column.getEntityValue(entity);
                        return value !== null && value !== undefined;
                    });
                };
                /**
                 * Gets primary keys of the entity and returns them in a literal object.
                 * For example, for Post{ id: 1, title: "hello" } where id is primary it will return { id: 1 }
                 * For multiple primary keys it returns multiple keys in object.
                 * For primary keys inside embeds it returns complex object literal with keys in them.
                 */
                EntityMetadata.prototype.getEntityIdMap = function (entity) {
                    if (!entity)
                        return undefined;
                    var primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;
                    var map = primaryColumns.reduce(function (map, column) {
                        if (column.isObjectId)
                            return Object.assign(map, column.getEntityValueMap(entity));
                        return OrmUtils_2.OrmUtils.mergeDeep(map, column.getEntityValueMap(entity));
                    }, {});
                    return Object.keys(map).length > 0 ? map : undefined;
                };
                /**
                 * Same as getEntityIdMap, but instead of id column property names it returns database column names.
                 */
                EntityMetadata.prototype.getDatabaseEntityIdMap = function (entity) {
                    var map = {};
                    var primaryColumns = this.parentEntityMetadata ? this.primaryColumns : this.primaryColumns;
                    primaryColumns.forEach(function (column) {
                        var entityValue = column.getEntityValue(entity);
                        if (entityValue === null || entityValue === undefined)
                            return;
                        map[column.databaseName] = entityValue;
                    });
                    var hasAllIds = Object.keys(map).every(function (key) {
                        return map[key] !== undefined && map[key] !== null;
                    });
                    return hasAllIds ? map : undefined;
                };
                /**
                 * Creates a "mixed id map".
                 * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.
                 * But if entity has a single primary key then it will return just value of the id column of the entity, just value.
                 * This is called mixed id map.
                 */
                EntityMetadata.prototype.getEntityIdMixedMap = function (entity) {
                    if (!entity)
                        return undefined;
                    var idMap = this.getEntityIdMap(entity);
                    if (this.hasMultiplePrimaryKeys) {
                        return idMap;
                    }
                    else if (idMap) {
                        return idMap[this.primaryColumns[0].propertyName]; // todo: what about parent primary column?
                    }
                    return idMap;
                };
                /**
                 * Checks if given object contains ALL primary keys entity must have.
                 * Returns true if it contains all of them, false if at least one of them is not defined.
                 */
                EntityMetadata.prototype.checkIfObjectContainsAllPrimaryKeys = function (object) {
                    return this.primaryColumns.every(function (primaryColumn) {
                        return object.hasOwnProperty(primaryColumn.propertyName);
                    });
                };
                /**
                 * Iterates throw entity and finds and extracts all values from relations in the entity.
                 * If relation value is an array its being flattened.
                 */
                EntityMetadata.prototype.extractRelationValuesFromEntity = function (entity, relations) {
                    var relationsAndValues = [];
                    relations.forEach(function (relation) {
                        var value = relation.getEntityValue(entity);
                        if (value instanceof Array) {
                            value.forEach(function (subValue) { return relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]); });
                        }
                        else if (value) {
                            relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);
                        }
                    });
                    return relationsAndValues;
                };
                // ---------------------------------------------------------------------
                // Public Builder Methods
                // ---------------------------------------------------------------------
                /**
                 * Registers a new column in the entity and recomputes all depend properties.
                 */
                EntityMetadata.prototype.registerColumn = function (column) {
                    this.ownColumns.push(column);
                    this.columns = this.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.columnsFromTree); }, this.ownColumns);
                    this.primaryColumns = this.columns.filter(function (column) { return column.isPrimary; });
                    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;
                    this.propertiesMap = this.createPropertiesMap();
                };
                /**
                 * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)
                 * in a special format - { propertyName: propertyName }.
                 *
                 * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.
                 * This method will create following object:
                 * { id: "id", counterEmbed: { count: "counterEmbed.count" }, category: "category" }
                 */
                EntityMetadata.prototype.createPropertiesMap = function () {
                    var map = {};
                    this.columns.forEach(function (column) { return OrmUtils_2.OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)); });
                    this.relations.forEach(function (relation) { return OrmUtils_2.OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)); });
                    return map;
                };
                return EntityMetadata;
            }());
            exports_76("EntityMetadata", EntityMetadata);
        }
    };
});
System.register("typeorm/decorator/options/ColumnOptions", [], function (exports_77, context_77) {
    "use strict";
    var __moduleName = context_77 && context_77.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/types/ColumnMode", [], function (exports_78, context_78) {
    "use strict";
    var __moduleName = context_78 && context_78.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/ColumnMetadataArgs", [], function (exports_79, context_79) {
    "use strict";
    var __moduleName = context_79 && context_79.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata/ColumnMetadata", [], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    var ColumnMetadata;
    return {
        setters: [],
        execute: function () {
            /**
             * This metadata contains all information about entity's column.
             */
            ColumnMetadata = (function () {
                // ---------------------------------------------------------------------
                // Constructor
                // ---------------------------------------------------------------------
                function ColumnMetadata(options) {
                    /**
                     * Type's length in the database.
                     */
                    this.length = "";
                    /**
                     * Indicates if this column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if this column is generated (auto increment or generated other way).
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if column value in the database should be unique or not.
                     */
                    this.isUnique = false;
                    /**
                     * Indicates if column can contain nulls or not.
                     */
                    this.isNullable = false;
                    /**
                     * Column comment.
                     * This feature is not supported by all databases.
                     */
                    this.comment = "";
                    /**
                     * Indicates if date column will contain a timezone.
                     * Used only for date-typed column types.
                     * Note that timezone option is not supported by all databases (only postgres for now).
                     */
                    this.timezone = false;
                    /**
                     * Indicates if date object must be stored in given date's timezone.
                     * By default date is saved in UTC timezone.
                     * Works only with "datetime" columns.
                     */
                    this.localTimezone = false;
                    /**
                     * Indicates if column's type will be set as a fixed-length data type.
                     * Works only with "string" columns.
                     */
                    this.fixedLength = false;
                    /**
                     * Indicates if column is virtual. Virtual columns are not mapped to the entity.
                     */
                    this.isVirtual = false;
                    /**
                     * Indicates if column is a parent id. Parent id columns are not mapped to the entity.
                     */
                    this.isParentId = false;
                    /**
                     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.
                     */
                    this.isDiscriminator = false;
                    /**
                     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.
                     */
                    this.isTreeLevel = false;
                    /**
                     * Indicates if this column contains an entity creation date.
                     */
                    this.isCreateDate = false;
                    /**
                     * Indicates if this column contains an entity update date.
                     */
                    this.isUpdateDate = false;
                    /**
                     * Indicates if this column contains an entity version.
                     */
                    this.isVersion = false;
                    /**
                     * Indicates if this column contains an object id.
                     */
                    this.isObjectId = false;
                    this.entityMetadata = options.entityMetadata;
                    this.embeddedMetadata = options.embeddedMetadata;
                    this.referencedColumn = options.referencedColumn;
                    if (options.args.propertyName)
                        this.propertyName = options.args.propertyName;
                    if (options.args.options.name)
                        this.givenDatabaseName = options.args.options.name;
                    if (options.args.options.type)
                        this.type = options.args.options.type;
                    if (options.args.options.length)
                        this.length = String(options.args.options.length);
                    if (options.args.options.primary)
                        this.isPrimary = options.args.options.primary;
                    if (options.args.options.generated)
                        this.isGenerated = options.args.options.generated;
                    if (options.args.options.unique)
                        this.isUnique = options.args.options.unique;
                    if (options.args.options.nullable)
                        this.isNullable = options.args.options.nullable;
                    if (options.args.options.comment)
                        this.comment = options.args.options.comment;
                    if (options.args.options.default !== undefined)
                        this.default = options.args.options.default;
                    if (options.args.options.scale)
                        this.scale = options.args.options.scale;
                    if (options.args.options.precision)
                        this.precision = options.args.options.precision;
                    if (options.args.options.timezone)
                        this.timezone = options.args.options.timezone;
                    if (options.args.options.localTimezone)
                        this.localTimezone = options.args.options.localTimezone;
                    if (options.args.options.fixedLength)
                        this.fixedLength = options.args.options.fixedLength;
                    if (options.args.mode) {
                        this.isVirtual = options.args.mode === "virtual";
                        this.isParentId = options.args.mode === "parentId";
                        this.isDiscriminator = options.args.mode === "discriminator";
                        this.isTreeLevel = options.args.mode === "treeLevel";
                        this.isCreateDate = options.args.mode === "createDate";
                        this.isUpdateDate = options.args.mode === "updateDate";
                        this.isVersion = options.args.mode === "version";
                        this.isObjectId = options.args.mode === "objectId";
                    }
                }
                // ---------------------------------------------------------------------
                // Public Methods
                // ---------------------------------------------------------------------
                /**
                 * Creates entity id map from the given entity ids array.
                 */
                ColumnMetadata.prototype.createValueMap = function (value) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_4 = function (propertyNames, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_4(propertyNames, map[propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_4(propertyNames, {});
                    }
                    else {
                        return _a = {}, _a[this.propertyName] = value, _a;
                    }
                    var _a;
                };
                /**
                 * Extracts column value and returns its column name with this value in a literal object.
                 * If column is in embedded (or recursive embedded) it returns complex literal object.
                 *
                 * Examples what this method can return depend if this column is in embeds.
                 * { id: 1 } or { title: "hello" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }
                 */
                ColumnMetadata.prototype.getEntityValueMap = function (entity) {
                    var _this = this;
                    // extract column value from embeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object and return it in a
                        // { data: { information: { counters: { id: ... } } } } format
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // now need to access post[data][information][counters] to get column value from the counters
                        // and on each step we need to create complex literal object, e.g. first { data },
                        // then { data: { information } }, then { data: { information: { counters } } },
                        // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }
                        // this recursive function helps doing that
                        var extractEmbeddedColumnValue_5 = function (propertyNames, value, map) {
                            var propertyName = propertyNames.shift();
                            if (propertyName) {
                                map[propertyName] = {};
                                extractEmbeddedColumnValue_5(propertyNames, value ? value[propertyName] : undefined, map[propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value ? value[_this.propertyName] : undefined;
                            return map;
                        };
                        return extractEmbeddedColumnValue_5(propertyNames, entity, {});
                    }
                    else {
                        return _a = {}, _a[this.propertyName] = entity[this.propertyName], _a;
                    }
                    var _a;
                };
                /**
                 * Extracts column value from the given entity.
                 * If column is in embedded (or recursive embedded) it extracts its value from there.
                 */
                ColumnMetadata.prototype.getEntityValue = function (entity) {
                    // if (entity === undefined || entity === null) return undefined; // uncomment if needed
                    // extract column value from embeddeds of entity if column is in embedded
                    if (this.embeddedMetadata) {
                        // example: post[data][information][counters].id where "data", "information" and "counters" are embeddeds
                        // we need to get value of "id" column from the post real entity object
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var propertyNames = this.embeddedMetadata.parentPropertyNames.slice();
                        // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters
                        // this recursive function takes array of generated property names and gets the post[data][information][counters] embed
                        var extractEmbeddedColumnValue_6 = function (propertyNames, value) {
                            var propertyName = propertyNames.shift();
                            return propertyName ? extractEmbeddedColumnValue_6(propertyNames, value[propertyName]) : value;
                        };
                        // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]
                        var embeddedObject = extractEmbeddedColumnValue_6(propertyNames, entity);
                        if (embeddedObject) {
                            if (this.relationMetadata && this.referencedColumn && this.isVirtual) {
                                var relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);
                                return relatedEntity ? this.referencedColumn.getEntityValue(relatedEntity) : undefined;
                            }
                            else {
                                return embeddedObject[this.propertyName];
                            }
                        }
                        return undefined;
                        // return embeddedObject ? embeddedObject[this.propertyName] : undefined;
                    }
                    else {
                        if (this.relationMetadata && this.referencedColumn && this.isVirtual) {
                            var relatedEntity = this.relationMetadata.getEntityValue(entity);
                            return relatedEntity ? this.referencedColumn.getEntityValue(relatedEntity) : undefined;
                        }
                        else {
                            return entity[this.propertyName];
                        }
                        // return entity[this.propertyName];
                    }
                };
                /**
                 * Sets given entity's column value.
                 * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.
                 */
                ColumnMetadata.prototype.setEntityValue = function (entity, value) {
                    var _this = this;
                    if (this.embeddedMetadata) {
                        // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]
                        var extractEmbeddedColumnValue_7 = function (embeddedMetadatas, map) {
                            // if (!object[embeddedMetadata.propertyName])
                            //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();
                            var embeddedMetadata = embeddedMetadatas.shift();
                            if (embeddedMetadata) {
                                if (!map[embeddedMetadata.propertyName])
                                    map[embeddedMetadata.propertyName] = embeddedMetadata.create();
                                extractEmbeddedColumnValue_7(embeddedMetadatas, map[embeddedMetadata.propertyName]);
                                return map;
                            }
                            map[_this.propertyName] = value;
                            return map;
                        };
                        return extractEmbeddedColumnValue_7(this.embeddedMetadata.embeddedMetadataTree.slice(), entity);
                    }
                    else {
                        entity[this.propertyName] = value;
                    }
                };
                // ---------------------------------------------------------------------
                // Builder Methods
                // ---------------------------------------------------------------------
                ColumnMetadata.prototype.build = function (namingStrategy) {
                    this.propertyPath = this.buildPropertyPath();
                    this.databaseName = this.buildDatabaseName(namingStrategy);
                    this.databaseNameWithoutPrefixes = namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);
                    return this;
                };
                // ---------------------------------------------------------------------
                // Protected Methods
                // ---------------------------------------------------------------------
                ColumnMetadata.prototype.buildPropertyPath = function () {
                    var path = "";
                    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length)
                        path = this.embeddedMetadata.parentPropertyNames.join(".") + ".";
                    if (this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName)
                        path += this.referencedColumn.propertyName + ".";
                    return path + this.propertyName;
                };
                ColumnMetadata.prototype.buildDatabaseName = function (namingStrategy) {
                    var propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPropertyNames : [];
                    return namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);
                };
                return ColumnMetadata;
            }());
            exports_80("ColumnMetadata", ColumnMetadata);
        }
    };
});
System.register("typeorm/schema-builder/schema/ColumnSchema", [], function (exports_81, context_81) {
    "use strict";
    var __moduleName = context_81 && context_81.id;
    var ColumnSchema;
    return {
        setters: [],
        execute: function () {
            /**
             * Table's column's schema in the database represented in this class.
             */
            ColumnSchema = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ColumnSchema(options) {
                    /**
                     * Indicates if column is NULL, or is NOT NULL in the database.
                     */
                    this.isNullable = false;
                    /**
                     * Indicates if column is auto-generated sequence.
                     */
                    this.isGenerated = false;
                    /**
                     * Indicates if column is a primary key.
                     */
                    this.isPrimary = false;
                    /**
                     * Indicates if column has unique value.
                     */
                    this.isUnique = false;
                    if (options) {
                        this.name = options.name || "";
                        this.type = options.type || "";
                        this.default = options.default;
                        this.isNullable = options.isNullable || false;
                        this.isGenerated = options.isGenerated || false;
                        this.isPrimary = options.isPrimary || false;
                        this.isUnique = options.isUnique || false;
                        this.comment = options.comment;
                    }
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Clones this column schema to a new column schema with exact same properties as this column schema has.
                 */
                ColumnSchema.prototype.clone = function () {
                    var newColumnSchema = new ColumnSchema();
                    newColumnSchema.name = this.name;
                    newColumnSchema.type = this.type;
                    newColumnSchema.default = this.default;
                    newColumnSchema.isNullable = this.isNullable;
                    newColumnSchema.isGenerated = this.isGenerated;
                    newColumnSchema.isPrimary = this.isPrimary;
                    newColumnSchema.isUnique = this.isUnique;
                    newColumnSchema.comment = this.comment;
                    return newColumnSchema;
                };
                // -------------------------------------------------------------------------
                // Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new column based on the given column metadata.
                 */
                ColumnSchema.create = function (columnMetadata, normalizedType) {
                    var columnSchema = new ColumnSchema();
                    columnSchema.name = columnMetadata.databaseName;
                    columnSchema.default = columnMetadata.default;
                    columnSchema.comment = columnMetadata.comment;
                    columnSchema.isGenerated = columnMetadata.isGenerated;
                    columnSchema.isNullable = columnMetadata.isNullable;
                    columnSchema.type = normalizedType;
                    columnSchema.isPrimary = columnMetadata.isPrimary;
                    columnSchema.isUnique = columnMetadata.isUnique;
                    return columnSchema;
                };
                return ColumnSchema;
            }());
            exports_81("ColumnSchema", ColumnSchema);
        }
    };
});
System.register("typeorm/query-runner/QueryRunner", [], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/Driver", [], function (exports_83, context_83) {
    "use strict";
    var __moduleName = context_83 && context_83.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/find-options/FindOneOptions", [], function (exports_84, context_84) {
    "use strict";
    var __moduleName = context_84 && context_84.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/find-options/FindManyOptions", [], function (exports_85, context_85) {
    "use strict";
    var __moduleName = context_85 && context_85.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/common/DeepPartial", [], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/SaveOptions", [], function (exports_87, context_87) {
    "use strict";
    var __moduleName = context_87 && context_87.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/RemoveOptions", [], function (exports_88, context_88) {
    "use strict";
    var __moduleName = context_88 && context_88.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/common/ObjectType", [], function (exports_89, context_89) {
    "use strict";
    var __moduleName = context_89 && context_89.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/query-runner/error/QueryRunnerProviderAlreadyReleasedError", [], function (exports_90, context_90) {
    "use strict";
    var __moduleName = context_90 && context_90.id;
    var QueryRunnerProviderAlreadyReleasedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use query runner from query runner provider after it was released.
             */
            QueryRunnerProviderAlreadyReleasedError = (function (_super) {
                __extends(QueryRunnerProviderAlreadyReleasedError, _super);
                function QueryRunnerProviderAlreadyReleasedError() {
                    var _this = _super.call(this) || this;
                    _this.name = "QueryRunnerProviderAlreadyReleasedError";
                    _this.message = "Database connection provided by a query runner was already released, cannot continue to use its querying methods anymore.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return QueryRunnerProviderAlreadyReleasedError;
            }(Error));
            exports_90("QueryRunnerProviderAlreadyReleasedError", QueryRunnerProviderAlreadyReleasedError);
        }
    };
});
System.register("typeorm/persistence/Subject", ["typeorm/metadata/types/ColumnTypes", "typeorm/util/DataTransformationUtils"], function (exports_91, context_91) {
    "use strict";
    var __moduleName = context_91 && context_91.id;
    var ColumnTypes_5, DataTransformationUtils_5, Subject;
    return {
        setters: [
            function (ColumnTypes_5_1) {
                ColumnTypes_5 = ColumnTypes_5_1;
            },
            function (DataTransformationUtils_5_1) {
                DataTransformationUtils_5 = DataTransformationUtils_5_1;
            }
        ],
        execute: function () {
            /**
             * Subject is a subject of persistence.
             * It holds information about each entity that needs to be persisted:
             * - what entity should be persisted
             * - what is database representation of the persisted entity
             * - what entity metadata of the persisted entity
             * - what is allowed to with persisted entity (insert/update/remove)
             *
             * Having this collection of subjects we can perform database queries.
             */
            Subject = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Subject(metadata, entity, databaseEntity) {
                    /**
                     * Date when this entity is persisted.
                     */
                    this.date = new Date();
                    // -------------------------------------------------------------------------
                    // Public Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if this subject can be inserted into the database.
                     * This means that this subject either is newly persisted, either can be inserted by cascades.
                     */
                    this.canBeInserted = false;
                    /**
                     * Indicates if this subject can be updated in the database.
                     * This means that this subject either was persisted, either can be updated by cascades.
                     */
                    this.canBeUpdated = false;
                    /**
                     * Indicates if this subject MUST be removed from the database.
                     * This means that this subject either was removed, either was removed by cascades.
                     */
                    this.mustBeRemoved = false;
                    /**
                     * Differentiated columns between persisted and database entities.
                     */
                    this.diffColumns = [];
                    /**
                     * Differentiated relations between persisted and database entities.
                     */
                    this.diffRelations = [];
                    /**
                     * List of relations which need to be unset.
                     * This is used to update relation from inverse side.
                     */
                    this.relationUpdates = [];
                    /**
                     * Records that needs to be inserted into the junction tables of this subject.
                     */
                    this.junctionInserts = [];
                    /**
                     * Records that needs to be removed from the junction tables of this subject.
                     */
                    this.junctionRemoves = [];
                    this.metadata = metadata;
                    this._persistEntity = entity;
                    this._databaseEntity = databaseEntity;
                }
                Object.defineProperty(Subject.prototype, "entity", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets entity sent to the persistence (e.g. changed entity).
                     * Throws error if persisted entity was not set.
                     */
                    get: function () {
                        if (!this._persistEntity)
                            throw new Error("Persistence entity is not set for the given subject.");
                        return this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasEntity", {
                    /**
                     * Checks if subject has a persisted entity.
                     */
                    get: function () {
                        return !!this._persistEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "databaseEntity", {
                    /**
                     * Gets entity from the database (e.g. original entity).
                     * THIS IS NOT RAW ENTITY DATA.
                     * Throws error if database entity was not set.
                     */
                    get: function () {
                        if (!this._databaseEntity)
                            throw new Error("Database entity is not set for the given subject.");
                        return this._databaseEntity;
                    },
                    /**
                     * Sets entity from the database (e.g. original entity).
                     * Once database entity set it calculates differentiated columns and relations
                     * between persistent entity and database entity.
                     */
                    set: function (databaseEntity) {
                        this._databaseEntity = databaseEntity;
                        this.recompute();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasDatabaseEntity", {
                    /**
                     * Checks if subject has a database entity.
                     */
                    get: function () {
                        return !!this._databaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "entityTarget", {
                    /**
                     * Gets entity target from the entity metadata of this subject.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeInserted", {
                    /**
                     * Checks if this subject must be inserted into the database.
                     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)
                     * and if it does not have database entity set.
                     */
                    get: function () {
                        return this.canBeInserted && !this.hasDatabaseEntity;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "mustBeUpdated", {
                    /**
                     * Checks if this subject must be updated into the database.
                     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)
                     * and if it does have differentiated columns or relations.
                     */
                    get: function () {
                        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Subject.prototype, "hasRelationUpdates", {
                    /**
                     * Checks if this subject has relations to be updated.
                     */
                    get: function () {
                        return this.relationUpdates.length > 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets id of the persisted entity.
                 * If entity is not set then it returns undefined.
                 * If entity itself has an id then it simply returns it.
                 * If entity does not have an id then it returns newly generated id.
            
                get getPersistedEntityIdMap(): any|undefined {
                    if (!this.hasEntity)
                        return undefined;
            
                    const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);
                    if (entityIdMap)
                        return entityIdMap;
            
                    if (this.newlyGeneratedId)
                        return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);
            
                    return undefined;
                }*/
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates this subject for errors.
                 * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.
                 */
                Subject.prototype.validate = function () {
                    if (this.mustBeInserted && this.mustBeRemoved)
                        throw new Error("Removed entity " + this.metadata.name + " is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.");
                    if (this.mustBeUpdated && this.mustBeRemoved)
                        throw new Error("Removed entity \"" + this.metadata.name + "\" is also scheduled for update operation. " +
                            "Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).");
                    if (this.mustBeInserted && this.mustBeUpdated)
                        throw new Error("Inserted entity " + this.metadata.name + " is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.");
                };
                /**
                 * Performs entity re-computations.
                 */
                Subject.prototype.recompute = function () {
                    if (this.hasEntity && this._databaseEntity) {
                        this.computeDiffColumns();
                        this.computeDiffRelationalColumns();
                    }
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Differentiate columns from the updated entity and entity stored in the database.
                 */
                Subject.prototype.computeDiffColumns = function () {
                    var _this = this;
                    this.diffColumns = this.metadata.columns.filter(function (column) {
                        // prepare both entity and database values to make comparision
                        var entityValue = column.getEntityValue(_this.entity);
                        var databaseValue = column.getEntityValue(_this.databaseEntity);
                        if (entityValue === undefined)
                            return false;
                        // normalize special values to make proper comparision
                        if (entityValue !== null && entityValue !== undefined) {
                            if (column.type === ColumnTypes_5.ColumnTypes.DATE) {
                                entityValue = DataTransformationUtils_5.DataTransformationUtils.mixedDateToDateString(entityValue);
                            }
                            else if (column.type === ColumnTypes_5.ColumnTypes.TIME) {
                                entityValue = DataTransformationUtils_5.DataTransformationUtils.mixedDateToTimeString(entityValue);
                            }
                            else if (column.type === ColumnTypes_5.ColumnTypes.DATETIME) {
                                // if (column.loadInLocalTimezone) {
                                //     entityValue = DataTransformationUtils.mixedDateToDatetimeString(entityValue);
                                //     databaseValue = DataTransformationUtils.mixedDateToDatetimeString(databaseValue);
                                // } else {
                                entityValue = DataTransformationUtils_5.DataTransformationUtils.mixedDateToUtcDatetimeString(entityValue);
                                databaseValue = DataTransformationUtils_5.DataTransformationUtils.mixedDateToUtcDatetimeString(databaseValue);
                                // }
                            }
                            else if (column.type === ColumnTypes_5.ColumnTypes.JSON) {
                                entityValue = JSON.stringify(entityValue);
                                if (databaseValue !== null && databaseValue !== undefined)
                                    databaseValue = JSON.stringify(databaseValue);
                            }
                            else if (column.type === ColumnTypes_5.ColumnTypes.SIMPLE_ARRAY) {
                                entityValue = DataTransformationUtils_5.DataTransformationUtils.simpleArrayToString(entityValue);
                                databaseValue = DataTransformationUtils_5.DataTransformationUtils.simpleArrayToString(databaseValue);
                            }
                        }
                        // todo: this mechanism does not get in count embeddeds in embeddeds
                        // if value is not defined then no need to update it
                        // if (!column.isInEmbedded && this.entity[column.propertyName] === undefined)
                        //     return false;
                        //
                        // if value is in embedded and is not defined then no need to update it
                        // if (column.isInEmbedded && (this.entity[column.embeddedProperty] === undefined || this.entity[column.embeddedProperty][column.propertyName] === undefined))
                        //     return false;
                        // if its a special column or value is not changed - then do nothing
                        if (column.isVirtual ||
                            column.isParentId ||
                            column.isDiscriminator ||
                            column.isUpdateDate ||
                            column.isVersion ||
                            column.isCreateDate ||
                            entityValue === databaseValue)
                            return false;
                        // filter out "relational columns" only in the case if there is a relation object in entity
                        var relation = _this.metadata.findRelationWithDbName(column.databaseName);
                        if (relation) {
                            var value = relation.getEntityValue(_this.entity);
                            if (value !== null && value !== undefined)
                                return false;
                        }
                        return true;
                    });
                };
                /**
                 * Difference columns of the owning one-to-one and many-to-one columns.
                 */
                Subject.prototype.computeDiffRelationalColumns = function () {
                    var _this = this;
                    this.diffRelations = this.metadata.relations.filter(function (relation) {
                        if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))
                            return false;
                        // here we cover two scenarios:
                        // 1. related entity can be another entity which is natural way
                        // 2. related entity can be entity id which is hacked way of updating entity
                        // todo: what to do if there is a column with relationId? (cover this too?)
                        var entityValue = relation.getEntityValue(_this.entity);
                        var updatedEntityRelationId = entityValue instanceof Object
                            ? relation.inverseEntityMetadata.getEntityIdMixedMap(entityValue)
                            : entityValue;
                        var dbEntityRelationId = relation.getEntityValue(_this.databaseEntity);
                        // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this
                        // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))
                        // todo:     return false;
                        // we don't perform operation over undefined properties
                        if (updatedEntityRelationId === undefined)
                            return false;
                        // if both are empty totally no need to do anything
                        if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&
                            (dbEntityRelationId === undefined || dbEntityRelationId === null))
                            return false;
                        // if relation ids aren't equal then we need to update them
                        return updatedEntityRelationId !== dbEntityRelationId;
                    });
                };
                return Subject;
            }());
            exports_91("Subject", Subject);
        }
    };
});
System.register("typeorm/repository/SpecificRepository", ["typeorm/query-runner/QueryRunnerProvider", "typeorm/persistence/Subject", "typeorm/metadata/RelationMetadata", "typeorm/query-builder/QueryBuilder", "typeorm/util/OrmUtils"], function (exports_92, context_92) {
    "use strict";
    var __moduleName = context_92 && context_92.id;
    var QueryRunnerProvider_2, Subject_1, RelationMetadata_1, QueryBuilder_4, OrmUtils_3, SpecificRepository;
    return {
        setters: [
            function (QueryRunnerProvider_2_1) {
                QueryRunnerProvider_2 = QueryRunnerProvider_2_1;
            },
            function (Subject_1_1) {
                Subject_1 = Subject_1_1;
            },
            function (RelationMetadata_1_1) {
                RelationMetadata_1 = RelationMetadata_1_1;
            },
            function (QueryBuilder_4_1) {
                QueryBuilder_4 = QueryBuilder_4_1;
            },
            function (OrmUtils_3_1) {
                OrmUtils_3 = OrmUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Repository for more specific operations.
             *
             * @deprecated Don't use it yet
             */
            SpecificRepository = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SpecificRepository(connection, metadata, queryRunnerProvider) {
                    this.connection = connection;
                    this.metadata = metadata;
                    this.queryRunnerProvider = queryRunnerProvider;
                }
                /**
                 * Sets given relatedEntityId to the value of the relation of the entity with entityId id.
                 * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.setRelation = function (relationProperty, entityId, relatedEntityId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, table, values, conditions, queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)
                                    //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);
                                    if (relation.isManyToMany)
                                        throw new Error("Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.");
                                    values = {}, conditions = {};
                                    if (relation.isOwning) {
                                        table = relation.entityMetadata.tableName;
                                        values[relation.joinColumns[0].referencedColumn.databaseName] = relatedEntityId;
                                        conditions[relation.joinColumns[0].referencedColumn.databaseName] = entityId;
                                    }
                                    else {
                                        table = relation.inverseEntityMetadata.tableName;
                                        values[relation.inverseRelation.joinColumns[0].referencedColumn.databaseName] = relatedEntityId;
                                        conditions[relation.inverseRelation.joinColumns[0].referencedColumn.databaseName] = entityId;
                                    }
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.update(table, values, conditions)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Sets given relatedEntityId to the value of the relation of the entity with entityId id.
                 * Should be used when you want quickly and efficiently set a relation (for many-to-one and one-to-many) to some entity.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.setInverseRelation = function (relationProperty, relatedEntityId, entityId) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, table, values, conditions, queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    // if (relation.isManyToMany || relation.isOneToMany || relation.isOneToOneNotOwner)
                                    //     throw new Error(`Only many-to-one and one-to-one with join column are supported for this operation. ${this.metadata.name}#${propertyName} relation type is ${relation.relationType}`);
                                    if (relation.isManyToMany)
                                        throw new Error("Many-to-many relation is not supported for this operation. Use #addToRelation method for many-to-many relations.");
                                    values = {}, conditions = {};
                                    if (relation.isOwning) {
                                        table = relation.inverseEntityMetadata.tableName;
                                        values[relation.inverseRelation.joinColumns[0].databaseName] = relatedEntityId;
                                        conditions[relation.inverseRelation.joinColumns[0].referencedColumn.databaseName] = entityId;
                                    }
                                    else {
                                        table = relation.entityMetadata.tableName;
                                        values[relation.joinColumns[0].databaseName] = relatedEntityId;
                                        conditions[relation.joinColumns[0].referencedColumn.databaseName] = entityId;
                                    }
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.update(table, values, conditions)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Adds a new relation between two entities into relation's many-to-many table.
                 * Should be used when you want quickly and efficiently add a relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addToRelation = function (relationProperty, entityId, relatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, queryRunnerProvider, queryRunner, insertPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyPath + " relation type is " + relation.relationType);
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    insertPromises = relatedEntityIds.map(function (relatedEntityId) {
                                        var values = {};
                                        if (relation.isOwning) {
                                            values[relation.junctionEntityMetadata.columns[0].databaseName] = entityId;
                                            values[relation.junctionEntityMetadata.columns[1].databaseName] = relatedEntityId;
                                        }
                                        else {
                                            values[relation.junctionEntityMetadata.columns[1].databaseName] = entityId;
                                            values[relation.junctionEntityMetadata.columns[0].databaseName] = relatedEntityId;
                                        }
                                        return queryRunner.insert(relation.junctionEntityMetadata.tableName, values);
                                    });
                                    return [4 /*yield*/, Promise.all(insertPromises)];
                                case 2:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Adds a new relation between two entities into relation's many-to-many table from inverse side of the given relation.
                 * Should be used when you want quickly and efficiently add a relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addToInverseRelation = function (relationProperty, relatedEntityId, entityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, queryRunnerProvider, queryRunner, insertPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyPath + " relation type is " + relation.relationType);
                                    queryRunnerProvider = this.queryRunnerProvider ? this.queryRunnerProvider : new QueryRunnerProvider_2.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 7]);
                                    insertPromises = entityIds.map(function (entityId) {
                                        var values = {};
                                        if (relation.isOwning) {
                                            values[relation.junctionEntityMetadata.columns[0].databaseName] = entityId;
                                            values[relation.junctionEntityMetadata.columns[1].databaseName] = relatedEntityId;
                                        }
                                        else {
                                            values[relation.junctionEntityMetadata.columns[1].databaseName] = entityId;
                                            values[relation.junctionEntityMetadata.columns[0].databaseName] = relatedEntityId;
                                        }
                                        return queryRunner.insert(relation.junctionEntityMetadata.tableName, values);
                                    });
                                    return [4 /*yield*/, Promise.all(insertPromises)];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 7];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a relation between two entities from relation's many-to-many table.
                 * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeFromRelation = function (relationProperty, entityId, relatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, qb, firstColumnName, secondColumnName;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyPath + " relation type is " + relation.relationType);
                                    // check if given relation entity ids is empty - then nothing to do here (otherwise next code will remove all ids)
                                    if (!relatedEntityIds || !relatedEntityIds.length)
                                        return [2 /*return*/, Promise.resolve()];
                                    qb = new QueryBuilder_4.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .delete()
                                        .fromTable(relation.junctionEntityMetadata.tableName, "junctionEntity");
                                    firstColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[0].databaseName : relation.junctionEntityMetadata.columns[1].databaseName);
                                    secondColumnName = this.connection.driver.escapeColumnName(relation.isOwning ? relation.junctionEntityMetadata.columns[1].databaseName : relation.junctionEntityMetadata.columns[0].databaseName);
                                    relatedEntityIds.forEach(function (relatedEntityId, index) {
                                        qb.orWhere("(" + firstColumnName + "=:entityId AND " + secondColumnName + "=:relatedEntity_" + index + ")")
                                            .setParameter("relatedEntity_" + index, relatedEntityId);
                                    });
                                    return [4 /*yield*/, qb
                                            .setParameter("entityId", entityId)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a relation between two entities from relation's many-to-many table.
                 * Should be used when you want quickly and efficiently remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeFromInverseRelation = function (relationProperty, relatedEntityId, entityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var propertyPath, relation, qb, firstColumnName, secondColumnName;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    propertyPath = this.metadata.computePropertyPath(relationProperty);
                                    relation = this.metadata.findRelationWithPropertyPath(propertyPath);
                                    if (!relation)
                                        throw new Error("Relation with property path " + propertyPath + " in entity was not found.");
                                    if (!relation.isManyToMany)
                                        throw new Error("Only many-to-many relation supported for this operation. However " + this.metadata.name + "#" + propertyPath + " relation type is " + relation.relationType);
                                    // check if given entity ids is empty - then nothing to do here (otherwise next code will remove all ids)
                                    if (!entityIds || !entityIds.length)
                                        return [2 /*return*/, Promise.resolve()];
                                    qb = new QueryBuilder_4.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .delete()
                                        .from(relation.junctionEntityMetadata.tableName, "junctionEntity");
                                    firstColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[1].databaseName : relation.junctionEntityMetadata.columns[0].databaseName;
                                    secondColumnName = relation.isOwning ? relation.junctionEntityMetadata.columns[0].databaseName : relation.junctionEntityMetadata.columns[1].databaseName;
                                    entityIds.forEach(function (entityId, index) {
                                        qb.orWhere("(" + firstColumnName + "=:relatedEntityId AND " + secondColumnName + "=:entity_" + index + ")")
                                            .setParameter("entity_" + index, entityId);
                                    });
                                    return [4 /*yield*/, qb.setParameter("relatedEntityId", relatedEntityId).execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Performs both #addToRelation and #removeFromRelation operations.
                 * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addAndRemoveFromRelation = function (relation, entityId, addRelatedEntityIds, removeRelatedEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all([
                                        this.addToRelation(relation, entityId, addRelatedEntityIds),
                                        this.removeFromRelation(relation, entityId, removeRelatedEntityIds)
                                    ])];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Performs both #addToRelation and #removeFromRelation operations.
                 * Should be used when you want quickly and efficiently and and remove a many-to-many relation between two entities.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.addAndRemoveFromInverseRelation = function (relation, relatedEntityId, addEntityIds, removeEntityIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all([
                                        this.addToInverseRelation(relation, relatedEntityId, addEntityIds),
                                        this.removeFromInverseRelation(relation, relatedEntityId, removeEntityIds)
                                    ])];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes entity with the given id.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeById = function (id) {
                    return __awaiter(this, void 0, void 0, function () {
                        var alias, parameters, condition;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    alias = this.metadata.tableName;
                                    parameters = {};
                                    condition = "";
                                    if (this.metadata.hasMultiplePrimaryKeys) {
                                        condition = this.metadata.primaryColumns.map(function (primaryColumn) {
                                            parameters[primaryColumn.propertyName] = id[primaryColumn.propertyName];
                                            return alias + "." + primaryColumn.propertyName + "=:" + primaryColumn.propertyName;
                                        }).join(" AND ");
                                    }
                                    else {
                                        condition = alias + "." + this.metadata.primaryColumns[0].propertyName + "=:id";
                                        parameters["id"] = id;
                                    }
                                    return [4 /*yield*/, new QueryBuilder_4.QueryBuilder(this.connection, this.queryRunnerProvider)
                                            .delete()
                                            .from(this.metadata.target, alias)
                                            .where(condition, parameters)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes all entities with the given ids.
                 * Note that event listeners and event subscribers won't work (and will not send any events) when using this operation.
                 */
                SpecificRepository.prototype.removeByIds = function (ids) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var alias, parameters, condition;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    alias = this.metadata.tableName;
                                    parameters = {};
                                    condition = "";
                                    if (this.metadata.hasMultiplePrimaryKeys) {
                                        condition = ids.map(function (id, idIndex) {
                                            _this.metadata.primaryColumns.map(function (primaryColumn) {
                                                parameters[primaryColumn.propertyName + "_" + idIndex] = id[primaryColumn.propertyName];
                                                return alias + "." + primaryColumn.propertyName + "=:" + primaryColumn.propertyName + "_" + idIndex;
                                            }).join(" AND ");
                                        }).join(" OR ");
                                    }
                                    else {
                                        condition = alias + "." + this.metadata.primaryColumns[0].propertyName + " IN (:ids)";
                                        parameters["ids"] = ids;
                                    }
                                    return [4 /*yield*/, new QueryBuilder_4.QueryBuilder(this.connection, this.queryRunnerProvider)
                                            .delete()
                                            .from(this.metadata.target, alias)
                                            .where(condition, parameters)
                                            .execute()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Finds all relation ids in the given entities.
                 */
                SpecificRepository.prototype.findRelationIds = function (relationOrName, entityOrEntities, inIds, notInIds) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var relation, entityReferencedColumns, ownerEntityColumns, inverseEntityColumns, inverseEntityColumnNames, entityIds, ea, ec, ids, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    relation = this.convertMixedRelationToMetadata(relationOrName);
                                    if (!(entityOrEntities instanceof Array))
                                        entityOrEntities = [entityOrEntities];
                                    entityReferencedColumns = relation.isOwning ? relation.joinColumns.map(function (joinColumn) { return joinColumn.referencedColumn; }) : relation.inverseRelation.inverseJoinColumns.map(function (joinColumn) { return joinColumn.referencedColumn; });
                                    ownerEntityColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                                    inverseEntityColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                    inverseEntityColumnNames = relation.isOwning ? relation.inverseJoinColumns.map(function (joinColumn) { return joinColumn.databaseName; }) : relation.inverseRelation.joinColumns.map(function (joinColumn) { return joinColumn.databaseName; });
                                    entityIds = this.convertEntityOrEntitiesToIdOrIds(entityReferencedColumns, entityOrEntities);
                                    if (!(entityIds instanceof Array))
                                        entityIds = [entityIds];
                                    // filter out empty entity ids
                                    entityIds = entityIds.filter(function (entityId) { return entityId !== null && entityId !== undefined; });
                                    // if no entity ids at the end, then we don't need to load anything
                                    if (entityIds.length === 0)
                                        return [2 /*return*/, []];
                                    ea = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                                    ec = function (column) { return _this.connection.driver.escapeColumnName(column); };
                                    ids = [];
                                    promises = entityIds.map(function (entityId) {
                                        var qb = new QueryBuilder_4.QueryBuilder(_this.connection, _this.queryRunnerProvider);
                                        inverseEntityColumnNames.forEach(function (columnName) {
                                            qb.select(ea("junction") + "." + ec(columnName) + " AS " + ea(columnName));
                                        });
                                        qb.fromTable(relation.junctionEntityMetadata.tableName, "junction");
                                        Object.keys(entityId).forEach(function (columnName) {
                                            var junctionColumnName = ownerEntityColumns.find(function (joinColumn) { return joinColumn.referencedColumn.databaseName === columnName; });
                                            qb.andWhere(ea("junction") + "." + ec(junctionColumnName.databaseName) + "=:" + junctionColumnName.databaseName + "_entityId", (_a = {}, _a[junctionColumnName.databaseName + "_entityId"] = entityId[columnName], _a));
                                            var _a;
                                        });
                                        // ownerEntityColumnNames.forEach(columnName => {
                                        //     qb.andWhere(ea("junction") + "." + ec(columnName) + "=:" + columnName + "_entityId", {[columnName + "_entityId"]: entityId});
                                        // });
                                        // todo: fix inIds
                                        // if (inIds && inIds.length > 0)
                                        //     qb.andWhere(ea("junction") + "." + ec(inverseEntityColumnNames.fullName) + " IN (:inIds)", {inIds: inIds});
                                        //
                                        // if (notInIds && notInIds.length > 0)
                                        //     qb.andWhere(ea("junction") + "." + ec(inverseEntityColumnNames.fullName) + " NOT IN (:notInIds)", {notInIds: notInIds});
                                        // console.log(qb.getSql());
                                        return qb.getRawMany()
                                            .then(function (results) {
                                            // console.log(results);
                                            results.forEach(function (result) {
                                                ids.push(Object.keys(result).reduce(function (id, key) {
                                                    var junctionColumnName = inverseEntityColumns.find(function (joinColumn) { return joinColumn.databaseName === key; });
                                                    OrmUtils_3.OrmUtils.mergeDeep(id, junctionColumnName.referencedColumn.createValueMap(result[key]));
                                                    return id;
                                                }, {}));
                                            }); // todo: prepare result?
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/, ids];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Converts entity or entities to id or ids map.
                 */
                SpecificRepository.prototype.convertEntityOrEntitiesToIdOrIds = function (columns, entityOrEntities) {
                    var _this = this;
                    if (entityOrEntities instanceof Array) {
                        return entityOrEntities.map(function (entity) { return _this.convertEntityOrEntitiesToIdOrIds(columns, entity); });
                    }
                    else {
                        if (entityOrEntities instanceof Object) {
                            return columns.reduce(function (ids, column) {
                                ids[column.databaseName] = column.getEntityValue(entityOrEntities);
                                return ids;
                            }, {});
                        }
                        else {
                            return entityOrEntities;
                        }
                    }
                };
                /**
                 * Converts relation name, relation name in function into RelationMetadata.
                 */
                SpecificRepository.prototype.convertMixedRelationToMetadata = function (relationOrName) {
                    if (relationOrName instanceof RelationMetadata_1.RelationMetadata)
                        return relationOrName;
                    var relationPropertyPath = relationOrName instanceof Function ? relationOrName(this.metadata.propertiesMap) : relationOrName;
                    var relation = this.metadata.findRelationWithPropertyPath(relationPropertyPath);
                    if (!relation)
                        throw new Error("Relation with property path " + relationPropertyPath + " in entity was not found.");
                    return relation;
                };
                /**
                 * Extracts unique objects from given entity and all its downside relations.
                 */
                SpecificRepository.prototype.extractObjectsById = function (entity, metadata, entityWithIds) {
                    var _this = this;
                    if (entityWithIds === void 0) { entityWithIds = []; }
                    var promises = metadata.relations.map(function (relation) {
                        var relMetadata = relation.inverseEntityMetadata;
                        var value = relation.getEntityValue(entity);
                        if (!value)
                            return undefined;
                        if (value instanceof Array) {
                            var subPromises = value.map(function (subEntity) {
                                return _this.extractObjectsById(subEntity, relMetadata, entityWithIds);
                            });
                            return Promise.all(subPromises);
                        }
                        else {
                            return _this.extractObjectsById(value, relMetadata, entityWithIds);
                        }
                    });
                    return Promise.all(promises.filter(function (result) { return !!result; })).then(function () {
                        if (!entityWithIds.find(function (entityWithId) { return entityWithId.entity === entity; })) {
                            var entityWithId = new Subject_1.Subject(metadata, entity);
                            entityWithIds.push(entityWithId);
                        }
                        return entityWithIds;
                    });
                };
                return SpecificRepository;
            }());
            exports_92("SpecificRepository", SpecificRepository);
        }
    };
});
System.register("typeorm/repository/TreeRepository", ["typeorm/repository/Repository"], function (exports_93, context_93) {
    "use strict";
    var __moduleName = context_93 && context_93.id;
    var Repository_1, TreeRepository;
    return {
        setters: [
            function (Repository_1_1) {
                Repository_1 = Repository_1_1;
            }
        ],
        execute: function () {
            /**
             * Repository with additional functions to work with trees.
             *
             * @see Repository
             */
            TreeRepository = (function (_super) {
                __extends(TreeRepository, _super);
                function TreeRepository() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // todo: implement moving
                // todo: implement removing
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets complete trees for all roots in the table.
                 */
                TreeRepository.prototype.findTrees = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var roots;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findRoots()];
                                case 1:
                                    roots = _a.sent();
                                    return [4 /*yield*/, Promise.all(roots.map(function (root) { return __awaiter(_this, void 0, void 0, function () {
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, this.findDescendantsTree(root)];
                                                    case 1:
                                                        _a.sent();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }))];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/, roots];
                            }
                        });
                    });
                };
                /**
                 * Roots are entities that have no ancestors. Finds them all.
                 */
                TreeRepository.prototype.findRoots = function () {
                    var parentPropertyName = this.metadata.treeParentRelation.propertyName;
                    return this.createQueryBuilder("treeEntity")
                        .where("treeEntity." + parentPropertyName + " IS NULL")
                        .getMany();
                };
                /**
                 * Creates a query builder used to get descendants of the entities in a tree.
                 */
                TreeRepository.prototype.createDescendantsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.manager.connection.driver.escapeAliasName(alias); };
                    var escapeColumn = function (column) { return _this.manager.connection.driver.escapeColumnName(column); };
                    var joinCondition = escapeAlias(alias) + "." + escapeColumn(this.metadata.primaryColumns[0].databaseName) + "=" + escapeAlias(closureTableAlias) + "." + escapeColumn("descendant");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)
                        .where(escapeAlias(closureTableAlias) + "." + escapeColumn("ancestor") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.primaryColumns[0].propertyName]);
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findDescendantsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getEntitiesAndRawResults()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.rawResults);
                        _this.buildChildrenEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of descendants of the entity.
                 */
                TreeRepository.prototype.countDescendants = function (entity) {
                    return this
                        .createDescendantsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Creates a query builder used to get ancestors of the entities in the tree.
                 */
                TreeRepository.prototype.createAncestorsQueryBuilder = function (alias, closureTableAlias, entity) {
                    var _this = this;
                    // create shortcuts for better readability
                    var escapeAlias = function (alias) { return _this.manager.connection.driver.escapeAliasName(alias); };
                    var escapeColumn = function (column) { return _this.manager.connection.driver.escapeColumnName(column); };
                    var joinCondition = escapeAlias(alias) + "." + escapeColumn(this.metadata.primaryColumns[0].databaseName) + "=" + escapeAlias(closureTableAlias) + "." + escapeColumn("ancestor");
                    return this.createQueryBuilder(alias)
                        .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)
                        .where(escapeAlias(closureTableAlias) + "." + escapeColumn("descendant") + "=" + this.metadata.getEntityIdMap(entity)[this.metadata.primaryColumns[0].propertyName]);
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.
                 */
                TreeRepository.prototype.findAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getMany();
                };
                /**
                 * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.
                 */
                TreeRepository.prototype.findAncestorsTree = function (entity) {
                    var _this = this;
                    // todo: throw exception if there is no column of this relation?
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getEntitiesAndRawResults()
                        .then(function (entitiesAndScalars) {
                        var relationMaps = _this.createRelationMaps("treeEntity", entitiesAndScalars.rawResults);
                        _this.buildParentEntityTree(entity, entitiesAndScalars.entities, relationMaps);
                        return entity;
                    });
                };
                /**
                 * Gets number of ancestors of the entity.
                 */
                TreeRepository.prototype.countAncestors = function (entity) {
                    return this
                        .createAncestorsQueryBuilder("treeEntity", "treeClosure", entity)
                        .getCount();
                };
                /**
                 * Moves entity to the children of then given entity.
                 *
                move(entity: Entity, to: Entity): Promise<void> {
                    return Promise.resolve();
                } */
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                TreeRepository.prototype.createRelationMaps = function (alias, rawResults) {
                    var _this = this;
                    return rawResults.map(function (rawResult) {
                        return {
                            id: rawResult[alias + "_" + _this.metadata.primaryColumns[0].databaseName],
                            parentId: rawResult[alias + "_" + _this.metadata.treeParentRelation.joinColumns[0].referencedColumn.databaseName]
                        };
                    });
                };
                TreeRepository.prototype.buildChildrenEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var childProperty = this.metadata.treeChildrenRelation.propertyName;
                    var parentEntityId = this.metadata.primaryColumns[0].getEntityValue(entity);
                    var childRelationMaps = relationMaps.filter(function (relationMap) { return relationMap.parentId === parentEntityId; });
                    var childIds = childRelationMaps.map(function (relationMap) { return relationMap.id; });
                    entity[childProperty] = entities.filter(function (entity) { return childIds.indexOf(_this.metadata.primaryColumns[0].getEntityValue(entity)) !== -1; });
                    entity[childProperty].forEach(function (childEntity) {
                        _this.buildChildrenEntityTree(childEntity, entities, relationMaps);
                    });
                };
                TreeRepository.prototype.buildParentEntityTree = function (entity, entities, relationMaps) {
                    var _this = this;
                    var parentProperty = this.metadata.treeParentRelation.propertyName;
                    var entityId = this.metadata.primaryColumns[0].getEntityValue(entity);
                    var parentRelationMap = relationMaps.find(function (relationMap) { return relationMap.id === entityId; });
                    var parentEntity = entities.find(function (entity) {
                        if (!parentRelationMap)
                            return false;
                        return entity[_this.metadata.primaryColumns[0].propertyName] === parentRelationMap.parentId;
                    });
                    if (parentEntity) {
                        entity[parentProperty] = parentEntity;
                        this.buildParentEntityTree(entity[parentProperty], entities, relationMaps);
                    }
                };
                return TreeRepository;
            }(Repository_1.Repository));
            exports_93("TreeRepository", TreeRepository);
        }
    };
});
System.register("typeorm/driver/mongodb/typings", ["events", "stream"], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    var events_1, stream_1;
    return {
        setters: [
            function (events_1_1) {
                events_1 = events_1_1;
            },
            function (stream_1_1) {
                stream_1 = stream_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/driver/mongodb/MongoQueryRunner", [], function (exports_95, context_95) {
    "use strict";
    var __moduleName = context_95 && context_95.id;
    var MongoQueryRunner;
    return {
        setters: [],
        execute: function () {
            /**
             * Runs queries on a single MongoDB connection.
             */
            MongoQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoQueryRunner.prototype.cursor = function (collectionName, query) {
                    return this.getCollection(collectionName).find(query || {});
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoQueryRunner.prototype.aggregate = function (collectionName, pipeline, options) {
                    return this.getCollection(collectionName).aggregate(pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoQueryRunner.prototype.bulkWrite = function (collectionName, operations, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).bulkWrite(operations, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoQueryRunner.prototype.count = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).count(query || {}, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoQueryRunner.prototype.createCollectionIndex = function (collectionName, fieldOrSpec, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).createIndex(fieldOrSpec, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoQueryRunner.prototype.createCollectionIndexes = function (collectionName, indexSpecs) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).createIndexes(indexSpecs)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoQueryRunner.prototype.deleteMany = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).deleteMany(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoQueryRunner.prototype.deleteOne = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).deleteOne(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoQueryRunner.prototype.distinct = function (collectionName, key, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).distinct(key, query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoQueryRunner.prototype.dropCollectionIndex = function (collectionName, indexName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).dropIndex(indexName, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoQueryRunner.prototype.dropCollectionIndexes = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).dropIndexes()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndDelete = function (collectionName, query, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndDelete(query, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndReplace = function (collectionName, query, replacement, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndReplace(query, replacement, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoQueryRunner.prototype.findOneAndUpdate = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).findOneAndUpdate(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoQueryRunner.prototype.geoHaystackSearch = function (collectionName, x, y, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).geoHaystackSearch(x, y, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoQueryRunner.prototype.geoNear = function (collectionName, x, y, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).geoNear(x, y, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoQueryRunner.prototype.group = function (collectionName, keys, condition, initial, reduce, finalize, command, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).group(keys, condition, initial, reduce, finalize, command, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoQueryRunner.prototype.collectionIndexes = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexes()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoQueryRunner.prototype.collectionIndexExists = function (collectionName, indexes) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexExists(indexes)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoQueryRunner.prototype.collectionIndexInformation = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).indexInformation(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoQueryRunner.prototype.initializeOrderedBulkOp = function (collectionName, options) {
                    return this.getCollection(collectionName).initializeOrderedBulkOp(options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoQueryRunner.prototype.initializeUnorderedBulkOp = function (collectionName, options) {
                    return this.getCollection(collectionName).initializeUnorderedBulkOp(options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoQueryRunner.prototype.insertMany = function (collectionName, docs, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).insertMany(docs, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoQueryRunner.prototype.insertOne = function (collectionName, doc, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).insertOne(doc, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoQueryRunner.prototype.isCapped = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).isCapped()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoQueryRunner.prototype.listCollectionIndexes = function (collectionName, options) {
                    return this.getCollection(collectionName).listIndexes(options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoQueryRunner.prototype.mapReduce = function (collectionName, map, reduce, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).mapReduce(map, reduce, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoQueryRunner.prototype.parallelCollectionScan = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).parallelCollectionScan(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoQueryRunner.prototype.reIndex = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).reIndex()];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoQueryRunner.prototype.rename = function (collectionName, newName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).rename(newName, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoQueryRunner.prototype.replaceOne = function (collectionName, query, doc, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).replaceOne(query, doc, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoQueryRunner.prototype.stats = function (collectionName, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).stats(options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoQueryRunner.prototype.updateMany = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).updateMany(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoQueryRunner.prototype.updateOne = function (collectionName, query, update, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.getCollection(collectionName).updateOne(query, update, options)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Public Implemented Methods (from QueryRunner)
                // -------------------------------------------------------------------------
                /**
                 * For MongoDB database we don't release connection, because its single connection.
                 */
                MongoQueryRunner.prototype.release = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Removes all collections from the currently connected database.
                 * Be careful with using this method and avoid using it in production or migrations
                 * (because it can clear all your database).
                 */
                MongoQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection.connection.dropDatabase()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                MongoQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                MongoQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                MongoQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                MongoQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                MongoQueryRunner.prototype.query = function (query, parameters) {
                    throw new Error("Executing SQL query is not supported by MongoDB driver.");
                };
                /**
                 * Insert a new row with given values into given table.
                 */
                MongoQueryRunner.prototype.insert = function (collectionName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .connection
                                        .collection(collectionName)
                                        .insertOne(keyValues)];
                                case 1:
                                    results = _a.sent();
                                    return [2 /*return*/, results.insertedId];
                            }
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                MongoQueryRunner.prototype.update = function (collectionName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .connection
                                        .collection(collectionName)
                                        .updateOne(conditions, valuesMap)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                MongoQueryRunner.prototype.delete = function (collectionName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (typeof conditions === "string")
                                        throw new Error("String condition is not supported by MongoDB driver.");
                                    return [4 /*yield*/, this.databaseConnection
                                            .connection
                                            .collection(collectionName)
                                            .deleteOne(conditions)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into the closure table.
                 */
                MongoQueryRunner.prototype.insertIntoClosureTable = function (collectionName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                MongoQueryRunner.prototype.loadTableSchema = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                MongoQueryRunner.prototype.loadTableSchemas = function (collectionNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                MongoQueryRunner.prototype.hasTable = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new table from the given table schema and column schemas inside it.
                 */
                MongoQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                MongoQueryRunner.prototype.hasColumn = function (collectionName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                MongoQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                MongoQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                MongoQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MongoQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                MongoQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                MongoQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                MongoQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                MongoQueryRunner.prototype.updatePrimaryKeys = function (tableSchema) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                MongoQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                MongoQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                MongoQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                MongoQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                MongoQueryRunner.prototype.createIndex = function (collectionName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                MongoQueryRunner.prototype.dropIndex = function (collectionName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            throw new Error("Schema update queries are not supported by MongoDB driver.");
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                MongoQueryRunner.prototype.normalizeType = function (typeOptions) {
                    throw new Error("Schema update queries are not supported by MongoDB driver.");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                MongoQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    throw new Error("Schema update queries are not supported by MongoDB driver.");
                };
                /**
                 * Drops collection.
                 */
                MongoQueryRunner.prototype.truncate = function (collectionName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.databaseConnection
                                        .connection
                                        .dropCollection(collectionName)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(MongoQueryRunner.prototype, "dbName", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Database name shortcut.
                     */
                    get: function () {
                        return this.driver.options.database;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets collection from the database with a given name.
                 */
                MongoQueryRunner.prototype.getCollection = function (collectionName) {
                    return this.databaseConnection.connection.collection(collectionName);
                };
                return MongoQueryRunner;
            }());
            exports_95("MongoQueryRunner", MongoQueryRunner);
        }
    };
});
System.register("typeorm/driver/mongodb/MongoDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/driver/mongodb/MongoQueryRunner", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/platform/PlatformTools"], function (exports_96, context_96) {
    "use strict";
    var __moduleName = context_96 && context_96.id;
    var ConnectionIsNotSetError_5, DriverPackageNotInstalledError_5, MongoQueryRunner_1, DriverOptionNotSetError_5, PlatformTools_6, MongoDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_5_1) {
                ConnectionIsNotSetError_5 = ConnectionIsNotSetError_5_1;
            },
            function (DriverPackageNotInstalledError_5_1) {
                DriverPackageNotInstalledError_5 = DriverPackageNotInstalledError_5_1;
            },
            function (MongoQueryRunner_1_1) {
                MongoQueryRunner_1 = MongoQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_5_1) {
                DriverOptionNotSetError_5 = DriverOptionNotSetError_5_1;
            },
            function (PlatformTools_6_1) {
                PlatformTools_6 = PlatformTools_6_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with MongoDB.
             */
            MongoDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoDriver(options, logger, mongodb) {
                    // validate options to make sure everything is correct and driver will be able to establish connection
                    this.validateOptions(options);
                    // if mongodb package instance was not set explicitly then try to load it
                    if (!mongodb)
                        mongodb = this.loadDependencies();
                    this.options = options;
                    this.logger = logger;
                    this.mongodb = mongodb;
                }
                // -------------------------------------------------------------------------
                // Public Overridden Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                MongoDriver.prototype.connect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        _this.mongodb.MongoClient.connect(_this.buildConnectionUrl(), _this.options.extra, function (err, database) {
                            if (err)
                                return fail(err);
                            _this.pool = database;
                            var databaseConnection = {
                                id: 1,
                                connection: _this.pool,
                                isTransactionActive: false
                            };
                            _this.queryRunner = new MongoQueryRunner_1.MongoQueryRunner(databaseConnection, _this, _this.logger);
                            ok();
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                MongoDriver.prototype.disconnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (!this.pool)
                                throw new ConnectionIsNotSetError_5.ConnectionIsNotSetError("mongodb");
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    var handler = function (err) { return err ? fail(err) : ok(); };
                                    _this.pool.close(handler);
                                    _this.pool = undefined;
                                })];
                        });
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                MongoDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.pool)
                                return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_5.ConnectionIsNotSetError("mongodb"))];
                            return [2 /*return*/, this.queryRunner];
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                MongoDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.mongodb,
                        connection: this.pool
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                MongoDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    throw new Error("This operation is not supported by Mongodb driver.");
                };
                /**
                 * Escapes a column name.
                 */
                MongoDriver.prototype.escapeColumnName = function (columnName) {
                    return columnName;
                };
                /**
                 * Escapes an alias.
                 */
                MongoDriver.prototype.escapeAliasName = function (aliasName) {
                    return aliasName;
                };
                /**
                 * Escapes a table name.
                 */
                MongoDriver.prototype.escapeTableName = function (tableName) {
                    return tableName;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                MongoDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                MongoDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                    }
                    // if (columnMetadata.isObjectId)
                    //     return new ObjectID(value);
                    return value;
                };
                // todo: make better abstraction
                MongoDriver.prototype.syncSchema = function (entityMetadatas) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.createQueryRunner()];
                                case 1:
                                    queryRunner = _a.sent();
                                    promises = [];
                                    return [4 /*yield*/, Promise.all(entityMetadatas.map(function (metadata) {
                                            metadata.indices.forEach(function (index) {
                                                var options = { name: index.name };
                                                promises.push(queryRunner.createCollectionIndex(metadata.tableName, index.columnNamesWithOrderingMap, options));
                                            });
                                        }))];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Validate driver options to make sure everything is correct and driver will be able to establish connection.
                 */
                MongoDriver.prototype.validateOptions = function (options) {
                    if (!options.url) {
                        if (!options.database)
                            throw new DriverOptionNotSetError_5.DriverOptionNotSetError("database");
                    }
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                MongoDriver.prototype.loadDependencies = function () {
                    try {
                        return PlatformTools_6.PlatformTools.load("mongodb"); // try to load native driver dynamically
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_5.DriverPackageNotInstalledError("MongoDB", "mongodb");
                    }
                };
                /**
                 * Builds connection url that is passed to underlying driver to perform connection to the mongodb database.
                 */
                MongoDriver.prototype.buildConnectionUrl = function () {
                    if (this.options.url)
                        return this.options.url;
                    return "mongodb://" + (this.options.host || "127.0.0.1") + ":" + (this.options.port || "27017") + "/" + this.options.database;
                };
                return MongoDriver;
            }());
            exports_96("MongoDriver", MongoDriver);
        }
    };
});
System.register("typeorm/query-builder/transformer/DocumentToEntityTransformer", [], function (exports_97, context_97) {
    "use strict";
    var __moduleName = context_97 && context_97.id;
    var DocumentToEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms raw document into entity object.
             * Entity is constructed based on its entity metadata.
             */
            DocumentToEntityTransformer = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function DocumentToEntityTransformer(// private selectionMap: AliasMap,
                    // private joinMappings: JoinMapping[],
                    // private relationCountMetas: RelationCountAttribute[],
                    enableRelationIdValues) {
                    if (enableRelationIdValues === void 0) { enableRelationIdValues = false; }
                    this.enableRelationIdValues = enableRelationIdValues;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                DocumentToEntityTransformer.prototype.transformAll = function (documents, metadata) {
                    var _this = this;
                    return documents.map(function (document) { return _this.transform(document, metadata); });
                };
                DocumentToEntityTransformer.prototype.transform = function (document, metadata) {
                    var entity = metadata.create();
                    var hasData = false;
                    // handle _id property the special way
                    if (metadata.objectIdColumn && document[metadata.objectIdColumn.databaseNameWithoutPrefixes]) {
                        // todo: we can't use driver in this class
                        // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?
                        // entity[metadata.objectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.objectIdColumn.name"], metadata.objectIdColumn);
                        entity[metadata.objectIdColumn.propertyName] = document[metadata.objectIdColumn.databaseNameWithoutPrefixes];
                        hasData = true;
                    }
                    // add special columns that contains relation ids
                    if (this.enableRelationIdValues) {
                        metadata.columns.filter(function (column) { return !!column.relationMetadata; }).forEach(function (column) {
                            var valueInObject = document[column.databaseNameWithoutPrefixes];
                            if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {
                                // todo: we can't use driver in this class
                                // const value = this.driver.prepareHydratedValue(valueInObject, column);
                                entity[column.propertyName] = valueInObject;
                                hasData = true;
                            }
                        });
                    }
                    /*this.joinMappings
                        .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)
                        .map(joinMapping => {
                            const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);
                            const isResultArray = joinMapping.isMany;
                            const result = !isResultArray ? relatedEntities[0] : relatedEntities;
            
                            if (result && (!isResultArray || result.length > 0)) {
                                entity[joinMapping.propertyName] = result;
                                hasData = true;
                            }
                        });*/
                    // get value from columns selections and put them into object
                    metadata.ownColumns.forEach(function (column) {
                        var valueInObject = document[column.databaseNameWithoutPrefixes];
                        if (valueInObject !== undefined &&
                            valueInObject !== null &&
                            column.propertyName &&
                            !column.isVirtual &&
                            !column.isParentId &&
                            !column.isDiscriminator) {
                            // const value = this.driver.prepareHydratedValue(valueInObject, column);
                            entity[column.propertyName] = valueInObject;
                            hasData = true;
                        }
                    });
                    var addEmbeddedValuesRecursively = function (entity, document, embeddeds) {
                        embeddeds.forEach(function (embedded) {
                            if (!document[embedded.prefix])
                                return;
                            if (embedded.isArray) {
                                entity[embedded.propertyName] = document[embedded.prefix].map(function (subValue) {
                                    var newItem = embedded.create();
                                    embedded.columns.forEach(function (column) {
                                        newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];
                                    });
                                    return newItem;
                                });
                            }
                            else {
                                embedded.columns.forEach(function (column) {
                                    var value = document[embedded.prefix][column.databaseNameWithoutPrefixes];
                                    if (!value)
                                        return;
                                    if (!entity[embedded.propertyName])
                                        entity[embedded.propertyName] = embedded.create();
                                    entity[embedded.propertyName][column.propertyName] = value;
                                });
                            }
                            addEmbeddedValuesRecursively(entity[embedded.propertyName], document[embedded.prefix], embedded.embeddeds);
                        });
                    };
                    addEmbeddedValuesRecursively(entity, document, metadata.embeddeds);
                    // if relation is loaded then go into it recursively and transform its values too
                    /*metadata.relations.forEach(relation => {
                        const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);
                        if (relationAlias) {
                            const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "join" && joinMapping.alias === relationAlias);
                            const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);
                            const isResultArray = relation.isManyToMany || relation.isOneToMany;
                            const result = !isResultArray ? relatedEntities[0] : relatedEntities;
            
                            if (result) {
                                let propertyName = relation.propertyName;
                                if (joinMapping) {
                                    propertyName = joinMapping.propertyName;
                                }
            
                                if (relation.isLazy) {
                                    entity["__" + propertyName + "__"] = result;
                                } else {
                                    entity[propertyName] = result;
                                }
            
                                if (!isResultArray || result.length > 0)
                                    hasData = true;
                            }
                        }
            
                        // if relation has id field then relation id/ids to that field.
                        if (relation.isManyToMany) {
                            if (relationAlias) {
                                const ids: any[] = [];
                                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === "relationId" && joinMapping.alias === relationAlias);
            
                                if (relation.idField || joinMapping) {
                                    const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;
                                    const junctionMetadata = relation.junctionEntityMetadata;
                                    const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;
            
                                    rawSqlResults.forEach(results => {
                                        if (relationAlias) {
                                            const resultsKey = relationAlias.name + "_" + columnName;
                                            const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);
                                            if (value !== undefined && value !== null)
                                                ids.push(value);
                                        }
                                    });
            
                                    if (ids && ids.length)
                                        entity[propertyName] = ids;
                                }
                            }
                        } else if (relation.idField) {
                            const relationName = relation.name;
                            entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + "_" + relationName], relation.referencedColumn);
                        }
            
                        // if relation counter
                        this.relationCountMetas.forEach(joinMeta => {
                            if (joinMeta.alias === relationAlias) {
                                // console.log("relation count was found for relation: ", relation);
                                // joinMeta.entity = entity;
                                joinMeta.entities.push({ entity: entity, metadata: metadata });
                                // console.log(joinMeta);
                                // console.log("---------------------");
                            }
                        });
                    });*/
                    return hasData ? entity : null;
                };
                return DocumentToEntityTransformer;
            }());
            exports_97("DocumentToEntityTransformer", DocumentToEntityTransformer);
        }
    };
});
System.register("typeorm/find-options/FindOptionsUtils", [], function (exports_98, context_98) {
    "use strict";
    var __moduleName = context_98 && context_98.id;
    var FindOptionsUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utilities to work with FindOptions.
             */
            FindOptionsUtils = (function () {
                function FindOptionsUtils() {
                }
                /**
                 * Checks if given object is really instance of FindOneOptions interface.
                 */
                FindOptionsUtils.isFindOneOptions = function (object) {
                    var possibleOptions = object;
                    return possibleOptions &&
                        (possibleOptions.where instanceof Object ||
                            possibleOptions.join instanceof Object ||
                            possibleOptions.order instanceof Object);
                };
                /**
                 * Checks if given object is really instance of FindManyOptions interface.
                 */
                FindOptionsUtils.isFindManyOptions = function (object) {
                    var possibleOptions = object;
                    return possibleOptions &&
                        (possibleOptions.where instanceof Object ||
                            possibleOptions.join instanceof Object ||
                            possibleOptions.order instanceof Object ||
                            typeof possibleOptions.skip === "number" ||
                            typeof possibleOptions.take === "number");
                };
                /**
                 * Checks if given object is really instance of FindOptions interface.
                 */
                FindOptionsUtils.extractFindOneOptionsAlias = function (object) {
                    if (this.isFindOneOptions(object) && object.join)
                        return object.join.alias;
                    return undefined;
                };
                /**
                 * Checks if given object is really instance of FindOptions interface.
                 */
                FindOptionsUtils.extractFindManyOptionsAlias = function (object) {
                    if (this.isFindManyOptions(object) && object.join)
                        return object.join.alias;
                    return undefined;
                };
                /**
                 * Applies give find one options to the given query builder.
                 */
                FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder = function (qb, options) {
                    if (this.isFindOneOptions(options))
                        return this.applyOptionsToQueryBuilder(qb, options);
                    if (options)
                        return this.applyConditions(qb, options);
                    return qb;
                };
                /**
                 * Applies give find many options to the given query builder.
                 */
                FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder = function (qb, options) {
                    if (this.isFindManyOptions(options))
                        return this.applyOptionsToQueryBuilder(qb, options);
                    if (options)
                        return this.applyConditions(qb, options);
                    return qb;
                };
                /**
                 * Applies give find options to the given query builder.
                 */
                FindOptionsUtils.applyOptionsToQueryBuilder = function (qb, options) {
                    // if options are not set then simply return query builder. This is made for simplicity of usage.
                    if (!options || !this.isFindOneOptions(options))
                        return qb;
                    // apply all options from FindOptions
                    if (options.where)
                        this.applyConditions(qb, options.where);
                    if (options.skip)
                        qb.skip(options.skip);
                    if (options.take)
                        qb.take(options.take);
                    if (options.order)
                        Object.keys(options.order).forEach(function (key) {
                            qb.addOrderBy(qb.alias + "." + key, options.order[key]);
                        });
                    if (options.join) {
                        if (options.join.leftJoin)
                            Object.keys(options.join.leftJoin).forEach(function (key) {
                                qb.leftJoin(options.join.leftJoin[key], key);
                            });
                        if (options.join.innerJoin)
                            Object.keys(options.join.innerJoin).forEach(function (key) {
                                qb.innerJoin(options.join.innerJoin[key], key);
                            });
                        if (options.join.leftJoinAndSelect)
                            Object.keys(options.join.leftJoinAndSelect).forEach(function (key) {
                                qb.leftJoinAndSelect(options.join.leftJoinAndSelect[key], key);
                            });
                        if (options.join.innerJoinAndSelect)
                            Object.keys(options.join.innerJoinAndSelect).forEach(function (key) {
                                qb.innerJoinAndSelect(options.join.innerJoinAndSelect[key], key);
                            });
                    }
                    return qb;
                };
                /**
                 * Applies given simple conditions set to a given query builder.
                 */
                FindOptionsUtils.applyConditions = function (qb, conditions) {
                    Object.keys(conditions).forEach(function (key, index) {
                        if (conditions[key] === null) {
                            qb.andWhere(qb.alias + "." + key + " IS NULL");
                        }
                        else {
                            var parameterName = "where_" + index;
                            qb.andWhere(qb.alias + "." + key + "=:" + parameterName)
                                .setParameter(parameterName, conditions[key]);
                        }
                    });
                    return qb;
                };
                return FindOptionsUtils;
            }());
            exports_98("FindOptionsUtils", FindOptionsUtils);
        }
    };
});
System.register("typeorm/entity-manager/MongoEntityManager", ["typeorm/entity-manager/EntityManager", "typeorm/query-builder/transformer/DocumentToEntityTransformer", "typeorm/find-options/FindOptionsUtils"], function (exports_99, context_99) {
    "use strict";
    var __moduleName = context_99 && context_99.id;
    var EntityManager_1, DocumentToEntityTransformer_1, FindOptionsUtils_1, MongoEntityManager;
    return {
        setters: [
            function (EntityManager_1_1) {
                EntityManager_1 = EntityManager_1_1;
            },
            function (DocumentToEntityTransformer_1_1) {
                DocumentToEntityTransformer_1 = DocumentToEntityTransformer_1_1;
            },
            function (FindOptionsUtils_1_1) {
                FindOptionsUtils_1 = FindOptionsUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
             * whatever entity type are you passing.
             *
             * This implementation is used for MongoDB driver which has some specifics in its EntityManager.
             */
            MongoEntityManager = (function (_super) {
                __extends(MongoEntityManager, _super);
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MongoEntityManager(connection, queryRunnerProvider) {
                    return _super.call(this, connection, queryRunnerProvider) || this;
                }
                // -------------------------------------------------------------------------
                // Overridden Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes raw SQL query and returns raw database results.
                 */
                MongoEntityManager.prototype.query = function (query, parameters) {
                    throw new Error("Queries aren't supported by MongoDB.");
                };
                /**
                 * Wraps given function execution (and all operations made there) in a transaction.
                 * All database operations must be executed using provided entity manager.
                 */
                MongoEntityManager.prototype.transaction = function (runInTransaction) {
                    throw new Error("Transactions aren't supported by MongoDB.");
                };
                /**
                 * Using Query Builder with MongoDB is not supported yet.
                 * Calling this method will return an error.
                 */
                MongoEntityManager.prototype.createQueryBuilder = function (entityClassOrName, alias, queryRunnerProvider) {
                    throw new Error("Query Builder is not supported by MongoDB.");
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                MongoEntityManager.prototype.find = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [2 /*return*/, cursor.toArray()];
                            }
                        });
                    });
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                MongoEntityManager.prototype.findAndCount = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor, _a, results, count;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _b.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, Promise.all([
                                            cursor.toArray(),
                                            this.count(entityClassOrName, query),
                                        ])];
                                case 2:
                                    _a = _b.sent(), results = _a[0], count = _a[1];
                                    return [2 /*return*/, [results, parseInt(count)]];
                            }
                        });
                    });
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                MongoEntityManager.prototype.findByIds = function (entityClassOrName, ids, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, query, objectIdInstance, cursor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClassOrName);
                                    query = this.convertFindManyOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
                                    objectIdInstance = require("mongodb").ObjectID;
                                    query["_id"] = { $in: ids.map(function (id) {
                                            if (id instanceof objectIdInstance)
                                                return id;
                                            return id[metadata.objectIdColumn.propertyName];
                                        }) };
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.skip)
                                            cursor.skip(optionsOrConditions.skip);
                                        if (optionsOrConditions.take)
                                            cursor.limit(optionsOrConditions.take);
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.toArray()];
                                case 2: return [2 /*return*/, _a.sent()];
                            }
                        });
                    });
                };
                /**
                 * Finds first entity that matches given conditions and/or find options.
                 */
                MongoEntityManager.prototype.findOne = function (entityClassOrName, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions);
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.limit(1).toArray()];
                                case 2:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length > 0 ? result[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                MongoEntityManager.prototype.findOneById = function (entityClassOrName, id, optionsOrConditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var query, cursor, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    query = this.convertFindOneOptionsOrConditionsToMongodbQuery(optionsOrConditions) || {};
                                    query["_id"] = id;
                                    return [4 /*yield*/, this.createEntityCursor(entityClassOrName, query)];
                                case 1:
                                    cursor = _a.sent();
                                    if (FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions)) {
                                        if (optionsOrConditions.order)
                                            cursor.sort(this.convertFindOptionsOrderToOrderCriteria(optionsOrConditions.order));
                                    }
                                    return [4 /*yield*/, cursor.limit(1).toArray()];
                                case 2:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length > 0 ? result[0] : undefined];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoEntityManager.prototype.createCursor = function (entityClassOrName, query) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.cursor(metadata.tableName, query);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 * This returns modified version of cursor that transforms each result into Entity model.
                 */
                MongoEntityManager.prototype.createEntityCursor = function (entityClassOrName, query) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    var cursor = this.createCursor(entityClassOrName, query);
                    var ParentCursor = require("mongodb").Cursor;
                    cursor.toArray = function (callback) {
                        if (callback) {
                            ParentCursor.prototype.toArray.call(this, function (error, results) {
                                if (error) {
                                    callback(error, results);
                                    return;
                                }
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return callback(error, transformer.transformAll(results, metadata));
                            });
                        }
                        else {
                            return ParentCursor.prototype.toArray.call(this).then(function (results) {
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return transformer.transformAll(results, metadata);
                            });
                        }
                    };
                    cursor.next = function (callback) {
                        if (callback) {
                            ParentCursor.prototype.next.call(this, function (error, result) {
                                if (error || !result) {
                                    callback(error, result);
                                    return;
                                }
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return callback(error, transformer.transform(result, metadata));
                            });
                        }
                        else {
                            return ParentCursor.prototype.next.call(this).then(function (result) {
                                if (!result)
                                    return result;
                                var transformer = new DocumentToEntityTransformer_1.DocumentToEntityTransformer();
                                return transformer.transform(result, metadata);
                            });
                        }
                    };
                    return cursor;
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoEntityManager.prototype.aggregate = function (entityClassOrName, pipeline, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.aggregate(metadata.tableName, pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoEntityManager.prototype.bulkWrite = function (entityClassOrName, operations, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.bulkWrite(metadata.tableName, operations, options);
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoEntityManager.prototype.count = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.count(metadata.tableName, query, options);
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoEntityManager.prototype.createCollectionIndex = function (entityClassOrName, fieldOrSpec, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.createCollectionIndex(metadata.tableName, fieldOrSpec, options);
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error.
                 * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoEntityManager.prototype.createCollectionIndexes = function (entityClassOrName, indexSpecs) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.createCollectionIndexes(metadata.tableName, indexSpecs);
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoEntityManager.prototype.deleteMany = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.deleteMany(metadata.tableName, query, options);
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoEntityManager.prototype.deleteOne = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.deleteOne(metadata.tableName, query, options);
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoEntityManager.prototype.distinct = function (entityClassOrName, key, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.distinct(metadata.tableName, key, query, options);
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoEntityManager.prototype.dropCollectionIndex = function (entityClassOrName, indexName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.dropCollectionIndex(metadata.tableName, indexName, options);
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoEntityManager.prototype.dropCollectionIndexes = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.dropCollectionIndexes(metadata.tableName);
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndDelete = function (entityClassOrName, query, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndDelete(metadata.tableName, query, options);
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndReplace = function (entityClassOrName, query, replacement, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndReplace(metadata.tableName, query, replacement, options);
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoEntityManager.prototype.findOneAndUpdate = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.findOneAndUpdate(metadata.tableName, query, update, options);
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoEntityManager.prototype.geoHaystackSearch = function (entityClassOrName, x, y, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.geoHaystackSearch(metadata.tableName, x, y, options);
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoEntityManager.prototype.geoNear = function (entityClassOrName, x, y, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.geoNear(metadata.tableName, x, y, options);
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoEntityManager.prototype.group = function (entityClassOrName, keys, condition, initial, reduce, finalize, command, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.group(metadata.tableName, keys, condition, initial, reduce, finalize, command, options);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoEntityManager.prototype.collectionIndexes = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexes(metadata.tableName);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoEntityManager.prototype.collectionIndexExists = function (entityClassOrName, indexes) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexExists(metadata.tableName, indexes);
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoEntityManager.prototype.collectionIndexInformation = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.collectionIndexInformation(metadata.tableName, options);
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoEntityManager.prototype.initializeOrderedBulkOp = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.initializeOrderedBulkOp(metadata.tableName, options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoEntityManager.prototype.initializeUnorderedBulkOp = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.initializeUnorderedBulkOp(metadata.tableName, options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoEntityManager.prototype.insertMany = function (entityClassOrName, docs, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.insertMany(metadata.tableName, docs, options);
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoEntityManager.prototype.insertOne = function (entityClassOrName, doc, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.insertOne(metadata.tableName, doc, options);
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoEntityManager.prototype.isCapped = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.isCapped(metadata.tableName);
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoEntityManager.prototype.listCollectionIndexes = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.listCollectionIndexes(metadata.tableName, options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoEntityManager.prototype.mapReduce = function (entityClassOrName, map, reduce, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.mapReduce(metadata.tableName, map, reduce, options);
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoEntityManager.prototype.parallelCollectionScan = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.parallelCollectionScan(metadata.tableName, options);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoEntityManager.prototype.reIndex = function (entityClassOrName) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.reIndex(metadata.tableName);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoEntityManager.prototype.rename = function (entityClassOrName, newName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.rename(metadata.tableName, newName, options);
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoEntityManager.prototype.replaceOne = function (entityClassOrName, query, doc, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.replaceOne(metadata.tableName, query, doc, options);
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoEntityManager.prototype.stats = function (entityClassOrName, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.stats(metadata.tableName, options);
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoEntityManager.prototype.updateMany = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.updateMany(metadata.tableName, query, update, options);
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoEntityManager.prototype.updateOne = function (entityClassOrName, query, update, options) {
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    return this.queryRunner.updateOne(metadata.tableName, query, update, options);
                };
                Object.defineProperty(MongoEntityManager.prototype, "queryRunner", {
                    // -------------------------------------------------------------------------
                    // Protected Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.connection.driver.queryRunner;
                    },
                    enumerable: true,
                    configurable: true
                });
                MongoEntityManager.prototype.convertFindManyOptionsOrConditionsToMongodbQuery = function (optionsOrConditions) {
                    if (!optionsOrConditions)
                        return undefined;
                    return FindOptionsUtils_1.FindOptionsUtils.isFindManyOptions(optionsOrConditions) ? optionsOrConditions.where : optionsOrConditions;
                };
                MongoEntityManager.prototype.convertFindOneOptionsOrConditionsToMongodbQuery = function (optionsOrConditions) {
                    if (!optionsOrConditions)
                        return undefined;
                    return FindOptionsUtils_1.FindOptionsUtils.isFindOneOptions(optionsOrConditions) ? optionsOrConditions.where : optionsOrConditions;
                };
                MongoEntityManager.prototype.convertFindOptionsOrderToOrderCriteria = function (order) {
                    var orderCriteria = {};
                    Object.keys(order).forEach(function (key) { return orderCriteria[key] = [key, order[key].toLowerCase()]; });
                    return orderCriteria;
                };
                return MongoEntityManager;
            }(EntityManager_1.EntityManager));
            exports_99("MongoEntityManager", MongoEntityManager);
        }
    };
});
System.register("typeorm/repository/MongoRepository", ["typeorm/repository/Repository"], function (exports_100, context_100) {
    "use strict";
    var __moduleName = context_100 && context_100.id;
    var Repository_2, MongoRepository;
    return {
        setters: [
            function (Repository_2_1) {
                Repository_2 = Repository_2_1;
            }
        ],
        execute: function () {
            /**
             * Repository used to manage mongodb documents of a single entity type.
             */
            MongoRepository = (function (_super) {
                __extends(MongoRepository, _super);
                function MongoRepository() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                // -------------------------------------------------------------------------
                // Overridden Methods
                // -------------------------------------------------------------------------
                /**
                 * Raw SQL query execution is not supported by MongoDB.
                 * Calling this method will return an error.
                 */
                MongoRepository.prototype.query = function (query, parameters) {
                    throw new Error("Queries aren't supported by MongoDB.");
                };
                /**
                 * Using Query Builder with MongoDB is not supported yet.
                 * Calling this method will return an error.
                 */
                MongoRepository.prototype.createQueryBuilder = function (alias, queryRunnerProvider) {
                    throw new Error("Query Builder is not supported by MongoDB.");
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                MongoRepository.prototype.find = function (optionsOrConditions) {
                    return this.manager.find(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                MongoRepository.prototype.findAndCount = function (optionsOrConditions) {
                    return this.manager.findAndCount(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                MongoRepository.prototype.findByIds = function (ids, optionsOrConditions) {
                    return this.manager.findByIds(this.metadata.target, ids, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions and/or find options.
                 */
                MongoRepository.prototype.findOne = function (optionsOrConditions) {
                    return this.manager.findOne(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                MongoRepository.prototype.findOneById = function (id, optionsOrConditions) {
                    return this.manager.findOneById(this.metadata.target, id, optionsOrConditions);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 */
                MongoRepository.prototype.createCursor = function (query) {
                    return this.manager.createCursor(this.metadata.target, query);
                };
                /**
                 * Creates a cursor for a query that can be used to iterate over results from MongoDB.
                 * This returns modified version of cursor that transforms each result into Entity model.
                 */
                MongoRepository.prototype.createEntityCursor = function (query) {
                    return this.manager.createEntityCursor(this.metadata.target, query);
                };
                /**
                 * Execute an aggregation framework pipeline against the collection.
                 */
                MongoRepository.prototype.aggregate = function (pipeline, options) {
                    return this.manager.aggregate(this.metadata.target, pipeline, options);
                };
                /**
                 * Perform a bulkWrite operation without a fluent API.
                 */
                MongoRepository.prototype.bulkWrite = function (operations, options) {
                    return this.manager.bulkWrite(this.metadata.target, operations, options);
                };
                /**
                 * Count number of matching documents in the db to a query.
                 */
                MongoRepository.prototype.count = function (query, options) {
                    return this.manager.count(this.metadata.target, query || {}, options);
                };
                /**
                 * Creates an index on the db and collection.
                 */
                MongoRepository.prototype.createCollectionIndex = function (fieldOrSpec, options) {
                    return this.manager.createCollectionIndex(this.metadata.target, fieldOrSpec, options);
                };
                /**
                 * Creates multiple indexes in the collection, this method is only supported for MongoDB 2.6 or higher.
                 * Earlier version of MongoDB will throw a command not supported error.
                 * Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
                 */
                MongoRepository.prototype.createCollectionIndexes = function (indexSpecs) {
                    return this.manager.createCollectionIndexes(this.metadata.target, indexSpecs);
                };
                /**
                 * Delete multiple documents on MongoDB.
                 */
                MongoRepository.prototype.deleteMany = function (query, options) {
                    return this.manager.deleteMany(this.metadata.tableName, query, options);
                };
                /**
                 * Delete a document on MongoDB.
                 */
                MongoRepository.prototype.deleteOne = function (query, options) {
                    return this.manager.deleteOne(this.metadata.tableName, query, options);
                };
                /**
                 * The distinct command returns returns a list of distinct values for the given key across a collection.
                 */
                MongoRepository.prototype.distinct = function (key, query, options) {
                    return this.manager.distinct(this.metadata.tableName, key, query, options);
                };
                /**
                 * Drops an index from this collection.
                 */
                MongoRepository.prototype.dropCollectionIndex = function (indexName, options) {
                    return this.manager.dropCollectionIndex(this.metadata.tableName, indexName, options);
                };
                /**
                 * Drops all indexes from the collection.
                 */
                MongoRepository.prototype.dropCollectionIndexes = function () {
                    return this.manager.dropCollectionIndexes(this.metadata.tableName);
                };
                /**
                 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndDelete = function (query, options) {
                    return this.manager.findOneAndDelete(this.metadata.tableName, query, options);
                };
                /**
                 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndReplace = function (query, replacement, options) {
                    return this.manager.findOneAndReplace(this.metadata.tableName, query, replacement, options);
                };
                /**
                 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
                 */
                MongoRepository.prototype.findOneAndUpdate = function (query, update, options) {
                    return this.manager.findOneAndUpdate(this.metadata.tableName, query, update, options);
                };
                /**
                 * Execute a geo search using a geo haystack index on a collection.
                 */
                MongoRepository.prototype.geoHaystackSearch = function (x, y, options) {
                    return this.manager.geoHaystackSearch(this.metadata.tableName, x, y, options);
                };
                /**
                 * Execute the geoNear command to search for items in the collection.
                 */
                MongoRepository.prototype.geoNear = function (x, y, options) {
                    return this.manager.geoNear(this.metadata.tableName, x, y, options);
                };
                /**
                 * Run a group command across a collection.
                 */
                MongoRepository.prototype.group = function (keys, condition, initial, reduce, finalize, command, options) {
                    return this.manager.group(this.metadata.tableName, keys, condition, initial, reduce, finalize, command, options);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoRepository.prototype.collectionIndexes = function () {
                    return this.manager.collectionIndexes(this.metadata.tableName);
                };
                /**
                 * Retrieve all the indexes on the collection.
                 */
                MongoRepository.prototype.collectionIndexExists = function (indexes) {
                    return this.manager.collectionIndexExists(this.metadata.tableName, indexes);
                };
                /**
                 * Retrieves this collections index info.
                 */
                MongoRepository.prototype.collectionIndexInformation = function (options) {
                    return this.manager.collectionIndexInformation(this.metadata.tableName, options);
                };
                /**
                 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
                 */
                MongoRepository.prototype.initializeOrderedBulkOp = function (options) {
                    return this.manager.initializeOrderedBulkOp(this.metadata.tableName, options);
                };
                /**
                 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
                 */
                MongoRepository.prototype.initializeUnorderedBulkOp = function (options) {
                    return this.manager.initializeUnorderedBulkOp(this.metadata.tableName, options);
                };
                /**
                 * Inserts an array of documents into MongoDB.
                 */
                MongoRepository.prototype.insertMany = function (docs, options) {
                    return this.manager.insertMany(this.metadata.tableName, docs, options);
                };
                /**
                 * Inserts a single document into MongoDB.
                 */
                MongoRepository.prototype.insertOne = function (doc, options) {
                    return this.manager.insertOne(this.metadata.tableName, doc, options);
                };
                /**
                 * Returns if the collection is a capped collection.
                 */
                MongoRepository.prototype.isCapped = function () {
                    return this.manager.isCapped(this.metadata.tableName);
                };
                /**
                 * Get the list of all indexes information for the collection.
                 */
                MongoRepository.prototype.listCollectionIndexes = function (options) {
                    return this.manager.listCollectionIndexes(this.metadata.tableName, options);
                };
                /**
                 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
                 */
                MongoRepository.prototype.mapReduce = function (map, reduce, options) {
                    return this.manager.mapReduce(this.metadata.tableName, map, reduce, options);
                };
                /**
                 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection.
                 * There are no ordering guarantees for returned results.
                 */
                MongoRepository.prototype.parallelCollectionScan = function (options) {
                    return this.manager.parallelCollectionScan(this.metadata.tableName, options);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoRepository.prototype.reIndex = function () {
                    return this.manager.reIndex(this.metadata.tableName);
                };
                /**
                 * Reindex all indexes on the collection Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
                 */
                MongoRepository.prototype.rename = function (newName, options) {
                    return this.manager.rename(this.metadata.tableName, newName, options);
                };
                /**
                 * Replace a document on MongoDB.
                 */
                MongoRepository.prototype.replaceOne = function (query, doc, options) {
                    return this.manager.replaceOne(this.metadata.tableName, query, doc, options);
                };
                /**
                 * Get all the collection statistics.
                 */
                MongoRepository.prototype.stats = function (options) {
                    return this.manager.stats(this.metadata.tableName, options);
                };
                /**
                 * Update multiple documents on MongoDB.
                 */
                MongoRepository.prototype.updateMany = function (query, update, options) {
                    return this.manager.updateMany(this.metadata.tableName, query, update, options);
                };
                /**
                 * Update a single document on MongoDB.
                 */
                MongoRepository.prototype.updateOne = function (query, update, options) {
                    return this.manager.updateOne(this.metadata.tableName, query, update, options);
                };
                return MongoRepository;
            }(Repository_2.Repository));
            exports_100("MongoRepository", MongoRepository);
        }
    };
});
System.register("typeorm/repository/RepositoryFactory", ["typeorm/repository/TreeRepository", "typeorm/repository/Repository", "typeorm/repository/SpecificRepository", "typeorm/driver/mongodb/MongoDriver", "typeorm/repository/MongoRepository"], function (exports_101, context_101) {
    "use strict";
    var __moduleName = context_101 && context_101.id;
    var TreeRepository_1, Repository_3, SpecificRepository_1, MongoDriver_1, MongoRepository_1, RepositoryFactory;
    return {
        setters: [
            function (TreeRepository_1_1) {
                TreeRepository_1 = TreeRepository_1_1;
            },
            function (Repository_3_1) {
                Repository_3 = Repository_3_1;
            },
            function (SpecificRepository_1_1) {
                SpecificRepository_1 = SpecificRepository_1_1;
            },
            function (MongoDriver_1_1) {
                MongoDriver_1 = MongoDriver_1_1;
            },
            function (MongoRepository_1_1) {
                MongoRepository_1 = MongoRepository_1_1;
            }
        ],
        execute: function () {
            /**
             * Factory used to create different types of repositories.
             */
            RepositoryFactory = (function () {
                function RepositoryFactory() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a regular repository.
                 */
                RepositoryFactory.prototype.createRepository = function (manager, metadata, queryRunnerProvider) {
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    var repository;
                    if (manager.connection.driver instanceof MongoDriver_1.MongoDriver) {
                        repository = new MongoRepository_1.MongoRepository();
                    }
                    else {
                        repository = new Repository_3.Repository();
                    }
                    repository["manager"] = manager;
                    repository["metadata"] = metadata;
                    repository["queryRunnerProvider"] = queryRunnerProvider;
                    return repository;
                };
                /**
                 * Creates a tree repository.
                 */
                RepositoryFactory.prototype.createTreeRepository = function (manager, metadata, queryRunnerProvider) {
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    var repository = new TreeRepository_1.TreeRepository();
                    repository["manager"] = manager;
                    repository["metadata"] = metadata;
                    repository["queryRunnerProvider"] = queryRunnerProvider;
                    return repository;
                };
                /**
                 * Creates a specific repository.
                 */
                RepositoryFactory.prototype.createSpecificRepository = function (connection, metadata, queryRunnerProvider) {
                    return new SpecificRepository_1.SpecificRepository(connection, metadata, queryRunnerProvider);
                };
                return RepositoryFactory;
            }());
            exports_101("RepositoryFactory", RepositoryFactory);
        }
    };
});
System.register("typeorm/container", [], function (exports_102, context_102) {
    "use strict";
    var __moduleName = context_102 && context_102.id;
    /**
     * Sets container to be used by this library.
     */
    function useContainer(iocContainer, options) {
        userContainer = iocContainer;
        userContainerOptions = options;
    }
    exports_102("useContainer", useContainer);
    /**
     * Gets the IOC container used by this library.
     */
    function getFromContainer(someClass) {
        if (userContainer) {
            try {
                var instance = userContainer.get(someClass);
                if (instance)
                    return instance;
                if (!userContainerOptions || !userContainerOptions.fallback)
                    return instance;
            }
            catch (error) {
                if (!userContainerOptions || !userContainerOptions.fallbackOnErrors)
                    throw error;
            }
        }
        return defaultContainer.get(someClass);
    }
    exports_102("getFromContainer", getFromContainer);
    var defaultContainer, userContainer, userContainerOptions;
    return {
        setters: [],
        execute: function () {
            /**
             * Container to be used by this library for inversion control. If container was not implicitly set then by default
             * container simply creates a new instance of the given class.
             */
            exports_102("defaultContainer", defaultContainer = new ((function () {
                function class_1() {
                    this.instances = [];
                }
                class_1.prototype.get = function (someClass) {
                    var instance = this.instances.find(function (instance) { return instance.type === someClass; });
                    if (!instance) {
                        instance = { type: someClass, object: new someClass() };
                        this.instances.push(instance);
                    }
                    return instance.object;
                };
                return class_1;
            }()))());
        }
    };
});
System.register("typeorm/repository/RepositoryAggregator", ["typeorm/repository/RepositoryFactory", "typeorm/container"], function (exports_103, context_103) {
    "use strict";
    var __moduleName = context_103 && context_103.id;
    var RepositoryFactory_1, container_1, RepositoryAggregator;
    return {
        setters: [
            function (RepositoryFactory_1_1) {
                RepositoryFactory_1 = RepositoryFactory_1_1;
            },
            function (container_1_1) {
                container_1 = container_1_1;
            }
        ],
        execute: function () {
            /**
             * Aggregates all repositories of the specific metadata.
             */
            RepositoryAggregator = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RepositoryAggregator(connection, metadata, queryRunnerProvider) {
                    this.metadata = metadata;
                    var factory = container_1.getFromContainer(RepositoryFactory_1.RepositoryFactory);
                    if (metadata.isClosure) {
                        this.repository = this.treeRepository = factory.createTreeRepository(connection.manager, metadata, queryRunnerProvider);
                    }
                    else {
                        this.repository = factory.createRepository(connection.manager, metadata, queryRunnerProvider);
                    }
                    this.specificRepository = factory.createSpecificRepository(connection, metadata, queryRunnerProvider);
                }
                return RepositoryAggregator;
            }());
            exports_103("RepositoryAggregator", RepositoryAggregator);
        }
    };
});
System.register("typeorm/entity-manager/error/NoNeedToReleaseEntityManagerError", [], function (exports_104, context_104) {
    "use strict";
    var __moduleName = context_104 && context_104.id;
    var NoNeedToReleaseEntityManagerError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to release entity manager that does not use single database connection.
             */
            NoNeedToReleaseEntityManagerError = (function (_super) {
                __extends(NoNeedToReleaseEntityManagerError, _super);
                function NoNeedToReleaseEntityManagerError() {
                    var _this = _super.call(this) || this;
                    _this.name = "NoNeedToReleaseEntityManagerError";
                    _this.message = "Entity manager is not using single database connection and cannot be released. " +
                        "Only entity managers created by connection#createEntityManagerWithSingleDatabaseConnection " +
                        "methods have a single database connection and they should be released.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoNeedToReleaseEntityManagerError;
            }(Error));
            exports_104("NoNeedToReleaseEntityManagerError", NoNeedToReleaseEntityManagerError);
        }
    };
});
System.register("typeorm/connection/error/RepositoryNotTreeError", [], function (exports_105, context_105) {
    "use strict";
    var __moduleName = context_105 && context_105.id;
    var RepositoryNotTreeError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotTreeError = (function (_super) {
                __extends(RepositoryNotTreeError, _super);
                function RepositoryNotTreeError(entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotTreeError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "Repository of the \"" + targetName + "\" class is not a TreeRepository. Try to use @ClosureTable decorator instead of @Table.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotTreeError;
            }(Error));
            exports_105("RepositoryNotTreeError", RepositoryNotTreeError);
        }
    };
});
System.register("typeorm/persistence/SubjectBuilder", ["typeorm/persistence/Subject", "typeorm/driver/mongodb/MongoDriver", "typeorm/util/OrmUtils"], function (exports_106, context_106) {
    "use strict";
    var __moduleName = context_106 && context_106.id;
    var Subject_2, MongoDriver_2, OrmUtils_4, SubjectBuilder;
    return {
        setters: [
            function (Subject_2_1) {
                Subject_2 = Subject_2_1;
            },
            function (MongoDriver_2_1) {
                MongoDriver_2 = MongoDriver_2_1;
            },
            function (OrmUtils_4_1) {
                OrmUtils_4 = OrmUtils_4_1;
            }
        ],
        execute: function () {
            /**
             * To be able to execute persistence operations we need to load all entities from the database we need.
             * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.
             * This is how we determine which entities needs to be loaded from db:
             *
             * 1. example with cascade updates and inserts:
             *
             * [Y] - means "yes, we load"
             * [N] - means "no, we don't load"
             * in {} braces we specify what cascade options are set between relations
             *
             * if Post is new, author is not set in the post
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // no because author is not set
             *     [Y] Photo -> {all} // no because author and its photo are not set
             *       [Y] Tag -> {all} // no because author and its photo and its tag are not set
             *
             * if Post is new, author is new (or anything else is new)
             * if Post is updated
             * if Post and/or Author are updated
             *
             * [Y] Post -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *   [Y] Author -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *     [Y] Photo -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *       [Y] Tag -> {all} // yes because of "update" and "insert" cascades, no because of "remove"
             *
             * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.
             * We load post, author, photo, tag only if they exist in the relation.
             * From these examples we can see that we always load entity relations when it has "update" or "insert" cascades.
             *
             * 2. example with cascade removes
             *
             * if entity is new its remove operations by cascades should not be executed
             * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed
             * if entity is removed then all its downside relations which has cascade remove should be removed
             *
             * Once we find removed entity - we load it, and every downside entity which has "remove" cascade set.
             *
             * At the end we have all entities we need to operate with.
             * Next step is to store all loaded entities to manipulate them efficiently.
             *
             * Rules of updating by cascades.
             * Insert operation can lead to:
             *  - insert operations
             *  - update operations
             * Update operation can lead to:
             *  - insert operations
             *  - update operations
             *  - remove operations
             * Remove operation can lead to:
             *  - remove operation
             */
            SubjectBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectBuilder(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    // -------------------------------------------------------------------------
                    // Protected properties
                    // -------------------------------------------------------------------------
                    /**
                     * If this gonna be reused then what to do with marked flags?
                     * One of solution can be clone this object and reset all marked states for this persistence.
                     * Or from reused just extract databaseEntities from their subjects? (looks better)
                     */
                    this.operateSubjects = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds operations for entity that is being inserted/updated.
                 */
                SubjectBuilder.prototype.persist = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainPersistedSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainPersistedSubject = new Subject_2.Subject(metadata, entity);
                                    mainPersistedSubject.canBeInserted = true;
                                    mainPersistedSubject.canBeUpdated = true;
                                    this.operateSubjects.push(mainPersistedSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to insert or update alongside with main persisted entity
                                    this.buildCascadeUpdateAndInsertOperateSubjects(mainPersistedSubject);
                                    // next step is to load database entities of all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities of all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: true, remove: true })];
                                case 3:
                                    // finally find which operate subjects have insert and remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds only remove operations for entity that is being removed.
                 */
                SubjectBuilder.prototype.remove = function (entity, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var mainRemovedSubject, operateSubjectsWithDatabaseEntities;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    mainRemovedSubject = new Subject_2.Subject(metadata, entity);
                                    mainRemovedSubject.mustBeRemoved = true;
                                    this.operateSubjects.push(mainRemovedSubject);
                                    // next step we build list of subjects we will operate with
                                    // these subjects are subjects that we need to remove alongside with main removed entity
                                    this.buildCascadeRemoveOperateSubjects(mainRemovedSubject);
                                    // next step is to load database entities for all operate subjects
                                    return [4 /*yield*/, this.loadOperateSubjectsDatabaseEntities()];
                                case 1:
                                    // next step is to load database entities for all operate subjects
                                    _a.sent();
                                    operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(function (subject) { return subject.hasDatabaseEntity; });
                                    return [4 /*yield*/, Promise.all(operateSubjectsWithDatabaseEntities.map(function (subject) {
                                            return _this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);
                                        }))];
                                case 2:
                                    _a.sent();
                                    // finally find which operate subjects have remove operations in their junction tables
                                    return [4 /*yield*/, this.buildJunctionOperations({ insert: false, remove: true })];
                                case 3:
                                    // finally find which operate subjects have remove operations in their junction tables
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds and pushes to array of operate entities all entities that we will work with.
                 * These are only relational entities which has insert and update cascades.
                 * All such entities will be loaded from the database, because they can be inserted or updated.
                 * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.
                 * We can't add removed entities here, because to know which entity was removed we need first to
                 * load original entity (particularly its id) from the database.
                 * That's why we first need to load all changed entities, then extract ids of the removed entities from them,
                 * and only then load removed entities by extracted ids.
                 */
                SubjectBuilder.prototype.buildCascadeUpdateAndInsertOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // we need only defined values and insert or update cascades of the relation should be set
                        return value !== undefined && value !== null && (relation.isCascadeInsert || relation.isCascadeUpdate);
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistValueSubject = _this.findByEntityLike(valueMetadata.target, value);
                        if (alreadyExistValueSubject) {
                            if (alreadyExistValueSubject.canBeInserted === false)
                                alreadyExistValueSubject.canBeInserted = relation.isCascadeInsert === true;
                            if (alreadyExistValueSubject.canBeUpdated === false)
                                alreadyExistValueSubject.canBeUpdated = relation.isCascadeUpdate === true;
                            return;
                        }
                        // mark subject with what we can do with it
                        // and add to the array of subjects to load only if there is no same entity there already
                        var valueSubject = new Subject_2.Subject(valueMetadata, value);
                        valueSubject.canBeInserted = relation.isCascadeInsert === true;
                        valueSubject.canBeUpdated = relation.isCascadeUpdate === true;
                        _this.operateSubjects.push(valueSubject);
                        // go recursively and find other entities we need to operate with
                        _this.buildCascadeUpdateAndInsertOperateSubjects(valueSubject);
                    });
                };
                /**
                 * Builds and pushes to array of operate entities all entities that must be removed.
                 */
                SubjectBuilder.prototype.buildCascadeRemoveOperateSubjects = function (subject) {
                    var _this = this;
                    subject.metadata
                        .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)
                        .filter(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // we need only defined values and insert cascades of the relation should be set
                        return value !== undefined && value !== null && relation.isCascadeRemove;
                    })
                        .forEach(function (_a) {
                        var relation = _a[0], value = _a[1], valueMetadata = _a[2];
                        // if we already has this entity in list of operated subjects then skip it to avoid recursion
                        var alreadyExistValueSubject = _this.findByEntityLike(valueMetadata.target, value);
                        if (alreadyExistValueSubject) {
                            alreadyExistValueSubject.mustBeRemoved = true;
                            return;
                        }
                        // add to the array of subjects to load only if there is no same entity there already
                        var valueSubject = new Subject_2.Subject(valueMetadata, value);
                        valueSubject.mustBeRemoved = true;
                        _this.operateSubjects.push(valueSubject);
                        // go recursively and find other entities to load by cascades in currently inserted entities
                        _this.buildCascadeRemoveOperateSubjects(valueSubject);
                    });
                };
                /**
                 * Loads database entities for all operate subjects which do not have database entity set.
                 * All entities that we load database entities for are marked as updated or inserted.
                 * To understand which of them really needs to be inserted or updated we need to load
                 * their original representations from the database.
                 */
                SubjectBuilder.prototype.loadOperateSubjectsDatabaseEntities = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.groupByEntityTargets().map(function (subjectGroup) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var allIds, entities;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    allIds = subjectGroup.subjects
                                                        .filter(function (subject) { return !subject.hasDatabaseEntity; }) // we don't load if subject already has a database entity loaded
                                                        .filter(function (subject) {
                                                        return !subject.metadata.isEntityMapEmpty(subject.entity);
                                                    }) // we only need entity id
                                                        .map(function (subject) {
                                                        // console.log(subject.entity);
                                                        return subject.metadata.getEntityIdMap(subject.entity);
                                                        // if (mixedId instanceof Object)
                                                        //     return Object.keys(mixedId).every(key => mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== "");
                                                        //
                                                        // return mixedId !== undefined && mixedId !== null && mixedId !== "";
                                                    });
                                                    // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there
                                                    // console.log("allIds: ", allIds);
                                                    // console.log("subject.entity: ", subjectGroup.subjects);
                                                    // console.log("allIds: ", allIds);
                                                    if (!allIds.length)
                                                        return [2 /*return*/];
                                                    if (!(this.connection.driver instanceof MongoDriver_2.MongoDriver)) return [3 /*break*/, 2];
                                                    return [4 /*yield*/, this.connection
                                                            .getMongoRepository(subjectGroup.target)
                                                            .findByIds(allIds)];
                                                case 1:
                                                    entities = _a.sent();
                                                    return [3 /*break*/, 4];
                                                case 2: return [4 /*yield*/, this.connection
                                                        .getRepository(subjectGroup.target)
                                                        .createQueryBuilder("operateSubject", this.queryRunnerProvider)
                                                        .andWhereInIds(allIds)
                                                        .enableAutoRelationIdsLoad()
                                                        .getMany()];
                                                case 3:
                                                    entities = _a.sent();
                                                    _a.label = 4;
                                                case 4:
                                                    // now when we have entities we need to find subject of each entity
                                                    // and insert that entity into database entity of the found subject
                                                    entities.forEach(function (entity) {
                                                        // console.log(1);
                                                        var subject = _this.findByEntityLike(subjectGroup.target, entity);
                                                        if (subject)
                                                            subject.databaseEntity = entity;
                                                    });
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * We need to load removed entity when:
                 *  - entity with relations is not new (this can be determined only after entity is loaded from db)
                 *      (note: simple "id" check will not work because id can be not generated)
                 *  - entity missing relation. When relation is simple
                 *      - in the case of one-to-one owner (with join column) relation we need to load owner entity
                 *      - in the case of one-to-one (without join column) relation we need to load inverse side entity
                 *      - in the case of many-to-one relations we need to load entity itself
                 *      - in the case of one-to-many relations we need to load entities by relation from inverse side
                 *
                 *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.
                 *
                 *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when
                 *  relation is replaced (e.g. changed with different object).
                 */
                SubjectBuilder.prototype.buildCascadeRemovedAndRelationUpdateOperateSubjects = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = subject.metadata.relations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                        var _this = this;
                                        var valueMetadata, qbAlias, relationIdInDatabaseEntity_1, persistValueRelationId, persistValue_1, alreadyLoadedRelatedDatabaseSubject, qb, condition, parameters, databaseEntity, persistValueRelationId, persistValue, relationIdInDatabaseEntity_2, alreadyLoadedRelatedDatabaseSubject, databaseEntity, inverseEntityRelationId, persistValue_2, databaseEntities_1, ea_1, ec_1, joinAlias_1, joinColumnConditions, inverseJoinColumnConditions, conditions, parameters, joinAlias_2, joinColumnConditions, inverseJoinColumnConditions, conditions, parameters, relationIdInDatabaseEntity, promises_1, promises_2;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    valueMetadata = relation.inverseEntityMetadata;
                                                    qbAlias = valueMetadata.tableName;
                                                    // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels
                                                    if (!subject.hasDatabaseEntity)
                                                        return [2 /*return*/];
                                                    if (!(relation.isOneToOneOwner || relation.isManyToOne)) return [3 /*break*/, 4];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    relationIdInDatabaseEntity_1 = relation.getEntityValue(subject.databaseEntity);
                                                    // if database relation id does not exist in the database object then nothing to remove
                                                    if (relationIdInDatabaseEntity_1 === null || relationIdInDatabaseEntity_1 === undefined)
                                                        return [2 /*return*/];
                                                    persistValueRelationId = undefined, persistValue_1 = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue_1 = relation.getEntityValue(subject.entity);
                                                        if (persistValue_1 === null)
                                                            persistValueRelationId = null;
                                                        if (persistValue_1)
                                                            persistValueRelationId = relation.joinColumns.reduce(function (map, column) { return column.referencedColumn.getEntityValueMap(persistValue_1); }, {});
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    // object is removed only if relation id in the persisted entity is empty or is changed
                                                    // if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity)
                                                    //     return;
                                                    // console.log("relationIdInDatabaseEntity:", relationIdInDatabaseEntity);
                                                    // console.log("persistValue:", persistValue);
                                                    // console.log("compareEntities:", relation.entityMetadata.compareEntities(relationIdInDatabaseEntity, persistValue));
                                                    // console.log("compareIds:", relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue));
                                                    if (persistValueRelationId !== null && relation.entityMetadata.compareIds(relationIdInDatabaseEntity_1, persistValue_1))
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Details
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Details loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Details
                                                        // (example) and we need to compare details.id === post.detailsId
                                                        return relation.entityMetadata.compareIds(relationIdInDatabaseEntity_1, relation.getEntityValue(relatedSubject.databaseEntity));
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 2];
                                                    qb = this.connection
                                                        .getRepository(valueMetadata.target)
                                                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                        .enableAutoRelationIdsLoad();
                                                    condition = relation.joinColumns.map(function (joinColumn) {
                                                        return qbAlias + "." + joinColumn.referencedColumn.propertyPath + " = :" + joinColumn.databaseName;
                                                    }).join(" AND ");
                                                    parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(relationIdInDatabaseEntity_1);
                                                        return parameters;
                                                    }, {});
                                                    qb.where(condition)
                                                        .setParameters(parameters);
                                                    return [4 /*yield*/, qb.getOne()];
                                                case 1:
                                                    databaseEntity = _a.sent();
                                                    if (databaseEntity) {
                                                        alreadyLoadedRelatedDatabaseSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    }
                                                    _a.label = 2;
                                                case 2:
                                                    if (!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 4];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 3:
                                                    _a.sent();
                                                    _a.label = 4;
                                                case 4:
                                                    if (!relation.isOneToOneNotOwner) return [3 /*break*/, 8];
                                                    // we only work with cascade removes here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/]; // todo: no
                                                    persistValueRelationId = undefined;
                                                    if (subject.hasEntity && !subject.mustBeRemoved) {
                                                        persistValue = relation.getEntityValue(subject.entity);
                                                        if (persistValue)
                                                            persistValueRelationId = relation.inverseRelation.getEntityValue(persistValue);
                                                        if (persistValueRelationId === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    relationIdInDatabaseEntity_2 = relation.inverseRelation.joinColumns[0].referencedColumn.getEntityValue(subject.databaseEntity);
                                                    // if database relation id does not exist then nothing to remove (but can this be possible?)
                                                    if (relationIdInDatabaseEntity_2 === null || relationIdInDatabaseEntity_2 === undefined)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(function (relatedSubject) {
                                                        // (example) filter only subject that has database entity loaded and its target is Post
                                                        if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)
                                                            return false;
                                                        // (example) here we seek a Post loaded from the database in the subjects
                                                        // (example) here relatedSubject.databaseEntity is a Post
                                                        // (example) and we need to compare post.detailsId === details.id
                                                        return relation.inverseRelation.getEntityValue(relatedSubject.databaseEntity) === relationIdInDatabaseEntity_2;
                                                    });
                                                    if (!!alreadyLoadedRelatedDatabaseSubject) return [3 /*break*/, 6];
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .where(qbAlias + "." + relation.inverseSidePropertyPath + "=:id") // TODO relation.inverseRelation.joinColumns
                                                            .setParameter("id", relationIdInDatabaseEntity_2) // (example) subject.entity is a details here, and the value is details.id
                                                            .enableAutoRelationIdsLoad()
                                                            .getOne()];
                                                case 5:
                                                    databaseEntity = _a.sent();
                                                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation
                                                    // we cannot check if it was removed or not until we query the database
                                                    // and it can be a situation that relation wasn't exist at all. This is particular that case
                                                    alreadyLoadedRelatedDatabaseSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);
                                                    _a.label = 6;
                                                case 6:
                                                    if (!(alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity)) return [3 /*break*/, 8];
                                                    inverseEntityRelationId = relation.inverseRelation.getEntityValue(alreadyLoadedRelatedDatabaseSubject.databaseEntity);
                                                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)
                                                        return [2 /*return*/];
                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                    // if we remove this it will cause a recursion
                                                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)
                                                        return [2 /*return*/];
                                                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;
                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject)];
                                                case 7:
                                                    _a.sent();
                                                    _a.label = 8;
                                                case 8:
                                                    if (!(relation.isOneToMany || relation.isManyToMany)) return [3 /*break*/, 18];
                                                    persistValue_2 = undefined;
                                                    if (subject.hasEntity) {
                                                        persistValue_2 = relation.getEntityValue(subject.entity);
                                                        if (persistValue_2 === undefined)
                                                            return [2 /*return*/]; // skip undefined properties
                                                    }
                                                    databaseEntities_1 = [];
                                                    ea_1 = function (alias) { return _this.connection.driver.escapeAliasName(alias); };
                                                    ec_1 = function (column) { return _this.connection.driver.escapeColumnName(column); };
                                                    if (!relation.isManyToManyOwner) return [3 /*break*/, 10];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    joinAlias_1 = ea_1("persistenceJoinedRelation");
                                                    joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                                                        return joinAlias_1 + "." + joinColumn.propertyName + " = :" + joinColumn.propertyName;
                                                    });
                                                    inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                                                        return joinAlias_1 + "." + inverseJoinColumn.propertyName + " = " + ea_1(qbAlias) + "." + ec_1(inverseJoinColumn.referencedColumn.propertyName);
                                                    });
                                                    conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND ");
                                                    parameters = relation.joinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(subject.databaseEntity);
                                                        return parameters;
                                                    }, {});
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .innerJoin(relation.junctionEntityMetadata.tableName, joinAlias_1, conditions)
                                                            .setParameters(parameters)
                                                            .enableAutoRelationIdsLoad()
                                                            .getMany()];
                                                case 9:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 10:
                                                    if (!relation.isManyToManyNotOwner) return [3 /*break*/, 12];
                                                    // we only need to load inverse entities if cascade removes are set
                                                    // because remove by cascades is the only reason we need relational entities here
                                                    if (!relation.isCascadeRemove)
                                                        return [2 /*return*/];
                                                    joinAlias_2 = ea_1("persistenceJoinedRelation");
                                                    joinColumnConditions = relation.joinColumns.map(function (joinColumn) {
                                                        return joinAlias_2 + "." + joinColumn.propertyName + " = " + ea_1(qbAlias) + "." + ec_1(joinColumn.referencedColumn.propertyName);
                                                    });
                                                    inverseJoinColumnConditions = relation.inverseJoinColumns.map(function (inverseJoinColumn) {
                                                        return joinAlias_2 + "." + inverseJoinColumn.propertyName + " = :" + inverseJoinColumn.propertyName;
                                                    });
                                                    conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(" AND ");
                                                    parameters = relation.inverseRelation.inverseJoinColumns.reduce(function (parameters, joinColumn) {
                                                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn.getEntityValue(subject.databaseEntity);
                                                        return parameters;
                                                    }, {});
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .innerJoin(relation.junctionEntityMetadata.tableName, joinAlias_2, conditions)
                                                            .setParameters(parameters)
                                                            .enableAutoRelationIdsLoad()
                                                            .getMany()];
                                                case 11:
                                                    databaseEntities_1 = _a.sent();
                                                    return [3 /*break*/, 14];
                                                case 12:
                                                    relationIdInDatabaseEntity = relation.inverseRelation.joinColumns[0].referencedColumn.getEntityValue(subject.databaseEntity);
                                                    return [4 /*yield*/, this.connection
                                                            .getRepository(valueMetadata.target)
                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                            .where(qbAlias + "." + relation.inverseSidePropertyPath + "=:id")
                                                            .setParameter("id", relationIdInDatabaseEntity)
                                                            .enableAutoRelationIdsLoad()
                                                            .getMany()];
                                                case 13:
                                                    // in this case we need inverse entities not only because of cascade removes
                                                    // because we also need inverse entities to be able to perform update of entities
                                                    // in the inverse side when entities is detached from one-to-many relation
                                                    databaseEntities_1 = _a.sent();
                                                    _a.label = 14;
                                                case 14:
                                                    // add to loadMap loaded entities if some of them are missing
                                                    databaseEntities_1.forEach(function (databaseEntity) {
                                                        var subjectInLoadMap = _this.findByEntityLike(valueMetadata.target, databaseEntity);
                                                        if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {
                                                            subjectInLoadMap.databaseEntity = databaseEntity;
                                                        }
                                                        else if (!subjectInLoadMap) {
                                                            var subject_1 = new Subject_2.Subject(valueMetadata, undefined, databaseEntity);
                                                            _this.operateSubjects.push(subject_1);
                                                        }
                                                    });
                                                    if (!(relation.isOneToMany && persistValue_2)) return [3 /*break*/, 16];
                                                    promises_1 = persistValue_2.map(function (persistValue) { return __awaiter(_this, void 0, void 0, function () {
                                                        var persistedValueInDatabaseEntity, loadedSubject, id, databaseEntity;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    persistedValueInDatabaseEntity = databaseEntities_1.find(function (databaseEntity) {
                                                                        return valueMetadata.compareEntities(persistValue, databaseEntity);
                                                                    });
                                                                    if (!!persistedValueInDatabaseEntity) return [3 /*break*/, 3];
                                                                    loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);
                                                                    if (!!loadedSubject) return [3 /*break*/, 2];
                                                                    id = valueMetadata.getEntityIdMap(persistValue);
                                                                    if (!id) return [3 /*break*/, 2];
                                                                    return [4 /*yield*/, this.connection
                                                                            .getRepository(valueMetadata.target)
                                                                            .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?
                                                                            .andWhereInIds([id])
                                                                            .enableAutoRelationIdsLoad()
                                                                            .getOne()];
                                                                case 1:
                                                                    databaseEntity = _a.sent();
                                                                    if (databaseEntity) {
                                                                        loadedSubject = new Subject_2.Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?
                                                                        this.operateSubjects.push(loadedSubject);
                                                                    }
                                                                    _a.label = 2;
                                                                case 2:
                                                                    if (loadedSubject) {
                                                                        loadedSubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: subject.entity
                                                                        });
                                                                    }
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_1)];
                                                case 15:
                                                    _a.sent();
                                                    _a.label = 16;
                                                case 16:
                                                    promises_2 = databaseEntities_1.map(function (databaseEntity) { return __awaiter(_this, void 0, void 0, function () {
                                                        var relatedEntitySubject, relatedValue;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);
                                                                    if (!relatedEntitySubject)
                                                                        return [2 /*return*/]; // should not be possible, anyway add it for type-safety
                                                                    // if object is already marked as removed then no need to proceed because it already was proceed
                                                                    // if we remove this check it will cause a recursion
                                                                    if (relatedEntitySubject.mustBeRemoved)
                                                                        return [2 /*return*/]; // todo: add another check for entity in unsetRelations?
                                                                    relatedValue = (persistValue_2 || []).find(function (persistValueItem) {
                                                                        return valueMetadata.compareEntities(relatedEntitySubject.databaseEntity, persistValueItem);
                                                                    });
                                                                    if (!(persistValue_2 === null || !relatedValue)) return [3 /*break*/, 3];
                                                                    if (!relation.isCascadeRemove) return [3 /*break*/, 2];
                                                                    relatedEntitySubject.mustBeRemoved = true;
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    return [4 /*yield*/, this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject)];
                                                                case 1:
                                                                    // mark as removed all underlying entities that has cascade remove
                                                                    _a.sent();
                                                                    return [3 /*break*/, 3];
                                                                case 2:
                                                                    if (relation.isOneToMany && relation.inverseRelation) {
                                                                        relatedEntitySubject.relationUpdates.push({
                                                                            relation: relation.inverseRelation,
                                                                            value: null
                                                                        }); // todo: implement same for one-to-one
                                                                    }
                                                                    _a.label = 3;
                                                                case 3: return [2 /*return*/];
                                                            }
                                                        });
                                                    }); });
                                                    return [4 /*yield*/, Promise.all(promises_2)];
                                                case 17:
                                                    _a.sent();
                                                    _a.label = 18;
                                                case 18: return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Builds all junction insert and remove operations used to insert new bind data into junction tables,
                 * or remove old junction records.
                 * Options specifies which junction operations should be built - insert, remove or both.
                 */
                SubjectBuilder.prototype.buildJunctionOperations = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = this.operateSubjects.filter(function (subject) { return subject.hasEntity; }).map(function (subject) {
                                        var metadata = subject.metadata.parentEntityMetadata ? subject.metadata.parentEntityMetadata : subject.metadata;
                                        var promises = metadata.manyToManyRelations.map(function (relation) { return __awaiter(_this, void 0, void 0, function () {
                                            var existInverseEntityRelationIds_1, relatedValue, existInverseEntityRelationIds, changedInverseEntityRelationIds, removedJunctionEntityIds, newJunctionEntities;
                                            return __generator(this, function (_a) {
                                                // if subject marked to be removed then all its junctions must be removed
                                                if (subject.mustBeRemoved && options.remove) {
                                                    existInverseEntityRelationIds_1 = relation.getEntityValue(subject.databaseEntity);
                                                    // finally create a new junction remove operation and push it to the array of such operations
                                                    if (existInverseEntityRelationIds_1.length > 0) {
                                                        subject.junctionRemoves.push({
                                                            relation: relation,
                                                            junctionRelationIds: existInverseEntityRelationIds_1
                                                        });
                                                    }
                                                    return [2 /*return*/];
                                                }
                                                // if entity don't have entity then no need to find something that should be inserted or removed
                                                if (!subject.hasEntity)
                                                    return [2 /*return*/];
                                                relatedValue = relation.getEntityValue(subject.entity);
                                                if (!(relatedValue instanceof Array))
                                                    return [2 /*return*/];
                                                existInverseEntityRelationIds = [];
                                                // if subject don't have database entity it means its new and we don't need to remove something that is not exist
                                                if (subject.hasDatabaseEntity) {
                                                    existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);
                                                    // console.log("existInverseEntityRelationIds:", existInverseEntityRelationIds[0]);
                                                }
                                                changedInverseEntityRelationIds = relatedValue
                                                    .map(function (subRelationValue) {
                                                    var joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                                    return joinColumns.reduce(function (ids, joinColumn) {
                                                        return OrmUtils_4.OrmUtils.mergeDeep(ids, joinColumn.referencedColumn.createValueMap(joinColumn.referencedColumn.getEntityValue(subRelationValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?
                                                    }, {});
                                                })
                                                    .filter(function (subRelationValue) { return subRelationValue !== undefined && subRelationValue !== null; });
                                                removedJunctionEntityIds = existInverseEntityRelationIds.filter(function (existRelationId) {
                                                    return !changedInverseEntityRelationIds.find(function (changedRelationId) {
                                                        return relation.inverseEntityMetadata.compareIds(changedRelationId, existRelationId);
                                                    });
                                                });
                                                newJunctionEntities = relatedValue.filter(function (subRelatedValue) {
                                                    // console.log(subRelatedValue);
                                                    var joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                                    var ids = joinColumns.reduce(function (ids, joinColumn) {
                                                        return OrmUtils_4.OrmUtils.mergeDeep(ids, joinColumn.referencedColumn.createValueMap(joinColumn.referencedColumn.getEntityValue(subRelatedValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?
                                                    }, {});
                                                    // console.log("ids:", ids);
                                                    return !existInverseEntityRelationIds.find(function (relationId) {
                                                        return relation.inverseEntityMetadata.compareIds(relationId, ids);
                                                    });
                                                });
                                                // console.log("newJunctionEntities: ", newJunctionEntities);
                                                // finally create a new junction insert operation and push it to the array of such operations
                                                if (newJunctionEntities.length > 0 && options.insert) {
                                                    subject.junctionInserts.push({
                                                        relation: relation,
                                                        junctionEntities: newJunctionEntities
                                                    });
                                                }
                                                // finally create a new junction remove operation and push it to the array of such operations
                                                if (removedJunctionEntityIds.length > 0 && options.remove) {
                                                    subject.junctionRemoves.push({
                                                        relation: relation,
                                                        junctionRelationIds: removedJunctionEntityIds
                                                    });
                                                }
                                                return [2 /*return*/];
                                            });
                                        }); });
                                        return Promise.all(promises);
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Finds subject where entity like given subject's entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasEntity)
                            return false;
                        if (subject.entity === entity)
                            return true;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);
                    });
                };
                /**
                 * Finds subject where entity like given subject's database entity.
                 * Comparision made by entity id.
                 */
                SubjectBuilder.prototype.findByDatabaseEntityLike = function (entityTarget, entity) {
                    return this.operateSubjects.find(function (subject) {
                        if (!subject.hasDatabaseEntity)
                            return false;
                        return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);
                    });
                };
                /**
                 * Groups given Subject objects into groups separated by entity targets.
                 */
                SubjectBuilder.prototype.groupByEntityTargets = function () {
                    return this.operateSubjects.reduce(function (groups, operatedEntity) {
                        var group = groups.find(function (group) { return group.target === operatedEntity.entityTarget; });
                        if (!group) {
                            group = { target: operatedEntity.entityTarget, subjects: [] };
                            groups.push(group);
                        }
                        group.subjects.push(operatedEntity);
                        return groups;
                    }, []);
                };
                return SubjectBuilder;
            }());
            exports_106("SubjectBuilder", SubjectBuilder);
        }
    };
});
System.register("typeorm/util/PromiseUtils", [], function (exports_107, context_107) {
    "use strict";
    var __moduleName = context_107 && context_107.id;
    var PromiseUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Utils to help to work with Promise objects.
             */
            PromiseUtils = (function () {
                function PromiseUtils() {
                }
                /**
                 * Runs given callback that returns promise for each item in the given collection in order.
                 * Operations executed after each other, right after previous promise being resolved.
                 */
                PromiseUtils.runInSequence = function (collection, callback) {
                    var results = [];
                    return collection.reduce(function (promise, item) {
                        return promise.then(function () {
                            return callback(item);
                        }).then(function (result) {
                            results.push(result);
                        });
                    }, Promise.resolve()).then(function () {
                        return results;
                    });
                };
                return PromiseUtils;
            }());
            exports_107("PromiseUtils", PromiseUtils);
        }
    };
});
System.register("typeorm/persistence/SubjectOperationExecutor", ["typeorm/util/OrmUtils", "typeorm/util/PromiseUtils", "typeorm/driver/mongodb/MongoDriver"], function (exports_108, context_108) {
    "use strict";
    var __moduleName = context_108 && context_108.id;
    var OrmUtils_5, PromiseUtils_1, MongoDriver_3, SubjectOperationExecutor;
    return {
        setters: [
            function (OrmUtils_5_1) {
                OrmUtils_5 = OrmUtils_5_1;
            },
            function (PromiseUtils_1_1) {
                PromiseUtils_1 = PromiseUtils_1_1;
            },
            function (MongoDriver_3_1) {
                MongoDriver_3 = MongoDriver_3_1;
            }
        ],
        execute: function () {
            /**
             * Executes all database operations (inserts, updated, deletes) that must be executed
             * with given persistence subjects.
             */
            SubjectOperationExecutor = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SubjectOperationExecutor(connection, transactionEntityManager, queryRunnerProvider) {
                    this.connection = connection;
                    this.transactionEntityManager = transactionEntityManager;
                    this.queryRunnerProvider = queryRunnerProvider;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes all operations over given array of subjects.
                 * Executes queries using given query runner.
                 */
                SubjectOperationExecutor.prototype.execute = function (subjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var isTransactionStartedByItself, _a, error_5, secondaryError_1;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    /*subjects.forEach(subject => {
                                        console.log(subject.entity);
                                        console.log("mustBeInserted: ", subject.mustBeInserted);
                                        console.log("mustBeUpdated: ", subject.mustBeUpdated);
                                        console.log("mustBeRemoved: ", subject.mustBeRemoved);
                                    });*/
                                    // validate all subjects first
                                    subjects.forEach(function (subject) { return subject.validate(); });
                                    // set class properties for easy use
                                    this.allSubjects = subjects;
                                    this.insertSubjects = subjects.filter(function (subject) { return subject.mustBeInserted; });
                                    this.updateSubjects = subjects.filter(function (subject) { return subject.mustBeUpdated; });
                                    this.removeSubjects = subjects.filter(function (subject) { return subject.mustBeRemoved; });
                                    this.relationUpdateSubjects = subjects.filter(function (subject) { return subject.hasRelationUpdates; });
                                    // if there are no operations to execute then don't need to do something including opening a transaction
                                    if (!this.insertSubjects.length &&
                                        !this.updateSubjects.length &&
                                        !this.removeSubjects.length &&
                                        !this.relationUpdateSubjects.length &&
                                        subjects.every(function (subject) { return !subject.junctionInserts.length; }) &&
                                        subjects.every(function (subject) { return !subject.junctionRemoves.length; }))
                                        return [2 /*return*/];
                                    isTransactionStartedByItself = false;
                                    _b.label = 1;
                                case 1:
                                    _b.trys.push([1, 17, , 22]);
                                    _a = this;
                                    return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 2:
                                    _a.queryRunner = _b.sent();
                                    if (!!this.queryRunner.isTransactionActive()) return [3 /*break*/, 4];
                                    isTransactionStartedByItself = true;
                                    return [4 /*yield*/, this.queryRunner.beginTransaction()];
                                case 3:
                                    _b.sent();
                                    _b.label = 4;
                                case 4: 
                                // broadcast "before" events before we start updating
                                return [4 /*yield*/, this.connection.broadcaster.broadcastBeforeEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 5:
                                    // broadcast "before" events before we start updating
                                    _b.sent();
                                    // since events can trigger some internal changes (for example update depend property) we need to perform some re-computations here
                                    this.updateSubjects.forEach(function (subject) { return subject.recompute(); });
                                    return [4 /*yield*/, this.executeInsertOperations()];
                                case 6:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeInsertClosureTableOperations()];
                                case 7:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeInsertJunctionsOperations()];
                                case 8:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeRemoveJunctionsOperations()];
                                case 9:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeUpdateOperations()];
                                case 10:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeUpdateRelations()];
                                case 11:
                                    _b.sent();
                                    return [4 /*yield*/, this.executeRemoveOperations()];
                                case 12:
                                    _b.sent();
                                    if (!(isTransactionStartedByItself === true)) return [3 /*break*/, 14];
                                    return [4 /*yield*/, this.queryRunner.commitTransaction()];
                                case 13:
                                    _b.sent();
                                    _b.label = 14;
                                case 14: 
                                // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                return [4 /*yield*/, this.updateSpecialColumnsInPersistedEntities()];
                                case 15:
                                    // update all special columns in persisted entities, like inserted id or remove ids from the removed entities
                                    _b.sent();
                                    // finally broadcast "after" events
                                    // note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    return [4 /*yield*/, this.connection.broadcaster.broadcastAfterEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects)];
                                case 16:
                                    // finally broadcast "after" events
                                    // note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers
                                    _b.sent();
                                    return [3 /*break*/, 22];
                                case 17:
                                    error_5 = _b.sent();
                                    if (!isTransactionStartedByItself) return [3 /*break*/, 21];
                                    _b.label = 18;
                                case 18:
                                    _b.trys.push([18, 20, , 21]);
                                    return [4 /*yield*/, this.queryRunner.rollbackTransaction()];
                                case 19:
                                    _b.sent();
                                    return [3 /*break*/, 21];
                                case 20:
                                    secondaryError_1 = _b.sent();
                                    return [3 /*break*/, 21];
                                case 21: throw error_5;
                                case 22: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion
                // -------------------------------------------------------------------------
                /**
                 * Executes insert operations.
                 *
                 * For insertion we separate two groups of entities:
                 * - first group of entities are entities which do not have any relations
                 *      or entities which do not have any non-nullable relation
                 * - second group of entities are entities which does have non-nullable relations
                 *
                 * Insert process of the entities from the first group which can only have nullable relations are actually a two-step process:
                 * - first we insert entities without their relations, explicitly left them NULL
                 * - later we update inserted entity once again with id of the object inserted with it
                 *
                 * Yes, two queries are being executed, but this is by design.
                 * There is no better way to solve this problem and others at the same time.
                 *
                 * Insert process of the entities from the second group which can have only non nullable relations is a single-step process:
                 * - we simply insert all entities and get into attention all its dependencies which were inserted in the first group
                 */
                SubjectOperationExecutor.prototype.executeInsertOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var firstInsertSubjects, secondInsertSubjects, updatePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    firstInsertSubjects = this.insertSubjects.filter(function (subject) { return !subject.metadata.hasNonNullableRelations; });
                                    secondInsertSubjects = this.insertSubjects.filter(function (subject) { return subject.metadata.hasNonNullableRelations; });
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    return [4 /*yield*/, Promise.all(firstInsertSubjects.map(function (subject) { return _this.insert(subject, []); }))];
                                case 1:
                                    // note: these operations should be executed in sequence, not in parallel
                                    // because second group depend of obtained data from the first group
                                    _a.sent();
                                    return [4 /*yield*/, Promise.all(secondInsertSubjects.map(function (subject) { return _this.insert(subject, firstInsertSubjects); }))];
                                case 2:
                                    _a.sent();
                                    updatePromises = [];
                                    firstInsertSubjects.forEach(function (subject) {
                                        // first update relations with join columns (one-to-one owner and many-to-one relations)
                                        var updateOptions = {};
                                        subject.metadata.relationsWithJoinColumns.forEach(function (relation) {
                                            relation.joinColumns.forEach(function (joinColumn) {
                                                var referencedColumn = joinColumn.referencedColumn;
                                                var relatedEntity = relation.getEntityValue(subject.entity);
                                                // if relation value is not set then nothing to do here
                                                if (!relatedEntity)
                                                    return;
                                                // check if relation reference column is a relation
                                                var relationId;
                                                var columnRelation = relation.inverseEntityMetadata.findRelationWithPropertyPath(joinColumn.referencedColumn.propertyPath);
                                                if (columnRelation) {
                                                    var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === referencedColumn.getEntityValue(relatedEntity); });
                                                    // if this relation was just inserted
                                                    if (insertSubject) {
                                                        // check if we have this relation id already
                                                        relationId = columnRelation.getEntityValue(referencedColumn.getEntityValue(relatedEntity));
                                                        if (!relationId) {
                                                            // if we don't have relation id then use special values
                                                            if (referencedColumn.isGenerated) {
                                                                relationId = insertSubject.newlyGeneratedId;
                                                            }
                                                            else if (referencedColumn.isObjectId) {
                                                                relationId = insertSubject.generatedObjectId;
                                                            }
                                                            // todo: handle other special types too
                                                        }
                                                    }
                                                }
                                                else {
                                                    var insertSubject = _this.insertSubjects.find(function (insertedSubject) { return insertedSubject.entity === relatedEntity; });
                                                    // if this relation was just inserted
                                                    if (insertSubject) {
                                                        // check if we have this relation id already
                                                        relationId = referencedColumn.getEntityValue(relatedEntity);
                                                        if (!relationId) {
                                                            // if we don't have relation id then use special values
                                                            if (referencedColumn.isGenerated) {
                                                                relationId = insertSubject.newlyGeneratedId;
                                                            }
                                                            else if (referencedColumn.isObjectId) {
                                                                relationId = insertSubject.generatedObjectId;
                                                            }
                                                            // todo: handle other special types too
                                                        }
                                                    }
                                                }
                                                if (relationId) {
                                                    updateOptions[joinColumn.databaseName] = relationId;
                                                }
                                            });
                                        });
                                        // if we found relations which we can update - then update them
                                        if (Object.keys(updateOptions).length > 0 /*&& subject.hasEntity*/) {
                                            // const relatedEntityIdMap = subject.getPersistedEntityIdMap; // todo: this works incorrectly
                                            var columns = subject.metadata.parentEntityMetadata ? subject.metadata.primaryColumns : subject.metadata.primaryColumns;
                                            var conditions_1 = {};
                                            columns.forEach(function (column) {
                                                var entityValue = column.getEntityValue(subject.entity);
                                                // if entity id is a relation, then extract referenced column from that relation
                                                var columnRelation = subject.metadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                if (entityValue && columnRelation) {
                                                    columnRelation.joinColumns.forEach(function (joinColumn) {
                                                        var relationIdOfEntityValue = entityValue[joinColumn.referencedColumn.propertyName];
                                                        if (!relationIdOfEntityValue) {
                                                            var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                            if (entityValueInsertSubject) {
                                                                if (joinColumn.referencedColumn.isGenerated) {
                                                                    relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;
                                                                }
                                                                else if (joinColumn.referencedColumn.isObjectId) {
                                                                    relationIdOfEntityValue = entityValueInsertSubject.generatedObjectId;
                                                                }
                                                            }
                                                        }
                                                        if (relationIdOfEntityValue) {
                                                            conditions_1[column.databaseName] = relationIdOfEntityValue;
                                                        }
                                                    });
                                                }
                                                else {
                                                    if (entityValue) {
                                                        conditions_1[column.databaseName] = entityValue;
                                                    }
                                                    else {
                                                        if (subject.newlyGeneratedId) {
                                                            conditions_1[column.databaseName] = subject.newlyGeneratedId;
                                                        }
                                                        else if (subject.generatedObjectId) {
                                                            conditions_1[column.databaseName] = subject.generatedObjectId;
                                                        }
                                                    }
                                                }
                                            });
                                            if (!Object.keys(conditions_1).length)
                                                return;
                                            var updatePromise = _this.queryRunner.update(subject.metadata.tableName, updateOptions, conditions_1);
                                            updatePromises.push(updatePromise);
                                        }
                                        // we need to update relation ids if newly inserted objects are used from inverse side in one-to-many inverse relation
                                        // we also need to update relation ids if newly inserted objects are used from inverse side in one-to-one inverse relation
                                        var oneToManyAndOneToOneNonOwnerRelations = subject.metadata.oneToManyRelations.concat(subject.metadata.oneToOneRelations.filter(function (relation) { return !relation.isOwning; }));
                                        // console.log(oneToManyAndOneToOneNonOwnerRelations);
                                        subject.metadata.extractRelationValuesFromEntity(subject.entity, oneToManyAndOneToOneNonOwnerRelations)
                                            .forEach(function (_a) {
                                            var relation = _a[0], subRelatedEntity = _a[1], inverseEntityMetadata = _a[2];
                                            relation.inverseRelation.joinColumns.forEach(function (joinColumn) {
                                                var referencedColumn = joinColumn.referencedColumn;
                                                var columns = inverseEntityMetadata.parentEntityMetadata ? inverseEntityMetadata.primaryColumns : inverseEntityMetadata.primaryColumns;
                                                var conditions = {};
                                                columns.forEach(function (column) {
                                                    var entityValue = column.getEntityValue(subRelatedEntity);
                                                    // if entity id is a relation, then extract referenced column from that relation
                                                    var columnRelation = inverseEntityMetadata.relations.find(function (relation) { return relation.propertyName === column.propertyName; });
                                                    if (entityValue && columnRelation) {
                                                        columnRelation.joinColumns.forEach(function (columnRelationJoinColumn) {
                                                            var relationIdOfEntityValue = entityValue[columnRelationJoinColumn.referencedColumn.propertyName];
                                                            if (!relationIdOfEntityValue) {
                                                                var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entityValue; });
                                                                if (entityValueInsertSubject) {
                                                                    if (columnRelationJoinColumn.referencedColumn.isGenerated) {
                                                                        relationIdOfEntityValue = entityValueInsertSubject.newlyGeneratedId;
                                                                    }
                                                                    else if (columnRelationJoinColumn.referencedColumn.isObjectId) {
                                                                        relationIdOfEntityValue = entityValueInsertSubject.generatedObjectId;
                                                                    }
                                                                }
                                                            }
                                                            if (relationIdOfEntityValue) {
                                                                conditions[column.databaseName] = relationIdOfEntityValue;
                                                            }
                                                        });
                                                    }
                                                    else {
                                                        var entityValueInsertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === subRelatedEntity; });
                                                        if (entityValue) {
                                                            conditions[column.databaseName] = entityValue;
                                                        }
                                                        else {
                                                            if (entityValueInsertSubject && entityValueInsertSubject.newlyGeneratedId) {
                                                                conditions[column.databaseName] = entityValueInsertSubject.newlyGeneratedId;
                                                            }
                                                            else if (entityValueInsertSubject && entityValueInsertSubject.generatedObjectId) {
                                                                conditions[column.databaseName] = entityValueInsertSubject.generatedObjectId;
                                                            }
                                                        }
                                                    }
                                                });
                                                if (!Object.keys(conditions).length)
                                                    return;
                                                var updateOptions = {};
                                                var columnRelation = relation.inverseEntityMetadata.relations.find(function (rel) { return rel.propertyName === referencedColumn.propertyName; });
                                                var columnValue = referencedColumn.getEntityValue(subject.entity);
                                                if (columnRelation) {
                                                    var id = columnRelation.getEntityValue(columnValue);
                                                    if (!id) {
                                                        var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === columnValue; });
                                                        if (insertSubject) {
                                                            if (insertSubject.newlyGeneratedId) {
                                                                id = insertSubject.newlyGeneratedId;
                                                            }
                                                            else if (insertSubject.generatedObjectId) {
                                                                id = insertSubject.generatedObjectId;
                                                            }
                                                        }
                                                    }
                                                    updateOptions[joinColumn.databaseName] = id;
                                                }
                                                else {
                                                    updateOptions[joinColumn.databaseName] = columnValue || subject.newlyGeneratedId || subRelatedEntity.generatedObjectId;
                                                }
                                                var updatePromise = _this.queryRunner.update(relation.inverseEntityMetadata.tableName, updateOptions, conditions);
                                                updatePromises.push(updatePromise);
                                            });
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(updatePromises)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts an entity from the given insert operation into the database.
                 * If entity has an generated column, then after saving new generated value will be stored to the InsertOperation.
                 * If entity uses class-table-inheritance, then multiple inserts may by performed to save all entities.
                 */
                SubjectOperationExecutor.prototype.insert = function (subject, alreadyInsertedSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentEntityMetadata, metadata, entity, newlyGeneratedId, parentGeneratedId, parentValuesMap, childValuesMap, secondGeneratedId, valuesMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    parentEntityMetadata = subject.metadata.parentEntityMetadata;
                                    metadata = subject.metadata;
                                    entity = subject.entity;
                                    if (!metadata.isClassTableChild) return [3 /*break*/, 3];
                                    parentValuesMap = this.collectColumnsAndValues(parentEntityMetadata, entity, subject.date, undefined, metadata.discriminatorValue, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(parentEntityMetadata.tableName, parentValuesMap, parentEntityMetadata.generatedColumn)];
                                case 1:
                                    newlyGeneratedId = parentGeneratedId = _a.sent();
                                    childValuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, newlyGeneratedId, undefined, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.tableName, childValuesMap, metadata.generatedColumn)];
                                case 2:
                                    secondGeneratedId = _a.sent();
                                    if (!newlyGeneratedId && secondGeneratedId)
                                        newlyGeneratedId = secondGeneratedId;
                                    return [3 /*break*/, 5];
                                case 3:
                                    valuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, undefined, undefined, alreadyInsertedSubjects);
                                    return [4 /*yield*/, this.queryRunner.insert(metadata.tableName, valuesMap, metadata.generatedColumn)];
                                case 4:
                                    newlyGeneratedId = _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (parentGeneratedId)
                                        subject.parentGeneratedId = parentGeneratedId;
                                    // todo: better if insert method will return object with all generated ids, object id, etc.
                                    if (newlyGeneratedId) {
                                        if (metadata.generatedColumn) {
                                            subject.newlyGeneratedId = newlyGeneratedId;
                                        }
                                        else if (metadata.objectIdColumn) {
                                            subject.generatedObjectId = newlyGeneratedId;
                                        }
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                SubjectOperationExecutor.prototype.collectColumns = function (columns, entity, object) {
                    var _this = this;
                    columns.forEach(function (column) {
                        if (column.isVirtual || column.isParentId || column.isDiscriminator)
                            return;
                        var value = entity[column.propertyName];
                        if (value === undefined)
                            return;
                        object[column.databaseNameWithoutPrefixes] = _this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class
                    });
                };
                SubjectOperationExecutor.prototype.collectEmbeds = function (embed, entity, object) {
                    var _this = this;
                    if (embed.isArray) {
                        if (entity[embed.propertyName] instanceof Array) {
                            if (!object[embed.prefix])
                                object[embed.prefix] = [];
                            entity[embed.propertyName].forEach(function (subEntity, index) {
                                if (!object[embed.prefix][index])
                                    object[embed.prefix][index] = {};
                                _this.collectColumns(embed.columns, subEntity, object[embed.prefix][index]);
                                embed.embeddeds.forEach(function (childEmbed) { return _this.collectEmbeds(childEmbed, subEntity, object[embed.prefix][index]); });
                            });
                        }
                    }
                    else {
                        if (entity[embed.propertyName] !== undefined) {
                            if (!object[embed.prefix])
                                object[embed.prefix] = {};
                            this.collectColumns(embed.columns, entity[embed.propertyName], object[embed.prefix]);
                            embed.embeddeds.forEach(function (childEmbed) { return _this.collectEmbeds(childEmbed, entity[embed.propertyName], object[embed.prefix]); });
                        }
                    }
                };
                /**
                 * Collects columns and values for the insert operation.
                 */
                SubjectOperationExecutor.prototype.collectColumnsAndValues = function (metadata, entity, date, parentIdColumnValue, discriminatorValue, alreadyInsertedSubjects) {
                    var _this = this;
                    var values = {};
                    if (this.connection.driver instanceof MongoDriver_3.MongoDriver) {
                        this.collectColumns(metadata.ownColumns, entity, values);
                        metadata.embeddeds.forEach(function (embed) { return _this.collectEmbeds(embed, entity, values); });
                    }
                    else {
                        metadata.columns.forEach(function (column) {
                            if (column.isVirtual || column.isParentId || column.isDiscriminator)
                                return;
                            var value = column.getEntityValue(entity);
                            if (value === null || value === undefined)
                                return;
                            values[column.databaseName] = _this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class
                        });
                    }
                    metadata.relationsWithJoinColumns.forEach(function (relation) {
                        relation.joinColumns.forEach(function (joinColumn) {
                            var relationValue;
                            var value = relation.getEntityValue(entity);
                            if (value) {
                                // if relation value is stored in the entity itself then use it from there
                                var relationId = joinColumn.referencedColumn.getEntityValue(value); // relation.getInverseEntityRelationId(value); // todo: check it
                                if (relationId) {
                                    relationValue = relationId;
                                }
                                // otherwise try to find relational value from just inserted subjects
                                var alreadyInsertedSubject = alreadyInsertedSubjects.find(function (insertedSubject) {
                                    return insertedSubject.entity === value;
                                });
                                if (alreadyInsertedSubject) {
                                    var referencedColumn = joinColumn.referencedColumn;
                                    // if join column references to the primary generated column then seek in the newEntityId of the insertedSubject
                                    if (referencedColumn.referencedColumn && referencedColumn.referencedColumn.isGenerated) {
                                        if (referencedColumn.isParentId) {
                                            relationValue = alreadyInsertedSubject.parentGeneratedId;
                                        }
                                        // todo: what if reference column is not generated?
                                        // todo: what if reference column is not related to table inheritance?
                                    }
                                    if (referencedColumn.isGenerated)
                                        relationValue = alreadyInsertedSubject.newlyGeneratedId;
                                    if (referencedColumn.isObjectId)
                                        relationValue = alreadyInsertedSubject.generatedObjectId;
                                    // if it references to create or update date columns
                                    if (referencedColumn.isCreateDate || referencedColumn.isUpdateDate)
                                        relationValue = _this.connection.driver.preparePersistentValue(alreadyInsertedSubject.date, referencedColumn);
                                    // if it references to version column
                                    if (referencedColumn.isVersion)
                                        relationValue = _this.connection.driver.preparePersistentValue(1, referencedColumn);
                                }
                            }
                            else if (relation.inverseRelation) {
                                var inverseSubject = _this.allSubjects.find(function (subject) {
                                    if (!subject.hasEntity || subject.entityTarget !== relation.inverseRelation.target)
                                        return false;
                                    var inverseRelationValue = relation.inverseRelation.getEntityValue(subject.entity);
                                    if (inverseRelationValue) {
                                        if (inverseRelationValue instanceof Array) {
                                            return inverseRelationValue.find(function (subValue) { return subValue === subValue; });
                                        }
                                        else {
                                            return inverseRelationValue === entity;
                                        }
                                    }
                                });
                                if (inverseSubject && joinColumn.referencedColumn.getEntityValue(inverseSubject.entity)) {
                                    relationValue = joinColumn.referencedColumn.getEntityValue(inverseSubject.entity);
                                }
                            }
                            if (relationValue) {
                                values[joinColumn.databaseName] = relationValue;
                            }
                        });
                    });
                    // add special column and value - date of creation
                    if (metadata.createDateColumn) {
                        var value = this.connection.driver.preparePersistentValue(date, metadata.createDateColumn);
                        values[metadata.createDateColumn.databaseName] = value;
                    }
                    // add special column and value - date of updating
                    if (metadata.updateDateColumn) {
                        var value = this.connection.driver.preparePersistentValue(date, metadata.updateDateColumn);
                        values[metadata.updateDateColumn.databaseName] = value;
                    }
                    // add special column and value - version column
                    if (metadata.versionColumn) {
                        var value = this.connection.driver.preparePersistentValue(1, metadata.versionColumn);
                        values[metadata.versionColumn.databaseName] = value;
                    }
                    // add special column and value - discriminator value (for tables using table inheritance)
                    if (metadata.discriminatorColumn) {
                        var value = this.connection.driver.preparePersistentValue(discriminatorValue || metadata.discriminatorValue, metadata.discriminatorColumn);
                        values[metadata.discriminatorColumn.databaseName] = value;
                    }
                    // add special column and value - tree level and tree parents (for tree-type tables)
                    if (metadata.treeLevelColumn && metadata.treeParentRelation) {
                        var parentEntity = metadata.treeParentRelation.getEntityValue(entity);
                        var parentLevel = parentEntity ? (metadata.treeLevelColumn.getEntityValue(parentEntity) || 0) : 0;
                        values[metadata.treeLevelColumn.databaseName] = parentLevel + 1;
                    }
                    // add special column and value - parent id column (for tables using table inheritance)
                    if (metadata.parentEntityMetadata && metadata.parentIdColumns.length) {
                        values[metadata.parentIdColumns[0].databaseName] = parentIdColumnValue || metadata.parentEntityMetadata.primaryColumns[0].getEntityValue(entity);
                    }
                    return values;
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into closure tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts all given subjects into closure table.
                 */
                SubjectOperationExecutor.prototype.executeInsertClosureTableOperations = function () {
                    var _this = this;
                    var promises = this.insertSubjects
                        .filter(function (subject) { return subject.metadata.isClosure; })
                        .map(function (subject) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: 
                                // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                return [4 /*yield*/, this.insertClosureTableValues(subject)];
                                case 1:
                                    // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);
                                    // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    return Promise.all(promises);
                };
                /**
                 * Inserts given subject into closure table.
                 */
                SubjectOperationExecutor.prototype.insertClosureTableValues = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableName, referencedColumn, newEntityId, parentEntity, parentEntityId, parentInsertedSubject, parentSubject, _a, values, _b, _c;
                        return __generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    tableName = subject.metadata.closureJunctionTable.tableName;
                                    referencedColumn = subject.metadata.treeParentRelation.joinColumns[0].referencedColumn;
                                    newEntityId = referencedColumn.getEntityValue(subject.entity);
                                    if (!newEntityId && referencedColumn.isGenerated) {
                                        newEntityId = subject.newlyGeneratedId;
                                        // we should not handle object id here because closure tables are not supported by mongodb driver.
                                    } // todo: implement other special column types too
                                    parentEntity = subject.metadata.treeParentRelation.getEntityValue(subject.entity);
                                    parentEntityId = 0;
                                    if (parentEntity) {
                                        parentEntityId = referencedColumn.getEntityValue(parentEntity);
                                        if (!parentEntityId && referencedColumn.isGenerated) {
                                            parentInsertedSubject = this.insertSubjects.find(function (subject) { return subject.entity === parentEntity; });
                                            // todo: throw exception if parentInsertedSubject is not set
                                            parentEntityId = parentInsertedSubject.newlyGeneratedId;
                                        } // todo: implement other special column types too
                                    }
                                    // try to find parent entity id in some other entity that has this entity in its children
                                    if (!parentEntityId) {
                                        parentSubject = this.allSubjects.find(function (allSubject) {
                                            if (!allSubject.hasEntity || !allSubject.metadata.isClosure || !allSubject.metadata.treeChildrenRelation)
                                                return false;
                                            var children = subject.metadata.treeChildrenRelation.getEntityValue(allSubject.entity);
                                            return children instanceof Array ? children.indexOf(subject.entity) !== -1 : false;
                                        });
                                        if (parentSubject) {
                                            parentEntityId = referencedColumn.getEntityValue(parentSubject);
                                            if (!parentEntityId && parentSubject.newlyGeneratedId) {
                                                parentEntityId = parentSubject.newlyGeneratedId;
                                            }
                                        }
                                    }
                                    // if parent entity exist then insert a new row into closure table
                                    _a = subject;
                                    return [4 /*yield*/, this.queryRunner.insertIntoClosureTable(tableName, newEntityId, parentEntityId, !!subject.metadata.treeLevelColumn)];
                                case 1:
                                    // if parent entity exist then insert a new row into closure table
                                    _a.treeLevel = _d.sent();
                                    if (!subject.metadata.treeLevelColumn) return [3 /*break*/, 3];
                                    values = (_b = {}, _b[subject.metadata.treeLevelColumn.databaseName] = subject.treeLevel, _b);
                                    return [4 /*yield*/, this.queryRunner.update(subject.metadata.tableName, values, (_c = {}, _c[referencedColumn.databaseName] = newEntityId, _c))];
                                case 2:
                                    _d.sent();
                                    _d.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update
                // -------------------------------------------------------------------------
                /**
                 * Updates all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(this.updateSubjects.map(function (subject) { return _this.update(subject); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject in the database.
                 */
                SubjectOperationExecutor.prototype.update = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var entity, idMap, value_1, valueMaps, valueMap, valueMap, valueMap, valueMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    entity = subject.entity;
                                    if (this.connection.driver instanceof MongoDriver_3.MongoDriver) {
                                        idMap = subject.metadata.getDatabaseEntityIdMap(entity);
                                        if (!idMap)
                                            throw new Error("Internal error. Cannot get id of the updating entity.");
                                        value_1 = {};
                                        this.collectColumns(subject.metadata.ownColumns, entity, value_1);
                                        subject.metadata.embeddeds.forEach(function (embed) { return _this.collectEmbeds(embed, entity, value_1); });
                                        // if number of updated columns = 0 no need to update updated date and version columns
                                        if (Object.keys(value_1).length === 0)
                                            return [2 /*return*/];
                                        if (subject.metadata.updateDateColumn)
                                            value_1[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);
                                        if (subject.metadata.versionColumn)
                                            value_1[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);
                                        return [2 /*return*/, this.queryRunner.update(subject.metadata.tableName, value_1, idMap)];
                                    }
                                    valueMaps = [];
                                    // console.log(subject.diffColumns);
                                    subject.diffColumns.forEach(function (column) {
                                        // if (!column.entityTarget) return; // todo: how this can be possible?
                                        var metadata = _this.connection.getMetadata(column.entityMetadata.target);
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === metadata.tableName; });
                                        if (!valueMap) {
                                            valueMap = { tableName: metadata.tableName, metadata: metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[column.databaseName] = _this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);
                                    });
                                    subject.diffRelations.forEach(function (relation) {
                                        var valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === relation.entityMetadata.tableName; });
                                        if (!valueMap) {
                                            valueMap = { tableName: relation.entityMetadata.tableName, metadata: relation.entityMetadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        var value = relation.getEntityValue(entity);
                                        relation.joinColumns.forEach(function (joinColumn) {
                                            valueMap.values[joinColumn.databaseName] = value !== null && value !== undefined ? value[joinColumn.referencedColumn.propertyName] : null; // todo: should not have a call to primaryColumn, instead join column metadata should be used
                                        });
                                    });
                                    // if number of updated columns = 0 no need to update updated date and version columns
                                    if (Object.keys(valueMaps).length === 0)
                                        return [2 /*return*/];
                                    if (subject.metadata.updateDateColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.tableName; });
                                        if (!valueMap) {
                                            valueMap = { tableName: subject.metadata.tableName, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);
                                    }
                                    if (subject.metadata.versionColumn) {
                                        valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.tableName; });
                                        if (!valueMap) {
                                            valueMap = { tableName: subject.metadata.tableName, metadata: subject.metadata, values: {} };
                                            valueMaps.push(valueMap);
                                        }
                                        valueMap.values[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);
                                    }
                                    if (subject.metadata.parentEntityMetadata) {
                                        if (subject.metadata.parentEntityMetadata.updateDateColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.parentEntityMetadata.tableName; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tableName: subject.metadata.parentEntityMetadata.tableName,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.parentEntityMetadata.updateDateColumn);
                                        }
                                        if (subject.metadata.parentEntityMetadata.versionColumn) {
                                            valueMap = valueMaps.find(function (valueMap) { return valueMap.tableName === subject.metadata.parentEntityMetadata.tableName; });
                                            if (!valueMap) {
                                                valueMap = {
                                                    tableName: subject.metadata.parentEntityMetadata.tableName,
                                                    metadata: subject.metadata.parentEntityMetadata,
                                                    values: {}
                                                };
                                                valueMaps.push(valueMap);
                                            }
                                            valueMap.values[subject.metadata.parentEntityMetadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.parentEntityMetadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.parentEntityMetadata.versionColumn);
                                        }
                                    }
                                    return [4 /*yield*/, Promise.all(valueMaps.map(function (valueMap) {
                                            var idMap = valueMap.metadata.getDatabaseEntityIdMap(entity);
                                            if (!idMap)
                                                throw new Error("Internal error. Cannot get id of the updating entity.");
                                            return _this.queryRunner.update(valueMap.tableName, valueMap.values, idMap);
                                        }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Update only relations
                // -------------------------------------------------------------------------
                /**
                 * Updates relations of all given subjects in the database.
                 */
                SubjectOperationExecutor.prototype.executeUpdateRelations = function () {
                    var _this = this;
                    return Promise.all(this.relationUpdateSubjects.map(function (subject) { return _this.updateRelations(subject); }));
                };
                /**
                 * Updates relations of the given subject in the database.
                 */
                SubjectOperationExecutor.prototype.updateRelations = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var values, idMap;
                        return __generator(this, function (_a) {
                            values = {};
                            subject.relationUpdates.forEach(function (setRelation) {
                                setRelation.relation.joinColumns.forEach(function (joinColumn) {
                                    var value = setRelation.value ? setRelation.value[joinColumn.referencedColumn.propertyName] : null;
                                    values[joinColumn.databaseName] = value; // todo: || fromInsertedSubjects ??
                                });
                            });
                            idMap = subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity);
                            if (!idMap)
                                throw new Error("Internal error. Cannot get id of the updating entity.");
                            return [2 /*return*/, this.queryRunner.update(subject.metadata.tableName, values, idMap)];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove
                // -------------------------------------------------------------------------
                /**
                 * Removes all given subjects from the database.
                 */
                SubjectOperationExecutor.prototype.executeRemoveOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_1.PromiseUtils.runInSequence(this.removeSubjects, function (subject) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.remove(subject)];
                                            case 1: return [2 /*return*/, _a.sent()];
                                        }
                                    }); }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates given subject from the database.
                 */
                SubjectOperationExecutor.prototype.remove = function (subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var parentConditions_1, childConditions_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!subject.metadata.parentEntityMetadata) return [3 /*break*/, 3];
                                    parentConditions_1 = {};
                                    subject.metadata.primaryColumns.forEach(function (column) {
                                        parentConditions_1[column.databaseName] = column.getEntityValue(subject.databaseEntity);
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.parentEntityMetadata.tableName, parentConditions_1)];
                                case 1:
                                    _a.sent();
                                    childConditions_1 = {};
                                    subject.metadata.primaryColumns.forEach(function (column) {
                                        childConditions_1[column.databaseName] = column.getEntityValue(subject.databaseEntity);
                                    });
                                    return [4 /*yield*/, this.queryRunner.delete(subject.metadata.tableName, childConditions_1)];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 5];
                                case 3: return [4 /*yield*/, this.queryRunner.delete(subject.metadata.tableName, subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity))];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Insertion into junction tables
                // -------------------------------------------------------------------------
                /**
                 * Inserts into database junction tables all given array of subjects junction data.
                 */
                SubjectOperationExecutor.prototype.executeInsertJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionInserts.forEach(function (junctionInsert) {
                                            promises.push(_this.insertJunctions(subject, junctionInsert));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts into database junction table given subject's junction insert data.
                 */
                SubjectOperationExecutor.prototype.insertJunctions = function (subject, junctionInsert) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var getRelationId, relation, joinColumns, ownId, promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    getRelationId = function (entity, joinColumns) {
                                        return joinColumns.map(function (joinColumn) {
                                            var id = joinColumn.referencedColumn.getEntityValue(entity);
                                            if (!id && joinColumn.referencedColumn.isGenerated) {
                                                var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entity; });
                                                if (insertSubject)
                                                    return insertSubject.newlyGeneratedId;
                                            }
                                            if (!id && joinColumn.referencedColumn.isObjectId) {
                                                var insertSubject = _this.insertSubjects.find(function (subject) { return subject.entity === entity; });
                                                if (insertSubject)
                                                    return insertSubject.generatedObjectId;
                                            }
                                            // todo: implement other special referenced column types (update date, create date, version, discriminator column, etc.)
                                            return id;
                                        });
                                    };
                                    relation = junctionInsert.relation;
                                    joinColumns = relation.isManyToManyOwner ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;
                                    ownId = getRelationId(subject.entity, joinColumns);
                                    if (!ownId.length)
                                        throw new Error("Cannot insert object of " + subject.entityTarget + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                    promises = junctionInsert.junctionEntities.map(function (newBindEntity) {
                                        // get relation id from the newly bind entity
                                        var joinColumns = relation.isManyToManyOwner ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;
                                        var relationId = getRelationId(newBindEntity, joinColumns);
                                        // if relation id still does not exist - we arise an error
                                        if (!relationId)
                                            throw new Error("Cannot insert object of " + newBindEntity.constructor.name + " type. Looks like its not persisted yet, or cascades are not set on the relation."); // todo: better error message
                                        var columns = relation.junctionEntityMetadata.columns.map(function (column) { return column.databaseName; });
                                        var values = relation.isOwning ? ownId.concat(relationId) : relationId.concat(ownId);
                                        return _this.queryRunner.insert(relation.junctionEntityMetadata.tableName, OrmUtils_5.OrmUtils.zipObject(columns, values));
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Remove from junction tables
                // -------------------------------------------------------------------------
                /**
                 * Removes from database junction tables all given array of subjects removal junction data.
                 */
                SubjectOperationExecutor.prototype.executeRemoveJunctionsOperations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var promises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    promises = [];
                                    this.allSubjects.forEach(function (subject) {
                                        subject.junctionRemoves.forEach(function (junctionRemove) {
                                            promises.push(_this.removeJunctions(subject, junctionRemove));
                                        });
                                    });
                                    return [4 /*yield*/, Promise.all(promises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes from database junction table all given subject's removal junction data.
                 */
                SubjectOperationExecutor.prototype.removeJunctions = function (subject, junctionRemove) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var junctionMetadata, entity, firstJoinColumns, secondJoinColumns, conditions, removePromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    junctionMetadata = junctionRemove.relation.junctionEntityMetadata;
                                    entity = subject.hasEntity ? subject.entity : subject.databaseEntity;
                                    firstJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.joinColumns : junctionRemove.relation.inverseRelation.inverseJoinColumns;
                                    secondJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.inverseJoinColumns : junctionRemove.relation.inverseRelation.joinColumns;
                                    conditions = {};
                                    firstJoinColumns.forEach(function (joinColumn) {
                                        conditions[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(entity);
                                    });
                                    removePromises = junctionRemove.junctionRelationIds.map(function (relationIds) {
                                        var inverseConditions = {};
                                        secondJoinColumns.forEach(function (joinColumn) {
                                            inverseConditions[joinColumn.databaseName] = joinColumn.referencedColumn.getEntityValue(relationIds);
                                        });
                                        return _this.queryRunner.delete(junctionMetadata.tableName, Object.assign({}, inverseConditions, conditions));
                                    });
                                    return [4 /*yield*/, Promise.all(removePromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Private Methods: Refresh entity values after persistence
                // -------------------------------------------------------------------------
                /**
                 * Updates all special columns of the saving entities (create date, update date, versioning).
                 */
                SubjectOperationExecutor.prototype.updateSpecialColumnsInPersistedEntities = function () {
                    // update entity columns that gets updated on each entity insert
                    this.insertSubjects.forEach(function (subject) {
                        if (subject.generatedObjectId && subject.metadata.objectIdColumn)
                            subject.metadata.objectIdColumn.setEntityValue(subject.entity, subject.generatedObjectId);
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            if (subject.newlyGeneratedId)
                                primaryColumn.setEntityValue(subject.entity, subject.newlyGeneratedId);
                        });
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            if (subject.parentGeneratedId)
                                primaryColumn.setEntityValue(subject.entity, subject.parentGeneratedId);
                        });
                        if (subject.metadata.updateDateColumn)
                            subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.createDateColumn)
                            subject.metadata.createDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.versionColumn)
                            subject.metadata.versionColumn.setEntityValue(subject.entity, 1);
                        if (subject.metadata.treeLevelColumn) {
                            // const parentEntity = insertOperation.entity[metadata.treeParentMetadata.propertyName];
                            // const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;
                            subject.metadata.treeLevelColumn.setEntityValue(subject.entity, subject.treeLevel);
                        }
                        /*if (subject.metadata.hasTreeChildrenCountColumn) {
                             subject.entity[subject.metadata.treeChildrenCountColumn.propertyName] = 0;
                        }*/
                    });
                    // update special columns that gets updated on each entity update
                    this.updateSubjects.forEach(function (subject) {
                        if (subject.metadata.updateDateColumn)
                            subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);
                        if (subject.metadata.versionColumn)
                            subject.metadata.versionColumn.setEntityValue(subject.entity, subject.metadata.versionColumn.getEntityValue(subject.entity) + 1);
                    });
                    // remove ids from the entities that were removed
                    this.removeSubjects
                        .filter(function (subject) { return subject.hasEntity; })
                        .forEach(function (subject) {
                        subject.metadata.primaryColumns.forEach(function (primaryColumn) {
                            primaryColumn.setEntityValue(subject.entity, undefined);
                        });
                    });
                };
                return SubjectOperationExecutor;
            }());
            exports_108("SubjectOperationExecutor", SubjectOperationExecutor);
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", [], function (exports_109, context_109) {
    "use strict";
    var __moduleName = context_109 && context_109.id;
    var PlainObjectToNewEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToNewEntityTransformer = (function () {
                function PlainObjectToNewEntityTransformer() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToNewEntityTransformer.prototype.transform = function (newEntity, object, metadata) {
                    this.groupAndTransform(newEntity, object, metadata);
                    return newEntity;
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated
                 * we need to group our result and we must have some unique id (primary key in our case)
                 */
                PlainObjectToNewEntityTransformer.prototype.groupAndTransform = function (entity, object, metadata) {
                    var _this = this;
                    // copy regular column properties from the given object
                    metadata.columns
                        .filter(function (column) { return object.hasOwnProperty(column.propertyName); })
                        .forEach(function (column) { return entity[column.propertyName] = object[column.propertyName]; }); // todo: also need to be sure that type is correct
                    // if relation is loaded then go into it recursively and transform its values too
                    metadata.relations
                        .filter(function (relation) { return object.hasOwnProperty(relation.propertyName); })
                        .forEach(function (relation) {
                        var relationMetadata = relation.inverseEntityMetadata;
                        if (!relationMetadata)
                            throw new Error("Relation metadata for the relation " + metadata.name + "#" + relation.propertyName + " is missing");
                        if (relation.isManyToMany || relation.isOneToMany) {
                            if (object[relation.propertyName] instanceof Array) {
                                entity[relation.propertyName] = object[relation.propertyName].map(function (subObject) {
                                    var subEntity = relationMetadata.create();
                                    // todo: support custom initial fields here
                                    if (entity[relation.propertyName] instanceof Array) {
                                        var existRelation = entity[relation.propertyName].find(function (subEntity) {
                                            return subEntity[relation.propertyName] === subObject[relation.propertyName];
                                        });
                                        if (existRelation)
                                            _this.groupAndTransform(subEntity, existRelation, relationMetadata);
                                    }
                                    _this.groupAndTransform(subEntity, subObject, relationMetadata);
                                    return subEntity;
                                });
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                        else {
                            if (object[relation.propertyName]) {
                                var subEntity = relationMetadata.create();
                                if (entity[relation.propertyName])
                                    _this.groupAndTransform(subEntity, entity[relation.propertyName], relationMetadata);
                                _this.groupAndTransform(subEntity, object[relation.propertyName], relationMetadata);
                                entity[relation.propertyName] = subEntity;
                            }
                            else {
                                entity[relation.propertyName] = object[relation.propertyName];
                            }
                        }
                    });
                };
                return PlainObjectToNewEntityTransformer;
            }());
            exports_109("PlainObjectToNewEntityTransformer", PlainObjectToNewEntityTransformer);
        }
    };
});
System.register("typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", [], function (exports_110, context_110) {
    "use strict";
    var __moduleName = context_110 && context_110.id;
    var LoadMapItem, LoadMap, PlainObjectToDatabaseEntityTransformer;
    return {
        setters: [],
        execute: function () {
            /**
             */
            LoadMapItem = (function () {
                function LoadMapItem(plainEntity, metadata, parentLoadMapItem, relation) {
                    this.plainEntity = plainEntity;
                    this.metadata = metadata;
                    this.parentLoadMapItem = parentLoadMapItem;
                    this.relation = relation;
                }
                Object.defineProperty(LoadMapItem.prototype, "target", {
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(LoadMapItem.prototype, "id", {
                    get: function () {
                        return this.metadata.getEntityIdMixedMap(this.plainEntity);
                    },
                    enumerable: true,
                    configurable: true
                });
                LoadMapItem.prototype.compareEntities = function (entity1, entity2) {
                    return this.metadata.compareEntities(entity1, entity2);
                };
                return LoadMapItem;
            }());
            LoadMap = (function () {
                function LoadMap() {
                    this.loadMapItems = [];
                }
                Object.defineProperty(LoadMap.prototype, "mainLoadMapItem", {
                    get: function () {
                        return this.loadMapItems.find(function (item) { return !item.relation && !item.parentLoadMapItem; });
                    },
                    enumerable: true,
                    configurable: true
                });
                LoadMap.prototype.addLoadMap = function (newLoadMap) {
                    var item = this.loadMapItems.find(function (item) { return item.target === newLoadMap.target && item.id === newLoadMap.id; });
                    if (!item)
                        this.loadMapItems.push(newLoadMap);
                };
                LoadMap.prototype.fillEntities = function (target, entities) {
                    var _this = this;
                    entities.forEach(function (entity) {
                        var item = _this.loadMapItems.find(function (loadMapItem) {
                            return loadMapItem.target === target && loadMapItem.compareEntities(entity, loadMapItem.plainEntity);
                        });
                        if (item)
                            item.entity = entity;
                    });
                };
                LoadMap.prototype.groupByTargetIds = function () {
                    var groups = [];
                    this.loadMapItems.forEach(function (loadMapItem) {
                        var group = groups.find(function (group) { return group.target === loadMapItem.target; });
                        if (!group) {
                            group = { target: loadMapItem.target, ids: [] };
                            groups.push(group);
                        }
                        group.ids.push(loadMapItem.id);
                    });
                    return groups;
                };
                return LoadMap;
            }());
            /**
             * Transforms plain old javascript object
             * Entity is constructed based on its entity metadata.
             */
            PlainObjectToDatabaseEntityTransformer = (function () {
                function PlainObjectToDatabaseEntityTransformer(entityManager) {
                    this.entityManager = entityManager;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                PlainObjectToDatabaseEntityTransformer.prototype.transform = function (plainObject, metadata) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var loadMap, fillLoadMap;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if plain object does not have id then nothing to load really
                                    if (!metadata.checkIfObjectContainsAllPrimaryKeys(plainObject))
                                        return [2 /*return*/, Promise.reject("Given object does not have a primary column, cannot transform it to database entity.")];
                                    loadMap = new LoadMap();
                                    fillLoadMap = function (entity, entityMetadata, parentLoadMapItem, relation) {
                                        var item = new LoadMapItem(entity, entityMetadata, parentLoadMapItem, relation);
                                        loadMap.addLoadMap(item);
                                        entityMetadata
                                            .extractRelationValuesFromEntity(entity, metadata.relations)
                                            .filter(function (value) { return value !== null && value !== undefined; })
                                            .forEach(function (_a) {
                                            var relation = _a[0], value = _a[1], inverseEntityMetadata = _a[2];
                                            return fillLoadMap(value, inverseEntityMetadata, item, relation);
                                        });
                                    };
                                    fillLoadMap(plainObject, metadata);
                                    // load all entities and store them in the load map
                                    return [4 /*yield*/, Promise.all(loadMap.groupByTargetIds().map(function (targetWithIds) {
                                            return _this.entityManager
                                                .findByIds(targetWithIds.target, targetWithIds.ids)
                                                .then(function (entities) { return loadMap.fillEntities(targetWithIds.target, entities); });
                                        }))];
                                case 1:
                                    // load all entities and store them in the load map
                                    _a.sent();
                                    // go through each item in the load map and set their entity relationship using metadata stored in load map
                                    loadMap.loadMapItems.forEach(function (loadMapItem) {
                                        if (!loadMapItem.relation ||
                                            !loadMapItem.entity ||
                                            !loadMapItem.parentLoadMapItem ||
                                            !loadMapItem.parentLoadMapItem.entity)
                                            return;
                                        if (loadMapItem.relation.isManyToMany || loadMapItem.relation.isOneToMany) {
                                            if (!loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName])
                                                loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = [];
                                            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName].push(loadMapItem.entity);
                                        }
                                        else {
                                            loadMapItem.parentLoadMapItem.entity[loadMapItem.relation.propertyName] = loadMapItem.entity;
                                        }
                                    });
                                    return [2 /*return*/, loadMap.mainLoadMapItem ? loadMap.mainLoadMapItem.entity : undefined];
                            }
                        });
                    });
                };
                return PlainObjectToDatabaseEntityTransformer;
            }());
            exports_110("PlainObjectToDatabaseEntityTransformer", PlainObjectToDatabaseEntityTransformer);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryNotFoundError", [], function (exports_111, context_111) {
    "use strict";
    var __moduleName = context_111 && context_111.id;
    var CustomRepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository was not found.
             */
            CustomRepositoryNotFoundError = (function (_super) {
                __extends(CustomRepositoryNotFoundError, _super);
                function CustomRepositoryNotFoundError(repository) {
                    var _this = _super.call(this) || this;
                    _this.name = "CustomRepositoryNotFoundError";
                    _this.message = "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " was not found. " +
                        "Did you forgot to put @EntityRepository decorator on it?";
                    return _this;
                }
                return CustomRepositoryNotFoundError;
            }(Error));
            exports_111("CustomRepositoryNotFoundError", CustomRepositoryNotFoundError);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryDoesNotHaveEntityError", [], function (exports_112, context_112) {
    "use strict";
    var __moduleName = context_112 && context_112.id;
    var CustomRepositoryDoesNotHaveEntityError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repositories that extend AbstractRepository classes does not have managed entity.
             */
            CustomRepositoryDoesNotHaveEntityError = (function (_super) {
                __extends(CustomRepositoryDoesNotHaveEntityError, _super);
                function CustomRepositoryDoesNotHaveEntityError(repository) {
                    var _this = _super.call(this, "Custom repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " does not have managed entity. " +
                        "Did you forget to specify entity for it @EntityRepository(MyEntity)? ") || this;
                    _this.name = "CustomRepositoryDoesNotHaveEntityError";
                    return _this;
                }
                return CustomRepositoryDoesNotHaveEntityError;
            }(Error));
            exports_112("CustomRepositoryDoesNotHaveEntityError", CustomRepositoryDoesNotHaveEntityError);
        }
    };
});
System.register("typeorm/repository/AbstractRepository", ["typeorm/repository/error/CustomRepositoryDoesNotHaveEntityError", "typeorm/index", "typeorm/repository/error/CustomRepositoryNotFoundError"], function (exports_113, context_113) {
    "use strict";
    var __moduleName = context_113 && context_113.id;
    var CustomRepositoryDoesNotHaveEntityError_1, index_1, CustomRepositoryNotFoundError_1, AbstractRepository;
    return {
        setters: [
            function (CustomRepositoryDoesNotHaveEntityError_1_1) {
                CustomRepositoryDoesNotHaveEntityError_1 = CustomRepositoryDoesNotHaveEntityError_1_1;
            },
            function (index_1_1) {
                index_1 = index_1_1;
            },
            function (CustomRepositoryNotFoundError_1_1) {
                CustomRepositoryNotFoundError_1 = CustomRepositoryNotFoundError_1_1;
            }
        ],
        execute: function () {
            /**
             * Provides abstract class for custom repositories that do not inherit from original orm Repository.
             * Contains all most-necessary methods to simplify code in the custom repository.
             * All methods are protected thus not exposed and it allows to create encapsulated custom repository.
             *
             * @experimental
             */
            AbstractRepository = (function () {
                function AbstractRepository() {
                }
                Object.defineProperty(AbstractRepository.prototype, "repository", {
                    // -------------------------------------------------------------------------
                    // Protected Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Gets the original ORM repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.manager.getRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AbstractRepository.prototype, "treeRepository", {
                    /**
                     * Gets the original ORM tree repository for the entity that is managed by this repository.
                     * If current repository does not manage any entity, then exception will be thrown.
                     */
                    get: function () {
                        var target = this.getCustomRepositoryTarget(this);
                        if (!target)
                            throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                        return this.manager.getTreeRepository(target);
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates a new query builder for the repository's entity that can be used to build a sql query.
                 * If current repository does not manage any entity, then exception will be thrown.
                 */
                AbstractRepository.prototype.createQueryBuilder = function (alias) {
                    var target = this.getCustomRepositoryTarget(this.constructor);
                    if (!target)
                        throw new CustomRepositoryDoesNotHaveEntityError_1.CustomRepositoryDoesNotHaveEntityError(this.constructor);
                    return this.manager.getRepository(target).createQueryBuilder(alias);
                };
                /**
                 * Creates a new query builder for the given entity that can be used to build a sql query.
                 */
                AbstractRepository.prototype.createQueryBuilderFor = function (entity, alias) {
                    return this.getRepositoryFor(entity).createQueryBuilder(alias);
                };
                /**
                 * Gets the original ORM repository for the given entity class.
                 */
                AbstractRepository.prototype.getRepositoryFor = function (entity) {
                    return this.manager.getRepository(entity);
                };
                /**
                 * Gets the original ORM tree repository for the given entity class.
                 */
                AbstractRepository.prototype.getTreeRepositoryFor = function (entity) {
                    return this.manager.getTreeRepository(entity);
                };
                // -------------------------------------------------------------------------
                // Private Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets custom repository's managed entity.
                 * If given custom repository does not manage any entity then undefined will be returned.
                 */
                AbstractRepository.prototype.getCustomRepositoryTarget = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_1.getMetadataArgsStorage().entityRepositories.find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_1.CustomRepositoryNotFoundError(customRepository);
                    return entityRepositoryMetadataArgs.entity;
                };
                return AbstractRepository;
            }());
            exports_113("AbstractRepository", AbstractRepository);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryCannotInheritRepositoryError", [], function (exports_114, context_114) {
    "use strict";
    var __moduleName = context_114 && context_114.id;
    var CustomRepositoryCannotInheritRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if custom repository inherits Repository class however entity is not set in @EntityRepository decorator.
             */
            CustomRepositoryCannotInheritRepositoryError = (function (_super) {
                __extends(CustomRepositoryCannotInheritRepositoryError, _super);
                function CustomRepositoryCannotInheritRepositoryError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        " cannot inherit Repository class without entity being set in the @EntityRepository decorator.") || this;
                    _this.name = "CustomRepositoryCannotInheritRepositoryError";
                    return _this;
                }
                return CustomRepositoryCannotInheritRepositoryError;
            }(Error));
            exports_114("CustomRepositoryCannotInheritRepositoryError", CustomRepositoryCannotInheritRepositoryError);
        }
    };
});
System.register("typeorm/entity-manager/EntityManager", ["typeorm/query-runner/error/QueryRunnerProviderAlreadyReleasedError", "typeorm/query-runner/QueryRunnerProvider", "typeorm/repository/RepositoryAggregator", "typeorm/entity-manager/error/NoNeedToReleaseEntityManagerError", "typeorm/repository/Repository", "typeorm/connection/error/RepositoryNotTreeError", "typeorm/query-builder/QueryBuilder", "typeorm/find-options/FindOptionsUtils", "typeorm/persistence/SubjectBuilder", "typeorm/persistence/SubjectOperationExecutor", "typeorm/query-builder/transformer/PlainObjectToNewEntityTransformer", "typeorm/query-builder/transformer/PlainObjectToDatabaseEntityTransformer", "typeorm/repository/error/CustomRepositoryNotFoundError", "typeorm/index", "typeorm/repository/AbstractRepository", "typeorm/repository/error/CustomRepositoryCannotInheritRepositoryError"], function (exports_115, context_115) {
    "use strict";
    var __moduleName = context_115 && context_115.id;
    var QueryRunnerProviderAlreadyReleasedError_1, QueryRunnerProvider_3, RepositoryAggregator_1, NoNeedToReleaseEntityManagerError_1, Repository_4, RepositoryNotTreeError_1, QueryBuilder_5, FindOptionsUtils_2, SubjectBuilder_1, SubjectOperationExecutor_1, PlainObjectToNewEntityTransformer_1, PlainObjectToDatabaseEntityTransformer_1, CustomRepositoryNotFoundError_2, index_2, AbstractRepository_1, CustomRepositoryCannotInheritRepositoryError_1, EntityManager;
    return {
        setters: [
            function (QueryRunnerProviderAlreadyReleasedError_1_1) {
                QueryRunnerProviderAlreadyReleasedError_1 = QueryRunnerProviderAlreadyReleasedError_1_1;
            },
            function (QueryRunnerProvider_3_1) {
                QueryRunnerProvider_3 = QueryRunnerProvider_3_1;
            },
            function (RepositoryAggregator_1_1) {
                RepositoryAggregator_1 = RepositoryAggregator_1_1;
            },
            function (NoNeedToReleaseEntityManagerError_1_1) {
                NoNeedToReleaseEntityManagerError_1 = NoNeedToReleaseEntityManagerError_1_1;
            },
            function (Repository_4_1) {
                Repository_4 = Repository_4_1;
            },
            function (RepositoryNotTreeError_1_1) {
                RepositoryNotTreeError_1 = RepositoryNotTreeError_1_1;
            },
            function (QueryBuilder_5_1) {
                QueryBuilder_5 = QueryBuilder_5_1;
            },
            function (FindOptionsUtils_2_1) {
                FindOptionsUtils_2 = FindOptionsUtils_2_1;
            },
            function (SubjectBuilder_1_1) {
                SubjectBuilder_1 = SubjectBuilder_1_1;
            },
            function (SubjectOperationExecutor_1_1) {
                SubjectOperationExecutor_1 = SubjectOperationExecutor_1_1;
            },
            function (PlainObjectToNewEntityTransformer_1_1) {
                PlainObjectToNewEntityTransformer_1 = PlainObjectToNewEntityTransformer_1_1;
            },
            function (PlainObjectToDatabaseEntityTransformer_1_1) {
                PlainObjectToDatabaseEntityTransformer_1 = PlainObjectToDatabaseEntityTransformer_1_1;
            },
            function (CustomRepositoryNotFoundError_2_1) {
                CustomRepositoryNotFoundError_2 = CustomRepositoryNotFoundError_2_1;
            },
            function (index_2_1) {
                index_2 = index_2_1;
            },
            function (AbstractRepository_1_1) {
                AbstractRepository_1 = AbstractRepository_1_1;
            },
            function (CustomRepositoryCannotInheritRepositoryError_1_1) {
                CustomRepositoryCannotInheritRepositoryError_1 = CustomRepositoryCannotInheritRepositoryError_1_1;
            }
        ],
        execute: function () {
            /**
             * Entity manager supposed to work with any entity, automatically find its repository and call its methods,
             * whatever entity type are you passing.
             */
            EntityManager = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                /**
                 * @param connection Connection to be used in this entity manager
                 * @param queryRunnerProvider Custom query runner to be used for operations in this entity manager
                 */
                function EntityManager(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider;
                    // -------------------------------------------------------------------------
                    // Private properties
                    // -------------------------------------------------------------------------
                    /**
                     * Stores temporarily user data.
                     * Useful for sharing data with subscribers.
                     */
                    this.data = {};
                    /**
                     * Stores all registered repositories.
                     */
                    this.repositoryAggregators = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Gets user data by a given key.
                 * Used get stored data stored in a transactional entity manager.
                 */
                EntityManager.prototype.getData = function (key) {
                    return this.data[key];
                };
                /**
                 * Sets value for the given key in user data.
                 * Used to store data in a transactional entity manager which can be accessed in subscribers then.
                 */
                EntityManager.prototype.setData = function (key, value) {
                    this.data[key] = value;
                    return this;
                };
                /**
                 * Checks if entity has an id by its Function type or schema name.
                 */
                EntityManager.prototype.hasId = function (targetOrEntity, maybeEntity) {
                    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var metadata = this.connection.getMetadata(target);
                    return metadata.hasId(entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                EntityManager.prototype.getId = function (targetOrEntity, maybeEntity) {
                    var target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;
                    var entity = arguments.length === 2 ? maybeEntity : targetOrEntity;
                    var metadata = this.connection.getMetadata(target);
                    return metadata.getEntityIdMixedMap(entity);
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                EntityManager.prototype.createQueryBuilder = function (entityClass, alias, queryRunnerProvider) {
                    var metadata = this.connection.getMetadata(entityClass);
                    return new QueryBuilder_5.QueryBuilder(this.connection, queryRunnerProvider || this.queryRunnerProvider)
                        .select(alias)
                        .from(metadata.target, alias);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                EntityManager.prototype.create = function (entityClass, plainObjectOrObjects) {
                    var _this = this;
                    var metadata = this.connection.getMetadata(entityClass);
                    if (!plainObjectOrObjects)
                        return metadata.create();
                    if (plainObjectOrObjects instanceof Array)
                        return plainObjectOrObjects.map(function (plainEntityLike) { return _this.create(entityClass, plainEntityLike); });
                    return this.merge(entityClass, metadata.create(), plainObjectOrObjects);
                };
                /**
                 * Merges two entities into one new entity.
                 */
                EntityManager.prototype.merge = function (entityClass, mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        entityLikes[_i - 2] = arguments[_i];
                    }
                    var metadata = this.connection.getMetadata(entityClass);
                    var plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer_1.PlainObjectToNewEntityTransformer();
                    entityLikes.forEach(function (object) { return plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata); });
                    return mergeIntoEntity;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 */
                EntityManager.prototype.preload = function (entityClass, entityLike) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, plainObjectToDatabaseEntityTransformer, transformedEntity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClass);
                                    plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer_1.PlainObjectToDatabaseEntityTransformer(this.connection.manager);
                                    return [4 /*yield*/, plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata)];
                                case 1:
                                    transformedEntity = _a.sent();
                                    if (transformedEntity)
                                        return [2 /*return*/, this.merge(entityClass, transformedEntity, entityLike)];
                                    return [2 /*return*/, undefined];
                            }
                        });
                    });
                };
                /**
                 * Persists (saves) a given entity in the database.
                 */
                EntityManager.prototype.save = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {
                    var _this = this;
                    var target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === "string")) ? targetOrEntity : undefined;
                    var entity = target ? maybeEntityOrOptions : targetOrEntity;
                    var options = target ? maybeOptions : maybeEntityOrOptions;
                    return Promise.resolve().then(function () { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var finalTarget;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(entity instanceof Array)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, Promise.all(entity.map(function (e) {
                                            var finalTarget = target ? target : e.constructor;
                                            return _this.saveOne(finalTarget, e, options);
                                        }))];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2:
                                    finalTarget = target ? target : entity.constructor;
                                    return [4 /*yield*/, this.saveOne(finalTarget, entity, options)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/, entity];
                            }
                        });
                    }); });
                };
                /**
                 * Persists (saves) a given entity in the database.
                 *
                 * @deprecated
                 */
                EntityManager.prototype.persist = function (targetOrEntity, maybeEntity, options) {
                    return this.save(targetOrEntity, maybeEntity, options);
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 */
                EntityManager.prototype.update = function (target, conditionsOrFindOptions, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var entity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findOne(target, conditionsOrFindOptions)];
                                case 1:
                                    entity = _a.sent();
                                    if (!entity)
                                        throw new Error("Cannot find entity to update by a given criteria");
                                    Object.assign(entity, partialEntity);
                                    return [4 /*yield*/, this.save(entity, options)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 */
                EntityManager.prototype.updateById = function (target, id, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var entity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findOneById(target, id)];
                                case 1:
                                    entity = _a.sent();
                                    if (!entity)
                                        throw new Error("Cannot find entity to update by a id");
                                    Object.assign(entity, partialEntity);
                                    return [4 /*yield*/, this.save(entity, options)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Removes a given entity from the database.
                 */
                EntityManager.prototype.remove = function (targetOrEntity, maybeEntityOrOptions, maybeOptions) {
                    var _this = this;
                    var target = (arguments.length > 1 && (targetOrEntity instanceof Function || typeof targetOrEntity === "string")) ? targetOrEntity : undefined;
                    var entity = target ? maybeEntityOrOptions : targetOrEntity;
                    var options = target ? maybeOptions : maybeEntityOrOptions;
                    return Promise.resolve().then(function () { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var finalTarget;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(entity instanceof Array)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, Promise.all(entity.map(function (e) {
                                            var finalTarget = target ? target : e.constructor;
                                            return _this.removeOne(finalTarget, e, options);
                                        }))];
                                case 1:
                                    _a.sent();
                                    return [3 /*break*/, 4];
                                case 2:
                                    finalTarget = target ? target : entity.constructor;
                                    return [4 /*yield*/, this.removeOne(finalTarget, entity, options)];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/, entity];
                            }
                        });
                    }); });
                };
                /**
                 * Removes entity by a given entity id.
                 */
                EntityManager.prototype.removeById = function (targetOrEntity, id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var entity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findOneById(targetOrEntity, id)];
                                case 1:
                                    entity = _a.sent();
                                    if (!entity)
                                        throw new Error("Cannot find entity to remove by a given id");
                                    return [4 /*yield*/, this.remove(entity, options)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Counts entities that match given find options or conditions.
                 */
                EntityManager.prototype.count = function (entityClass, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                    return FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getCount();
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                EntityManager.prototype.find = function (entityClass, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                    return FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getMany();
                };
                /**
                 * Finds entities that match given find options and conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                EntityManager.prototype.findAndCount = function (entityClass, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                    return FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getManyAndCount();
                };
                /**
                 * Finds entities with ids.
                 * Optionally find options or conditions can be applied.
                 */
                EntityManager.prototype.findByIds = function (entityClass, ids, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindManyOptionsAlias(optionsOrConditions) || metadata.name);
                    FindOptionsUtils_2.FindOptionsUtils.applyFindManyOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);
                    ids = ids.map(function (id) {
                        if (!metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                            return metadata.createEntityIdMap([id]);
                        }
                        return id;
                    });
                    qb.andWhereInIds(ids);
                    return qb.getMany();
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                EntityManager.prototype.findOne = function (entityClass, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindOneOptionsAlias(optionsOrConditions) || metadata.name);
                    return FindOptionsUtils_2.FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions).getOne();
                };
                /**
                 * Finds entity with given id.
                 * Optionally find options or conditions can be applied.
                 */
                EntityManager.prototype.findOneById = function (entityClass, id, optionsOrConditions) {
                    var metadata = this.connection.getMetadata(entityClass);
                    var qb = this.createQueryBuilder(entityClass, FindOptionsUtils_2.FindOptionsUtils.extractFindOneOptionsAlias(optionsOrConditions) || metadata.name);
                    if (metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                        // const columnNames = this.metadata.getEntityIdMap({  });
                        throw new Error("You have multiple primary keys in your entity, to use findOneById with multiple primary keys please provide " +
                            "complete object with all entity ids, like this: { firstKey: value, secondKey: value }");
                    }
                    FindOptionsUtils_2.FindOptionsUtils.applyFindOneOptionsOrConditionsToQueryBuilder(qb, optionsOrConditions);
                    if (!metadata.hasMultiplePrimaryKeys && !(id instanceof Object)) {
                        id = metadata.createEntityIdMap([id]);
                    }
                    qb.andWhereInIds([id]);
                    return qb.getOne();
                };
                /**
                 * Executes raw SQL query and returns raw database results.
                 */
                EntityManager.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 6]);
                                    return [4 /*yield*/, queryRunner.query(query, parameters)];
                                case 3: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 4: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Wraps given function execution (and all operations made there) in a transaction.
                 * All database operations must be executed using provided entity manager.
                 */
                EntityManager.prototype.transaction = function (runInTransaction) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunnerProvider, queryRunner, transactionEntityManager, result, err_1;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                                        throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver, true);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    transactionEntityManager = new EntityManager(this.connection, queryRunnerProvider);
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 12]);
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/, runInTransaction(transactionEntityManager)];
                                case 4:
                                    result = _a.sent();
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/, result];
                                case 6:
                                    err_1 = _a.sent();
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw err_1;
                                case 8: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 9:
                                    _a.sent();
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Clears all the data from the given table (truncates/drops it).
                 */
                EntityManager.prototype.clear = function (entityClass) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, queryRunnerProvider, queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(entityClass);
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver);
                                    return [4 /*yield*/, queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, , 4, 6]);
                                    return [4 /*yield*/, queryRunner.truncate(metadata.tableName)];
                                case 3: return [2 /*return*/, _a.sent()]; // await is needed here because we are using finally
                                case 4: return [4 /*yield*/, queryRunnerProvider.release(queryRunner)];
                                case 5:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                EntityManager.prototype.getRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider)
                        return this.obtainRepositoryAggregator(entityClassOrName).repository;
                    return this.connection.getRepository(entityClassOrName);
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 */
                EntityManager.prototype.getTreeRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider) {
                        var treeRepository = this.obtainRepositoryAggregator(entityClassOrName).treeRepository;
                        if (!treeRepository)
                            throw new RepositoryNotTreeError_1.RepositoryNotTreeError(entityClassOrName);
                        return treeRepository;
                    }
                    return this.connection.getTreeRepository(entityClassOrName);
                };
                /**
                 * Gets mongodb repository for the given entity class or name.
                 */
                EntityManager.prototype.getMongoRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider)
                        return this.obtainRepositoryAggregator(entityClassOrName).repository;
                    return this.connection.getMongoRepository(entityClassOrName);
                };
                /**
                 * Gets specific repository for the given entity class or name.
                 * If single database connection mode is used, then repository is obtained from the
                 * repository aggregator, where each repository is individually created for this entity manager.
                 * When single database connection is not used, repository is being obtained from the connection.
                 *
                 * @deprecated Don't use specific repository - it will be refactored or removed
                 */
                EntityManager.prototype.getSpecificRepository = function (entityClassOrName) {
                    // if single db connection is used then create its own repository with reused query runner
                    if (this.queryRunnerProvider)
                        return this.obtainRepositoryAggregator(entityClassOrName).specificRepository;
                    return this.connection.getSpecificRepository(entityClassOrName);
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                EntityManager.prototype.getCustomRepository = function (customRepository) {
                    var entityRepositoryMetadataArgs = index_2.getMetadataArgsStorage().entityRepositories.find(function (repository) {
                        return repository.target === (customRepository instanceof Function ? customRepository : customRepository.constructor);
                    });
                    if (!entityRepositoryMetadataArgs)
                        throw new CustomRepositoryNotFoundError_2.CustomRepositoryNotFoundError(customRepository);
                    var entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;
                    var entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);
                    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,
                    // however we need these properties for internal work of the class
                    if (entityRepositoryInstance instanceof AbstractRepository_1.AbstractRepository) {
                        if (!entityRepositoryInstance["manager"])
                            entityRepositoryInstance["manager"] = this;
                    }
                    if (entityRepositoryInstance instanceof Repository_4.Repository) {
                        if (!entityMetadata)
                            throw new CustomRepositoryCannotInheritRepositoryError_1.CustomRepositoryCannotInheritRepositoryError(customRepository);
                        entityRepositoryInstance["manager"] = this;
                        entityRepositoryInstance["metadata"] = entityMetadata;
                    }
                    return entityRepositoryInstance;
                };
                /**
                 * Releases all resources used by entity manager.
                 * This is used when entity manager is created with a single query runner,
                 * and this single query runner needs to be released after job with entity manager is done.
                 */
                EntityManager.prototype.release = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (!this.queryRunnerProvider)
                                throw new NoNeedToReleaseEntityManagerError_1.NoNeedToReleaseEntityManagerError();
                            return [2 /*return*/, this.queryRunnerProvider.releaseReused()];
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs a save operation for a single entity.
                 */
                EntityManager.prototype.saveOne = function (target, entity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, queryRunnerProvider, transactionEntityManager, databaseEntityLoader, executor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(target);
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver, true);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 4, 7]);
                                    transactionEntityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(queryRunnerProvider);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunnerProvider);
                                    return [4 /*yield*/, databaseEntityLoader.persist(entity, metadata)];
                                case 2:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunnerProvider);
                                    return [4 /*yield*/, executor.execute(databaseEntityLoader.operateSubjects)];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 7];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Performs a remove operation for a single entity.
                 */
                EntityManager.prototype.removeOne = function (target, entity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var metadata, queryRunnerProvider, transactionEntityManager, databaseEntityLoader, executor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    metadata = this.connection.getMetadata(target);
                                    queryRunnerProvider = this.queryRunnerProvider || new QueryRunnerProvider_3.QueryRunnerProvider(this.connection.driver, true);
                                    _a.label = 1;
                                case 1:
                                    _a.trys.push([1, , 4, 7]);
                                    transactionEntityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(queryRunnerProvider);
                                    databaseEntityLoader = new SubjectBuilder_1.SubjectBuilder(this.connection, queryRunnerProvider);
                                    return [4 /*yield*/, databaseEntityLoader.remove(entity, metadata)];
                                case 2:
                                    _a.sent();
                                    executor = new SubjectOperationExecutor_1.SubjectOperationExecutor(this.connection, transactionEntityManager, queryRunnerProvider);
                                    return [4 /*yield*/, executor.execute(databaseEntityLoader.operateSubjects)];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 7];
                                case 4:
                                    if (!!this.queryRunnerProvider) return [3 /*break*/, 6];
                                    return [4 /*yield*/, queryRunnerProvider.releaseReused()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [7 /*endfinally*/];
                                case 7: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Gets, or if does not exist yet, creates and returns a repository aggregator for a particular entity target.
                 */
                EntityManager.prototype.obtainRepositoryAggregator = function (entityClassOrName) {
                    if (this.queryRunnerProvider && this.queryRunnerProvider.isReleased)
                        throw new QueryRunnerProviderAlreadyReleasedError_1.QueryRunnerProviderAlreadyReleasedError();
                    var metadata = this.connection.getMetadata(entityClassOrName);
                    var repositoryAggregator = this.repositoryAggregators.find(function (repositoryAggregate) { return repositoryAggregate.metadata === metadata; });
                    if (!repositoryAggregator) {
                        repositoryAggregator = new RepositoryAggregator_1.RepositoryAggregator(this.connection, this.connection.getMetadata(entityClassOrName), this.queryRunnerProvider);
                        this.repositoryAggregators.push(repositoryAggregator); // todo: check isnt memory leak here?
                    }
                    return repositoryAggregator;
                };
                return EntityManager;
            }());
            exports_115("EntityManager", EntityManager);
        }
    };
});
System.register("typeorm/repository/Repository", [], function (exports_116, context_116) {
    "use strict";
    var __moduleName = context_116 && context_116.id;
    var Repository;
    return {
        setters: [],
        execute: function () {
            /**
             * Repository is supposed to work with your entity objects. Find entities, insert, update, delete, etc.
             */
            Repository = (function () {
                function Repository() {
                }
                Object.defineProperty(Repository.prototype, "target", {
                    // -------------------------------------------------------------------------
                    // Public Methods
                    // -------------------------------------------------------------------------
                    /**
                     * Returns object that is managed by this repository.
                     * If this repository manages entity from schema,
                     * then it returns a name of that schema instead.
                     */
                    get: function () {
                        return this.metadata.target;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Checks if entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                Repository.prototype.hasId = function (entity) {
                    return this.manager.hasId(this.metadata.target, entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                Repository.prototype.getId = function (entity) {
                    return this.manager.getId(this.metadata.target, entity);
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                Repository.prototype.createQueryBuilder = function (alias, queryRunnerProvider) {
                    return this.manager.createQueryBuilder(this.metadata.target, alias, queryRunnerProvider);
                };
                /**
                 * Creates a new entity instance or instances.
                 * Can copy properties from the given object into new entities.
                 */
                Repository.prototype.create = function (plainEntityLikeOrPlainEntityLikes) {
                    return this.manager.create(this.metadata.target, plainEntityLikeOrPlainEntityLikes);
                };
                /**
                 * Merges multiple entities (or entity-like objects) into a given entity.
                 */
                Repository.prototype.merge = function (mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        entityLikes[_i - 1] = arguments[_i];
                    }
                    return (_a = this.manager).merge.apply(_a, [this.metadata.target, mergeIntoEntity].concat(entityLikes));
                    var _a;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 *
                 * Note that given entity-like object must have an entity id / primary key to find entity by.
                 * Returns undefined if entity with given id was not found.
                 */
                Repository.prototype.preload = function (entityLike) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.preload(this.metadata.target, entityLike)];
                        });
                    });
                };
                /**
                 * Saves one or many given entities.
                 */
                Repository.prototype.save = function (entityOrEntities, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.save(this.metadata.target, entityOrEntities, options)];
                        });
                    });
                };
                /**
                 * Saves one or many given entities.
                 */
                Repository.prototype.persist = function (entityOrEntities, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.save(entityOrEntities, options)];
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 */
                Repository.prototype.update = function (conditionsOrFindOptions, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var entity;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.findOne(conditionsOrFindOptions)];
                                case 1:
                                    entity = _a.sent();
                                    if (!entity)
                                        throw new Error("Cannot find entity to update by a given criteria");
                                    Object.assign(entity, partialEntity);
                                    return [4 /*yield*/, this.save(entity, options)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 */
                Repository.prototype.updateById = function (id, partialEntity, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.updateById(this.metadata.target, id, partialEntity, options)];
                        });
                    });
                };
                /**
                 * Removes one or many given entities.
                 */
                Repository.prototype.remove = function (entityOrEntities, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.remove(this.metadata.target, entityOrEntities, options)];
                        });
                    });
                };
                /**
                 * Removes entity by a given entity id.
                 */
                Repository.prototype.removeById = function (id, options) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.removeById(this.metadata.target, id, options)];
                        });
                    });
                };
                /**
                 * Counts entities that match given find options or conditions.
                 */
                Repository.prototype.count = function (optionsOrConditions) {
                    return this.manager.count(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                Repository.prototype.find = function (optionsOrConditions) {
                    return this.manager.find(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                Repository.prototype.findAndCount = function (optionsOrConditions) {
                    return this.manager.findAndCount(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                Repository.prototype.findByIds = function (ids, optionsOrConditions) {
                    return this.manager.findByIds(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                Repository.prototype.findOne = function (optionsOrConditions) {
                    return this.manager.findOne(this.metadata.target, optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                Repository.prototype.findOneById = function (id, optionsOrConditions) {
                    return this.manager.findOneById(this.metadata.target, id, optionsOrConditions);
                };
                /**
                 * Executes a raw SQL query and returns a raw database results.
                 * Raw query execution is supported only by relational databases (MongoDB is not supported).
                 */
                Repository.prototype.query = function (query, parameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.query(query, parameters)];
                        });
                    });
                };
                /**
                 * Clears all the data from the given table/collection (truncates/drops it).
                 */
                Repository.prototype.clear = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.manager.clear(this.metadata.target)];
                        });
                    });
                };
                return Repository;
            }());
            exports_116("Repository", Repository);
        }
    };
});
System.register("typeorm/subscriber/event/UpdateEvent", [], function (exports_117, context_117) {
    "use strict";
    var __moduleName = context_117 && context_117.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/RemoveEvent", [], function (exports_118, context_118) {
    "use strict";
    var __moduleName = context_118 && context_118.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/event/InsertEvent", [], function (exports_119, context_119) {
    "use strict";
    var __moduleName = context_119 && context_119.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/subscriber/EntitySubscriberInterface", [], function (exports_120, context_120) {
    "use strict";
    var __moduleName = context_120 && context_120.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/RepositoryNotFoundError", [], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    var RepositoryNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when repository for the given class is not found.
             */
            RepositoryNotFoundError = (function (_super) {
                __extends(RepositoryNotFoundError, _super);
                function RepositoryNotFoundError(connectionName, entityClass) {
                    var _this = _super.call(this) || this;
                    _this.name = "RepositoryNotFoundError";
                    var targetName = typeof entityClass === "function" && entityClass.name ? entityClass.name : entityClass;
                    _this.message = "No repository for \"" + targetName + "\" was found. Looks like this entity is not registered in " +
                        ("current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return RepositoryNotFoundError;
            }(Error));
            exports_121("RepositoryNotFoundError", RepositoryNotFoundError);
        }
    };
});
System.register("typeorm/util/DirectoryExportedClassesLoader", ["typeorm/platform/PlatformTools"], function (exports_122, context_122) {
    "use strict";
    var __moduleName = context_122 && context_122.id;
    /**
     * Loads all exported classes from the given directory.
     */
    function importClassesFromDirectories(directories, formats) {
        if (formats === void 0) { formats = [".js", ".ts"]; }
        function loadFileClasses(exported, allLoaded) {
            if (exported instanceof Function) {
                allLoaded.push(exported);
            }
            else if (exported instanceof Object) {
                Object.keys(exported).forEach(function (key) { return loadFileClasses(exported[key], allLoaded); });
            }
            else if (exported instanceof Array) {
                exported.forEach(function (i) { return loadFileClasses(i, allLoaded); });
            }
            return allLoaded;
        }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_7.PlatformTools.load("glob").sync(PlatformTools_7.PlatformTools.pathNormilize(dir)));
        }, []);
        var dirs = allFiles
            .filter(function (file) {
            var dtsExtension = file.substring(file.length - 5, file.length);
            return formats.indexOf(PlatformTools_7.PlatformTools.pathExtname(file)) !== -1 && dtsExtension !== ".d.ts";
        })
            .map(function (file) { return PlatformTools_7.PlatformTools.load(PlatformTools_7.PlatformTools.pathResolve(file)); });
        return loadFileClasses(dirs, []);
    }
    exports_122("importClassesFromDirectories", importClassesFromDirectories);
    /**
     * Loads all json files from the given directory.
     */
    function importJsonsFromDirectories(directories, format) {
        if (format === void 0) { format = ".json"; }
        var allFiles = directories.reduce(function (allDirs, dir) {
            return allDirs.concat(PlatformTools_7.PlatformTools.load("glob").sync(PlatformTools_7.PlatformTools.pathNormilize(dir)));
        }, []);
        return allFiles
            .filter(function (file) { return PlatformTools_7.PlatformTools.pathExtname(file) === format; })
            .map(function (file) { return PlatformTools_7.PlatformTools.load(PlatformTools_7.PlatformTools.pathResolve(file)); });
    }
    exports_122("importJsonsFromDirectories", importJsonsFromDirectories);
    var PlatformTools_7;
    return {
        setters: [
            function (PlatformTools_7_1) {
                PlatformTools_7 = PlatformTools_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/NamingStrategyMetadataArgs", [], function (exports_123, context_123) {
    "use strict";
    var __moduleName = context_123 && context_123.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/JoinColumnMetadataArgs", [], function (exports_124, context_124) {
    "use strict";
    var __moduleName = context_124 && context_124.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/JoinTableMetadataArgs", [], function (exports_125, context_125) {
    "use strict";
    var __moduleName = context_125 && context_125.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntitySubscriberMetadataArgs", [], function (exports_126, context_126) {
    "use strict";
    var __moduleName = context_126 && context_126.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/InheritanceMetadataArgs", [], function (exports_127, context_127) {
    "use strict";
    var __moduleName = context_127 && context_127.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/DiscriminatorValueMetadataArgs", [], function (exports_128, context_128) {
    "use strict";
    var __moduleName = context_128 && context_128.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntityRepositoryMetadataArgs", [], function (exports_129, context_129) {
    "use strict";
    var __moduleName = context_129 && context_129.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/TransactionEntityMetadataArgs", [], function (exports_130, context_130) {
    "use strict";
    var __moduleName = context_130 && context_130.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-builder/MetadataUtils", [], function (exports_131, context_131) {
    "use strict";
    var __moduleName = context_131 && context_131.id;
    var MetadataUtils;
    return {
        setters: [],
        execute: function () {
            /**
             * Metadata args utility functions.
             */
            MetadataUtils = (function () {
                function MetadataUtils() {
                }
                /**
                 * Gets given's entity all inherited classes.
                 * Gives in order from parents to children.
                 * For example Post extends ContentModel which extends Unit it will give
                 * [Unit, ContentModel, Post]
                 */
                MetadataUtils.getInheritanceTree = function (entity) {
                    var tree = [entity];
                    var getPrototypeOf = function (object) {
                        var proto = Object.getPrototypeOf(object);
                        if (proto && proto.name) {
                            tree.push(proto);
                            getPrototypeOf(proto);
                        }
                    };
                    getPrototypeOf(entity);
                    return tree;
                };
                /**
                 * Checks if this table is inherited from another table.
                 */
                MetadataUtils.isInherited = function (target1, target2) {
                    return target1.prototype instanceof target2;
                };
                /**
                 * Filters given array of targets by a given classes.
                 * If classes are not given, then it returns array itself.
                 */
                MetadataUtils.filterByTarget = function (array, classes) {
                    if (!classes)
                        return array;
                    return array.filter(function (item) { return item.target && classes.indexOf(item.target) !== -1; });
                };
                return MetadataUtils;
            }());
            exports_131("MetadataUtils", MetadataUtils);
        }
    };
});
System.register("typeorm/metadata-args/MetadataArgsStorage", ["typeorm/metadata-builder/MetadataUtils"], function (exports_132, context_132) {
    "use strict";
    var __moduleName = context_132 && context_132.id;
    var MetadataUtils_1, MetadataArgsStorage;
    return {
        setters: [
            function (MetadataUtils_1_1) {
                MetadataUtils_1 = MetadataUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Storage all metadatas args of all available types: tables, columns, subscribers, relations, etc.
             * Each metadata args represents some specifications of what it represents.
             * MetadataArgs used to create a real Metadata objects.
             */
            MetadataArgsStorage = (function () {
                function MetadataArgsStorage() {
                    // -------------------------------------------------------------------------
                    // Properties
                    // -------------------------------------------------------------------------
                    this.tables = [];
                    this.entityRepositories = [];
                    this.transactionEntityManagers = [];
                    this.namingStrategies = [];
                    this.entitySubscribers = [];
                    this.indices = [];
                    this.columns = [];
                    this.relations = [];
                    this.joinColumns = [];
                    this.joinTables = [];
                    this.entityListeners = [];
                    this.relationCounts = [];
                    this.relationIds = [];
                    this.embeddeds = [];
                    this.inheritances = [];
                    this.discriminatorValues = [];
                }
                MetadataArgsStorage.prototype.filterTables = function (target) {
                    return this.tables.filter(function (table) {
                        return target instanceof Array ? target.indexOf(table.target) !== -1 : table.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterColumns = function (target) {
                    return this.columns.filter(function (column) {
                        return target instanceof Array ? target.indexOf(column.target) !== -1 : column.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterRelations = function (target) {
                    return this.relations.filter(function (relation) {
                        return target instanceof Array ? target.indexOf(relation.target) !== -1 : relation.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterRelationIds = function (target) {
                    return this.relationIds.filter(function (relationId) {
                        return target instanceof Array ? target.indexOf(relationId.target) !== -1 : relationId.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterRelationCounts = function (target) {
                    return this.relationCounts.filter(function (relationCount) {
                        return target instanceof Array ? target.indexOf(relationCount.target) !== -1 : relationCount.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterIndices = function (target) {
                    return this.indices.filter(function (index) {
                        return target instanceof Array ? target.indexOf(index.target) !== -1 : index.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterListeners = function (target) {
                    return this.entityListeners.filter(function (index) {
                        return target instanceof Array ? target.indexOf(index.target) !== -1 : index.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterEmbeddeds = function (target) {
                    return this.embeddeds.filter(function (embedded) {
                        return target instanceof Array ? target.indexOf(embedded.target) !== -1 : embedded.target === target;
                    });
                };
                MetadataArgsStorage.prototype.findJoinTable = function (target, propertyName) {
                    return this.joinTables.find(function (joinTable) {
                        return joinTable.target === target && joinTable.propertyName === propertyName;
                    });
                };
                MetadataArgsStorage.prototype.filterJoinColumns = function (target, propertyName) {
                    return this.joinColumns.filter(function (joinColumn) {
                        return joinColumn.target === target && joinColumn.propertyName === propertyName;
                    });
                };
                MetadataArgsStorage.prototype.filterSubscribers = function (target) {
                    return this.entitySubscribers.filter(function (subscriber) {
                        return target instanceof Array ? target.indexOf(subscriber.target) !== -1 : subscriber.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterNamingStrategies = function (target) {
                    return this.namingStrategies.filter(function (subscriber) {
                        return target instanceof Array ? target.indexOf(subscriber.target) !== -1 : subscriber.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterTransactionEntityManagers = function (target) {
                    return this.transactionEntityManagers.filter(function (subscriber) {
                        return target instanceof Array ? target.indexOf(subscriber.target) !== -1 : subscriber.target === target;
                    });
                };
                MetadataArgsStorage.prototype.filterSingleTableChildren = function (target) {
                    return this.tables.filter(function (table) {
                        return table.target instanceof Function
                            && target instanceof Function
                            && MetadataUtils_1.MetadataUtils.isInherited(table.target, target)
                            && table.type === "single-table-child";
                    });
                };
                MetadataArgsStorage.prototype.findInheritanceType = function (target) {
                    return this.inheritances.find(function (inheritance) { return inheritance.target === target; });
                };
                MetadataArgsStorage.prototype.findDiscriminatorValue = function (target) {
                    return this.discriminatorValues.find(function (discriminatorValue) { return discriminatorValue.target === target; });
                };
                return MetadataArgsStorage;
            }());
            exports_132("MetadataArgsStorage", MetadataArgsStorage);
        }
    };
});
System.register("typeorm/metadata-builder/JunctionEntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata/IndexMetadata"], function (exports_133, context_133) {
    "use strict";
    var __moduleName = context_133 && context_133.id;
    var EntityMetadata_1, ColumnMetadata_1, ForeignKeyMetadata_1, IndexMetadata_1, JunctionEntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_1_1) {
                EntityMetadata_1 = EntityMetadata_1_1;
            },
            function (ColumnMetadata_1_1) {
                ColumnMetadata_1 = ColumnMetadata_1_1;
            },
            function (ForeignKeyMetadata_1_1) {
                ForeignKeyMetadata_1 = ForeignKeyMetadata_1_1;
            },
            function (IndexMetadata_1_1) {
                IndexMetadata_1 = IndexMetadata_1_1;
            }
        ],
        execute: function () {
            /**
             * Creates EntityMetadata for junction tables.
             * Junction tables are tables generated by many-to-many relations.
             */
            JunctionEntityMetadataBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function JunctionEntityMetadataBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds EntityMetadata for the junction of the given many-to-many relation.
                 */
                JunctionEntityMetadataBuilder.prototype.build = function (relation, joinTable) {
                    var _this = this;
                    var referencedColumns = this.collectReferencedColumns(relation, joinTable);
                    var inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);
                    var joinTableName = joinTable.name || this.connection.driver.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : "");
                    var entityMetadata = new EntityMetadata_1.EntityMetadata({
                        connection: this.connection,
                        args: {
                            target: "",
                            name: joinTableName,
                            type: "junction"
                        }
                    });
                    // create original side junction columns
                    var junctionColumns = referencedColumns.map(function (referencedColumn) {
                        var joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumnArgs) {
                            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) &&
                                !!joinColumnArgs.name;
                        }) : undefined;
                        var columnName = joinColumn && joinColumn.name ? joinColumn.name : _this.connection.driver.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);
                        return new ColumnMetadata_1.ColumnMetadata({
                            entityMetadata: entityMetadata,
                            referencedColumn: referencedColumn,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: columnName,
                                options: {
                                    name: columnName,
                                    length: referencedColumn.length,
                                    type: referencedColumn.type,
                                    nullable: false,
                                    primary: true,
                                }
                            }
                        });
                    });
                    // create inverse side junction columns
                    var inverseJunctionColumns = inverseReferencedColumns.map(function (inverseReferencedColumn) {
                        var joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumnArgs) {
                            return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) &&
                                !!joinColumnArgs.name;
                        }) : undefined;
                        var columnName = joinColumn && joinColumn.name ? joinColumn.name : _this.connection.driver.namingStrategy.joinTableColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);
                        return new ColumnMetadata_1.ColumnMetadata({
                            entityMetadata: entityMetadata,
                            referencedColumn: inverseReferencedColumn,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: columnName,
                                options: {
                                    length: inverseReferencedColumn.length,
                                    type: inverseReferencedColumn.type,
                                    name: columnName,
                                    nullable: false,
                                    primary: true,
                                }
                            }
                        });
                    });
                    // set junction table columns
                    entityMetadata.ownColumns = junctionColumns.concat(inverseJunctionColumns);
                    entityMetadata.ownColumns.forEach(function (column) { return column.relationMetadata = relation; });
                    // create junction table foreign keys
                    entityMetadata.foreignKeys = [
                        new ForeignKeyMetadata_1.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: relation.entityMetadata,
                            columns: junctionColumns,
                            referencedColumns: referencedColumns
                        }),
                        new ForeignKeyMetadata_1.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: relation.inverseEntityMetadata,
                            columns: inverseJunctionColumns,
                            referencedColumns: inverseReferencedColumns
                        }),
                    ];
                    // create junction table indices
                    entityMetadata.indices = [
                        new IndexMetadata_1.IndexMetadata({
                            entityMetadata: entityMetadata,
                            columns: junctionColumns,
                            args: {
                                target: "",
                                unique: false
                            }
                        }),
                        new IndexMetadata_1.IndexMetadata({
                            entityMetadata: entityMetadata,
                            columns: inverseJunctionColumns,
                            args: {
                                target: "",
                                unique: false
                            }
                        })
                    ];
                    // finally return entity metadata
                    return entityMetadata;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Collects referenced columns from the given join column args.
                 */
                JunctionEntityMetadataBuilder.prototype.collectReferencedColumns = function (relation, joinTable) {
                    var hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(function (joinColumn) { return !!joinColumn.referencedColumnName; }) : false;
                    if (!joinTable.joinColumns || (joinTable.joinColumns && !hasAnyReferencedColumnName)) {
                        return relation.entityMetadata.columns.filter(function (column) { return column.isPrimary; });
                    }
                    else {
                        return joinTable.joinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.entityMetadata.columns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.entityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                /**
                 * Collects inverse referenced columns from the given join column args.
                 */
                JunctionEntityMetadataBuilder.prototype.collectInverseReferencedColumns = function (relation, joinTable) {
                    var hasInverseJoinColumns = !!joinTable.inverseJoinColumns;
                    var hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(function (joinColumn) { return !!joinColumn.referencedColumnName; }) : false;
                    if (!hasInverseJoinColumns || (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)) {
                        return relation.inverseEntityMetadata.primaryColumns;
                    }
                    else {
                        return joinTable.inverseJoinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; });
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.inverseEntityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                return JunctionEntityMetadataBuilder;
            }());
            exports_133("JunctionEntityMetadataBuilder", JunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata", "typeorm/metadata/types/ColumnTypes"], function (exports_134, context_134) {
    "use strict";
    var __moduleName = context_134 && context_134.id;
    var EntityMetadata_2, ColumnMetadata_2, ForeignKeyMetadata_2, ColumnTypes_6, ClosureJunctionEntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_2_1) {
                EntityMetadata_2 = EntityMetadata_2_1;
            },
            function (ColumnMetadata_2_1) {
                ColumnMetadata_2 = ColumnMetadata_2_1;
            },
            function (ForeignKeyMetadata_2_1) {
                ForeignKeyMetadata_2 = ForeignKeyMetadata_2_1;
            },
            function (ColumnTypes_6_1) {
                ColumnTypes_6 = ColumnTypes_6_1;
            }
        ],
        execute: function () {
            /**
             * Creates EntityMetadata for junction tables of the closure entities.
             * Closure junction tables are tables generated by closure entities.
             */
            ClosureJunctionEntityMetadataBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function ClosureJunctionEntityMetadataBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds EntityMetadata for the closure junction of the given closure entity.
                 */
                ClosureJunctionEntityMetadataBuilder.prototype.build = function (parentClosureEntityMetadata) {
                    // create entity metadata itself
                    var entityMetadata = new EntityMetadata_2.EntityMetadata({
                        parentClosureEntityMetadata: parentClosureEntityMetadata,
                        connection: this.connection,
                        args: {
                            target: "",
                            name: parentClosureEntityMetadata.tableNameWithoutPrefix,
                            type: "closure-junction"
                        }
                    });
                    // create ancestor and descendant columns for new closure junction table
                    parentClosureEntityMetadata.primaryColumns.forEach(function (primaryColumn) {
                        entityMetadata.ownColumns.push(new ColumnMetadata_2.ColumnMetadata({
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "ancestor_" + primaryColumn.databaseName,
                                options: {
                                    length: primaryColumn.length,
                                    type: primaryColumn.type,
                                }
                            }
                        }));
                        entityMetadata.ownColumns.push(new ColumnMetadata_2.ColumnMetadata({
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "descendant_" + primaryColumn.databaseName,
                                options: {
                                    length: primaryColumn.length,
                                    type: primaryColumn.type,
                                }
                            }
                        }));
                    });
                    // if tree level column was defined by a closure entity then add it to the junction columns as well
                    if (parentClosureEntityMetadata.treeLevelColumn) {
                        entityMetadata.ownColumns.push(new ColumnMetadata_2.ColumnMetadata({
                            entityMetadata: entityMetadata,
                            args: {
                                target: "",
                                mode: "virtual",
                                propertyName: "level",
                                options: {
                                    type: ColumnTypes_6.ColumnTypes.INTEGER,
                                }
                            }
                        }));
                    }
                    // create junction table foreign keys
                    entityMetadata.foreignKeys = [
                        new ForeignKeyMetadata_2.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: parentClosureEntityMetadata,
                            columns: [entityMetadata.ownColumns[0]],
                            referencedColumns: parentClosureEntityMetadata.primaryColumns
                        }),
                        new ForeignKeyMetadata_2.ForeignKeyMetadata({
                            entityMetadata: entityMetadata,
                            referencedEntityMetadata: parentClosureEntityMetadata,
                            columns: [entityMetadata.ownColumns[1]],
                            referencedColumns: parentClosureEntityMetadata.primaryColumns
                        }),
                    ];
                    return entityMetadata;
                };
                return ClosureJunctionEntityMetadataBuilder;
            }());
            exports_134("ClosureJunctionEntityMetadataBuilder", ClosureJunctionEntityMetadataBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/RelationJoinColumnBuilder", ["typeorm/metadata/ColumnMetadata", "typeorm/metadata/ForeignKeyMetadata"], function (exports_135, context_135) {
    "use strict";
    var __moduleName = context_135 && context_135.id;
    var ColumnMetadata_3, ForeignKeyMetadata_3, RelationJoinColumnBuilder;
    return {
        setters: [
            function (ColumnMetadata_3_1) {
                ColumnMetadata_3 = ColumnMetadata_3_1;
            },
            function (ForeignKeyMetadata_3_1) {
                ForeignKeyMetadata_3 = ForeignKeyMetadata_3_1;
            }
        ],
        execute: function () {
            /**
             * Builds join column for the many-to-one and one-to-one owner relations.
             *
             * Cases it should cover:
             * 1. when join column is set with custom name and without referenced column name
             * we need automatically set referenced column name - primary ids by default
             * @JoinColumn({ name: "custom_name" })
             *
             * 2. when join column is set with only referenced column name
             * we need automatically set join column name - relation name + referenced column name
             * @JoinColumn({ referencedColumnName: "title" })
             *
             * 3. when join column is set without both referenced column name and join column name
             * we need to automatically set both of them
             * @JoinColumn()
             *
             * 4. when join column is not set at all (as in case of @ManyToOne relation)
             * we need to create join column for it with proper referenced column name and join column name
             *
             * 5. when multiple join columns set none of referencedColumnName and name can be optional
             * both options are required
             * @JoinColumn([
             *      { name: "category_title", referencedColumnName: "type" },
             *      { name: "category_title", referencedColumnName: "name" },
             * ])
             *
             * Since for many-to-one relations having JoinColumn decorator is not required,
             * we need to go thought each many-to-one relation without join column decorator set
             * and create join column metadata args for them.
             */
            RelationJoinColumnBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function RelationJoinColumnBuilder(connection) {
                    this.connection = connection;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds a foreign key of the many-to-one or one-to-one owner relations.
                 */
                RelationJoinColumnBuilder.prototype.build = function (joinColumns, relation) {
                    var referencedColumns = this.collectReferencedColumns(joinColumns, relation);
                    if (!referencedColumns.length)
                        return undefined; // this case is possible only for one-to-one non owning side
                    var columns = this.collectColumns(joinColumns, relation, referencedColumns);
                    return new ForeignKeyMetadata_3.ForeignKeyMetadata({
                        entityMetadata: relation.entityMetadata,
                        referencedEntityMetadata: relation.inverseEntityMetadata,
                        namingStrategy: this.connection.driver.namingStrategy,
                        columns: columns,
                        referencedColumns: referencedColumns,
                        onDelete: relation.onDelete,
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Collects referenced columns from the given join column args.
                 */
                RelationJoinColumnBuilder.prototype.collectReferencedColumns = function (joinColumns, relation) {
                    var hasAnyReferencedColumnName = joinColumns.find(function (joinColumnArgs) { return !!joinColumnArgs.referencedColumnName; });
                    var manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;
                    var hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;
                    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {
                        return relation.inverseEntityMetadata.primaryColumns;
                    }
                    else {
                        return joinColumns.map(function (joinColumn) {
                            var referencedColumn = relation.inverseEntityMetadata.ownColumns.find(function (column) { return column.propertyName === joinColumn.referencedColumnName; }); // todo: can we also search in relations?
                            if (!referencedColumn)
                                throw new Error("Referenced column " + joinColumn.referencedColumnName + " was not found in entity " + relation.inverseEntityMetadata.name);
                            return referencedColumn;
                        });
                    }
                };
                /**
                 * Collects columns from the given join column args.
                 */
                RelationJoinColumnBuilder.prototype.collectColumns = function (joinColumns, relation, referencedColumns) {
                    var _this = this;
                    return referencedColumns.map(function (referencedColumn) {
                        // in the case if relation has join column with only name set we need this check
                        var joinColumnMetadataArg = joinColumns.find(function (joinColumn) {
                            return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) &&
                                !!joinColumn.name;
                        });
                        var joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : _this.connection.driver.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);
                        var relationalColumn = relation.entityMetadata.ownColumns.find(function (column) { return column.databaseName === joinColumnName; });
                        if (!relationalColumn) {
                            relationalColumn = new ColumnMetadata_3.ColumnMetadata({
                                entityMetadata: relation.entityMetadata,
                                args: {
                                    target: "",
                                    mode: "virtual",
                                    propertyName: relation.propertyName,
                                    options: {
                                        name: joinColumnName,
                                        type: referencedColumn.type,
                                        primary: relation.isPrimary,
                                        nullable: relation.isNullable,
                                    }
                                }
                            });
                            relation.entityMetadata.registerColumn(relationalColumn);
                        }
                        relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column
                        relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type
                        relationalColumn.relationMetadata = relation;
                        relationalColumn.build(_this.connection.driver.namingStrategy);
                        return relationalColumn;
                    });
                };
                return RelationJoinColumnBuilder;
            }());
            exports_135("RelationJoinColumnBuilder", RelationJoinColumnBuilder);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataBuilder", ["typeorm/metadata/EntityMetadata", "typeorm/metadata/ColumnMetadata", "typeorm/metadata/IndexMetadata", "typeorm/metadata/RelationMetadata", "typeorm/metadata/EmbeddedMetadata", "typeorm/metadata/RelationIdMetadata", "typeorm/metadata/RelationCountMetadata", "typeorm/metadata-builder/MetadataUtils", "typeorm/metadata-builder/JunctionEntityMetadataBuilder", "typeorm/metadata-builder/ClosureJunctionEntityMetadataBuilder", "typeorm/metadata-builder/RelationJoinColumnBuilder", "typeorm/metadata/EntityListenerMetadata"], function (exports_136, context_136) {
    "use strict";
    var __moduleName = context_136 && context_136.id;
    var EntityMetadata_3, ColumnMetadata_4, IndexMetadata_2, RelationMetadata_2, EmbeddedMetadata_1, RelationIdMetadata_1, RelationCountMetadata_1, MetadataUtils_2, JunctionEntityMetadataBuilder_1, ClosureJunctionEntityMetadataBuilder_1, RelationJoinColumnBuilder_1, EntityListenerMetadata_1, EntityMetadataBuilder;
    return {
        setters: [
            function (EntityMetadata_3_1) {
                EntityMetadata_3 = EntityMetadata_3_1;
            },
            function (ColumnMetadata_4_1) {
                ColumnMetadata_4 = ColumnMetadata_4_1;
            },
            function (IndexMetadata_2_1) {
                IndexMetadata_2 = IndexMetadata_2_1;
            },
            function (RelationMetadata_2_1) {
                RelationMetadata_2 = RelationMetadata_2_1;
            },
            function (EmbeddedMetadata_1_1) {
                EmbeddedMetadata_1 = EmbeddedMetadata_1_1;
            },
            function (RelationIdMetadata_1_1) {
                RelationIdMetadata_1 = RelationIdMetadata_1_1;
            },
            function (RelationCountMetadata_1_1) {
                RelationCountMetadata_1 = RelationCountMetadata_1_1;
            },
            function (MetadataUtils_2_1) {
                MetadataUtils_2 = MetadataUtils_2_1;
            },
            function (JunctionEntityMetadataBuilder_1_1) {
                JunctionEntityMetadataBuilder_1 = JunctionEntityMetadataBuilder_1_1;
            },
            function (ClosureJunctionEntityMetadataBuilder_1_1) {
                ClosureJunctionEntityMetadataBuilder_1 = ClosureJunctionEntityMetadataBuilder_1_1;
            },
            function (RelationJoinColumnBuilder_1_1) {
                RelationJoinColumnBuilder_1 = RelationJoinColumnBuilder_1_1;
            },
            function (EntityListenerMetadata_1_1) {
                EntityListenerMetadata_1 = EntityListenerMetadata_1_1;
            }
        ],
        execute: function () {
            /**
             * Builds EntityMetadata objects and all its sub-metadatas.
             */
            EntityMetadataBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function EntityMetadataBuilder(connection, metadataArgsStorage) {
                    this.connection = connection;
                    this.metadataArgsStorage = metadataArgsStorage;
                    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder_1.JunctionEntityMetadataBuilder(connection);
                    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder_1.ClosureJunctionEntityMetadataBuilder(connection);
                    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder_1.RelationJoinColumnBuilder(connection);
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Builds a complete entity metadatas for the given entity classes.
                 */
                EntityMetadataBuilder.prototype.build = function (entityClasses) {
                    var _this = this;
                    // if entity classes to filter entities by are given then do filtering, otherwise use all
                    var allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;
                    // filter out table metadata args for those we really create entity metadatas and tables in the db
                    var realTables = allTables.filter(function (table) { return table.type === "regular" || table.type === "closure" || table.type === "class-table-child" || table.type === "single-table-child"; });
                    // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)
                    var entityMetadatas = realTables.map(function (tableArgs) { return _this.createEntityMetadata(tableArgs); });
                    // calculate entity metadata computed properties and all its sub-metadatas
                    entityMetadatas.forEach(function (entityMetadata) { return _this.computeEntityMetadata(entityMetadata); });
                    // calculate entity metadata's inverse properties
                    entityMetadatas.forEach(function (entityMetadata) { return _this.computeInverseProperties(entityMetadata, entityMetadatas); });
                    // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations
                    entityMetadatas
                        .filter(function (entityMetadata) { return entityMetadata.tableType !== "single-table-child"; })
                        .forEach(function (entityMetadata) {
                        // create entity's relations join columns (for many-to-one and one-to-one owner)
                        entityMetadata.relations.filter(function (relation) { return relation.isOneToOne || relation.isManyToOne; }).forEach(function (relation) {
                            var joinColumns = _this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);
                            var foreignKey = _this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args
                            if (foreignKey) {
                                relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column
                                entityMetadata.foreignKeys.push(foreignKey);
                            }
                        });
                        // create junction entity metadatas for entity many-to-many relations
                        entityMetadata.relations.filter(function (relation) { return relation.isManyToMany; }).forEach(function (relation) {
                            var joinTable = _this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);
                            if (!joinTable)
                                return; // no join table set - no need to do anything (it means this is many-to-many inverse side)
                            // here we create a junction entity metadata for a new junction table of many-to-many relation
                            var junctionEntityMetadata = _this.junctionEntityMetadataBuilder.build(relation, joinTable);
                            relation.registerForeignKeys.apply(relation, junctionEntityMetadata.foreignKeys);
                            relation.registerJunctionEntityMetadata(junctionEntityMetadata);
                            // compute new entity metadata properties and push it to entity metadatas pool
                            _this.computeEntityMetadata(junctionEntityMetadata);
                            _this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);
                            entityMetadatas.push(junctionEntityMetadata);
                        });
                        // update entity metadata depend properties
                        entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(function (relation) { return relation.isWithJoinColumn; });
                        entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(function (relation) { return !relation.isNullable || relation.isPrimary; });
                    });
                    // generate closure junction tables for all closure tables
                    entityMetadatas
                        .filter(function (metadata) { return metadata.isClosure; })
                        .forEach(function (entityMetadata) {
                        var closureJunctionEntityMetadata = _this.closureJunctionEntityMetadataBuilder.build(entityMetadata);
                        entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;
                        _this.computeEntityMetadata(closureJunctionEntityMetadata);
                        _this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);
                        entityMetadatas.push(closureJunctionEntityMetadata);
                    });
                    // after all metadatas created we set parent entity metadata for class-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return metadata.tableType === "single-table-child"; })
                        .forEach(function (entityMetadata) {
                        var inheritanceTree = entityMetadata.target instanceof Function
                            ? MetadataUtils_2.MetadataUtils.getInheritanceTree(entityMetadata.target)
                            : [entityMetadata.target];
                        var parentMetadata = entityMetadatas.find(function (metadata) {
                            return inheritanceTree.find(function (inheritance) { return inheritance === metadata.target; }) && metadata.inheritanceType === "single-table";
                        });
                        if (parentMetadata) {
                            entityMetadata.parentEntityMetadata = parentMetadata;
                            entityMetadata.tableName = parentMetadata.tableName;
                        }
                    });
                    // after all metadatas created we set child entity metadatas for class-table inheritance
                    entityMetadatas.forEach(function (metadata) {
                        metadata.childEntityMetadatas = entityMetadatas.filter(function (childMetadata) {
                            return metadata.target instanceof Function
                                && childMetadata.target instanceof Function
                                && MetadataUtils_2.MetadataUtils.isInherited(childMetadata.target, metadata.target);
                        });
                    });
                    // generate keys for tables with single-table inheritance
                    entityMetadatas
                        .filter(function (metadata) { return metadata.inheritanceType === "single-table" && metadata.discriminatorColumn; })
                        .forEach(function (entityMetadata) { return _this.createKeysForTableInheritance(entityMetadata); });
                    // build all indices (need to do it after relations and their join columns are built)
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.indices.forEach(function (index) { return index.build(_this.connection.driver.namingStrategy); });
                    });
                    // add lazy initializer for entity relations
                    entityMetadatas
                        .filter(function (metadata) { return metadata.target instanceof Function; })
                        .forEach(function (entityMetadata) {
                        entityMetadata.relations
                            .filter(function (relation) { return relation.isLazy; })
                            .forEach(function (relation) {
                            _this.connection.driver.lazyRelationsWrapper.wrap(entityMetadata.target.prototype, relation);
                        });
                    });
                    return entityMetadatas;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates entity metadata from the given table args.
                 * Creates column, relation, etc. metadatas for everything this entity metadata owns.
                 */
                EntityMetadataBuilder.prototype.createEntityMetadata = function (tableArgs) {
                    // we take all "inheritance tree" from a target entity to collect all stored metadata args
                    // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit
                    // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes
                    var inheritanceTree = tableArgs.target instanceof Function
                        ? MetadataUtils_2.MetadataUtils.getInheritanceTree(tableArgs.target)
                        : [tableArgs.target]; // todo: implement later here inheritance for string-targets
                    // if single table inheritance used, we need to copy all children columns in to parent table
                    var singleTableChildrenTargets = this.metadataArgsStorage
                        .filterSingleTableChildren(tableArgs.target)
                        .map(function (args) { return args.target; })
                        .filter(function (target) { return target instanceof Function; });
                    inheritanceTree.push.apply(inheritanceTree, singleTableChildrenTargets);
                    var entityMetadata = new EntityMetadata_3.EntityMetadata({ connection: this.connection, args: tableArgs });
                    var inheritanceType = this.metadataArgsStorage.findInheritanceType(tableArgs.target);
                    entityMetadata.inheritanceType = inheritanceType ? inheritanceType.type : undefined;
                    var discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(tableArgs.target);
                    entityMetadata.discriminatorValue = discriminatorValue ? discriminatorValue.value : tableArgs.target.name; // todo: pass this to naming strategy to generate a name
                    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(inheritanceTree));
                    entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(inheritanceTree).map(function (args) {
                        var column = new ColumnMetadata_4.ColumnMetadata({ entityMetadata: entityMetadata, args: args });
                        // if single table inheritance used, we need to mark all inherit table columns as nullable
                        if (singleTableChildrenTargets.indexOf(args.target) !== -1)
                            column.isNullable = true;
                        return column;
                    });
                    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(inheritanceTree).map(function (args) {
                        return new RelationMetadata_2.RelationMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(inheritanceTree).map(function (args) {
                        return new RelationIdMetadata_1.RelationIdMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(inheritanceTree).map(function (args) {
                        return new RelationCountMetadata_1.RelationCountMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.indices = this.metadataArgsStorage.filterIndices(inheritanceTree).map(function (args) {
                        return new IndexMetadata_2.IndexMetadata({ entityMetadata: entityMetadata, args: args });
                    });
                    entityMetadata.listeners = this.metadataArgsStorage.filterListeners(inheritanceTree).map(function (args) {
                        return new EntityListenerMetadata_1.EntityListenerMetadata(args);
                    });
                    return entityMetadata;
                };
                /**
                 * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,
                 * and does the same for all its sub-embeddeds (goes recursively).
                 */
                EntityMetadataBuilder.prototype.createEmbeddedsRecursively = function (entityMetadata, embeddedArgs) {
                    var _this = this;
                    return embeddedArgs.map(function (embeddedArgs) {
                        var embeddedMetadata = new EmbeddedMetadata_1.EmbeddedMetadata({ entityMetadata: entityMetadata, args: embeddedArgs });
                        embeddedMetadata.columns = _this.metadataArgsStorage.filterColumns(embeddedMetadata.type).map(function (args) {
                            return new ColumnMetadata_4.ColumnMetadata({ entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.relations = _this.metadataArgsStorage.filterRelations(embeddedMetadata.type).map(function (args) {
                            return new RelationMetadata_2.RelationMetadata({ entityMetadata: entityMetadata, embeddedMetadata: embeddedMetadata, args: args });
                        });
                        embeddedMetadata.embeddeds = _this.createEmbeddedsRecursively(entityMetadata, _this.metadataArgsStorage.filterEmbeddeds(embeddedMetadata.type));
                        embeddedMetadata.embeddeds.forEach(function (subEmbedded) { return subEmbedded.parentEmbeddedMetadata = embeddedMetadata; });
                        return embeddedMetadata;
                    });
                };
                /**
                 * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).
                 */
                EntityMetadataBuilder.prototype.computeEntityMetadata = function (entityMetadata) {
                    var _this = this;
                    entityMetadata.embeddeds.forEach(function (embedded) { return embedded.build(_this.connection.driver.namingStrategy); });
                    entityMetadata.embeddeds.forEach(function (embedded) {
                        embedded.columnsFromTree.forEach(function (column) { return column.build(_this.connection.driver.namingStrategy); });
                        embedded.relationsFromTree.forEach(function (relation) { return relation.build(); });
                    });
                    entityMetadata.ownColumns.forEach(function (column) { return column.build(_this.connection.driver.namingStrategy); });
                    entityMetadata.ownRelations.forEach(function (relation) { return relation.build(); });
                    entityMetadata.relations = entityMetadata.embeddeds.reduce(function (relations, embedded) { return relations.concat(embedded.relationsFromTree); }, entityMetadata.ownRelations);
                    entityMetadata.oneToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToOne; });
                    entityMetadata.oneToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToMany; });
                    entityMetadata.manyToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToOne; });
                    entityMetadata.manyToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToMany; });
                    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(function (relation) { return relation.isOneToOneOwner; });
                    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(function (relation) { return relation.isManyToManyOwner; });
                    entityMetadata.treeParentRelation = entityMetadata.relations.find(function (relation) { return relation.isTreeParent; });
                    entityMetadata.treeChildrenRelation = entityMetadata.relations.find(function (relation) { return relation.isTreeChildren; });
                    entityMetadata.columns = entityMetadata.embeddeds.reduce(function (columns, embedded) { return columns.concat(embedded.columnsFromTree); }, entityMetadata.ownColumns);
                    entityMetadata.primaryColumns = entityMetadata.columns.filter(function (column) { return column.isPrimary; });
                    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;
                    entityMetadata.generatedColumn = entityMetadata.columns.find(function (column) { return column.isGenerated; });
                    entityMetadata.createDateColumn = entityMetadata.columns.find(function (column) { return column.isCreateDate; });
                    entityMetadata.updateDateColumn = entityMetadata.columns.find(function (column) { return column.isUpdateDate; });
                    entityMetadata.versionColumn = entityMetadata.columns.find(function (column) { return column.isVersion; });
                    entityMetadata.discriminatorColumn = entityMetadata.columns.find(function (column) { return column.isDiscriminator; });
                    entityMetadata.treeLevelColumn = entityMetadata.columns.find(function (column) { return column.isTreeLevel; });
                    entityMetadata.parentIdColumns = entityMetadata.columns.filter(function (column) { return column.isParentId; });
                    entityMetadata.objectIdColumn = entityMetadata.columns.find(function (column) { return column.isObjectId; });
                    entityMetadata.foreignKeys.forEach(function (foreignKey) { return foreignKey.build(_this.connection.driver.namingStrategy); });
                    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();
                    entityMetadata.relationIds.forEach(function (relationId) { return relationId.build(); });
                    entityMetadata.relationCounts.forEach(function (relationCount) { return relationCount.build(); });
                    entityMetadata.embeddeds.forEach(function (embedded) {
                        embedded.relationIdsFromTree.forEach(function (relationId) { return relationId.build(); });
                        embedded.relationCountsFromTree.forEach(function (relationCount) { return relationCount.build(); });
                    });
                };
                /**
                 * Computes entity metadata's relations inverse side properties.
                 */
                EntityMetadataBuilder.prototype.computeInverseProperties = function (entityMetadata, entityMetadatas) {
                    entityMetadata.relations.forEach(function (relation) {
                        // compute inverse side (related) entity metadatas for all relation metadatas
                        var inverseEntityMetadata = entityMetadatas.find(function (m) { return m.target === relation.type || (typeof relation.type === "string" && m.targetName === relation.type); });
                        if (!inverseEntityMetadata)
                            throw new Error("Entity metadata for " + entityMetadata.name + "#" + relation.propertyPath + " was not found. Check if you specified a correct entity object, check its really entity and its connected in the connection options.");
                        relation.inverseEntityMetadata = inverseEntityMetadata;
                        relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();
                        // and compute inverse relation and mark if it has such
                        relation.inverseRelation = inverseEntityMetadata.relations.find(function (foundRelation) { return foundRelation.propertyPath === relation.inverseSidePropertyPath; });
                    });
                };
                /**
                 * Creates indices for the table of single table inheritance.
                 */
                EntityMetadataBuilder.prototype.createKeysForTableInheritance = function (entityMetadata) {
                    entityMetadata.indices.push(new IndexMetadata_2.IndexMetadata({
                        entityMetadata: entityMetadata,
                        columns: [entityMetadata.discriminatorColumn],
                        args: {
                            target: entityMetadata.target,
                            unique: false
                        }
                    }), new IndexMetadata_2.IndexMetadata({
                        entityMetadata: entityMetadata,
                        columns: entityMetadata.primaryColumns.concat([entityMetadata.discriminatorColumn]),
                        args: {
                            target: entityMetadata.target,
                            unique: false
                        }
                    }));
                };
                return EntityMetadataBuilder;
            }());
            exports_136("EntityMetadataBuilder", EntityMetadataBuilder);
            // generate virtual column with foreign key for class-table inheritance
            /*entityMetadatas.forEach(entityMetadata => {
             if (!entityMetadata.parentEntityMetadata)
             return;
            
             const parentPrimaryColumns = entityMetadata.parentEntityMetadata.primaryColumns;
             const parentIdColumns = parentPrimaryColumns.map(primaryColumn => {
             const columnName = this.namingStrategy.classTableInheritanceParentColumnName(entityMetadata.parentEntityMetadata.tableName, primaryColumn.propertyName);
             const column = new ColumnMetadataBuilder(entityMetadata);
             column.type = primaryColumn.type;
             column.propertyName = primaryColumn.propertyName; // todo: check why needed
             column.givenName = columnName;
             column.mode = "parentId";
             column.isUnique = true;
             column.isNullable = false;
             // column.entityTarget = entityMetadata.target;
             return column;
             });
            
             // add foreign key
             const foreignKey = new ForeignKeyMetadataBuilder(
             entityMetadata,
             parentIdColumns,
             entityMetadata.parentEntityMetadata,
             parentPrimaryColumns,
             "CASCADE"
             );
             entityMetadata.ownColumns.push(...parentIdColumns);
             entityMetadata.foreignKeys.push(foreignKey);
             });*/
            /*protected createEntityMetadata(metadata: EntityMetadata, options: {
             userSpecifiedTableName?: string,
             closureOwnerTableName?: string,
             }) {
            
             const tableNameUserSpecified = options.userSpecifiedTableName;
             const isClosureJunction = metadata.tableType === "closure-junction";
             const targetName = metadata.target instanceof Function ? (metadata.target as any).name : metadata.target;
             const tableNameWithoutPrefix = isClosureJunction
             ? this.namingStrategy.closureJunctionTableName(options.closureOwnerTableName!)
             : this.namingStrategy.tableName(targetName, options.userSpecifiedTableName);
            
             const tableName = this.namingStrategy.prefixTableName(this.driver.options.tablesPrefix, tableNameWithoutPrefix);
            
             // for virtual tables (like junction table) target is equal to undefined at this moment
             // we change this by setting virtual's table name to a target name
             // todo: add validation so targets with same schema names won't conflicts with virtual table names
             metadata.target = metadata.target ? metadata.target : tableName;
             metadata.targetName = targetName;
             metadata.givenTableName = tableNameUserSpecified;
             metadata.tableNameWithoutPrefix = tableNameWithoutPrefix;
             metadata.tableName = tableName;
             metadata.name = targetName ? targetName : tableName;
             // metadata.namingStrategy = this.namingStrategy;
             }*/
            /*protected createEntityMetadata(tableArgs: any, argsForTable: any, ): EntityMetadata {
             const metadata = new EntityMetadata({
             junction: false,
             target: tableArgs.target,
             tablesPrefix: this.driver.options.tablesPrefix,
             namingStrategy: this.namingStrategy,
             tableName: argsForTable.name,
             tableType: argsForTable.type,
             orderBy: argsForTable.orderBy,
             engine: argsForTable.engine,
             skipSchemaSync: argsForTable.skipSchemaSync,
             columnMetadatas: columns,
             relationMetadatas: relations,
             relationIdMetadatas: relationIds,
             relationCountMetadatas: relationCounts,
             indexMetadatas: indices,
             embeddedMetadatas: embeddeds,
             inheritanceType: mergedArgs.inheritance ? mergedArgs.inheritance.type : undefined,
             discriminatorValue: discriminatorValueArgs ? discriminatorValueArgs.value : (tableArgs.target as any).name // todo: pass this to naming strategy to generate a name
             }, this.lazyRelationsWrapper);
             return metadata;
             }*/
            // const tables = [mergedArgs.table].concat(mergedArgs.children);
            // tables.forEach(tableArgs => {
            // find embeddable tables for embeddeds registered in this table and create EmbeddedMetadatas from them
            // const findEmbeddedsRecursively = (embeddedArgs: EmbeddedMetadataArgs[]) => {
            //     const embeddeds: EmbeddedMetadata[] = [];
            //     embeddedArgs.forEach(embedded => {
            //         const embeddableTable = embeddableMergedArgs.find(embeddedMergedArgs => embeddedMergedArgs.table.target === embedded.type());
            //         if (embeddableTable) {
            //             const columns = embeddableTable.columns.toArray().map(args => new ColumnMetadata(args));
            //             const relations = embeddableTable.relations.toArray().map(args => new RelationMetadata(args));
            //             const subEmbeddeds = findEmbeddedsRecursively(embeddableTable.embeddeds.toArray());
            //             embeddeds.push(new EmbeddedMetadata(columns, relations, subEmbeddeds, embedded));
            //         }
            //     });
            //     return embeddeds;
            // };
            // const embeddeds = findEmbeddedsRecursively(mergedArgs.embeddeds.toArray());
            // create metadatas from args
            // const argsForTable = mergedArgs.inheritance && mergedArgs.inheritance.type === "single-table" ? mergedArgs.table : tableArgs;
            // const table = new TableMetadata(argsForTable);
            // const columns = mergedArgs.columns.toArray().map(args => {
            //
            //     // if column's target is a child table then this column should have all nullable columns
            //     if (mergedArgs.inheritance &&
            //         mergedArgs.inheritance.type === "single-table" &&
            //         args.target !== mergedArgs.table.target && !!mergedArgs.children.find(childTable => childTable.target === args.target)) {
            //         args.options.nullable = true;
            //     }
            //     return new ColumnMetadata(args);
            // });
            // const discriminatorValueArgs = mergedArgs.discriminatorValues.find(discriminatorValueArgs => {
            //     return discriminatorValueArgs.target === tableArgs.target;
            // });
            // after all metadatas created we set parent entity metadata for class-table inheritance
            // entityMetadatas.forEach(entityMetadata => {
            //     const mergedArgs = realTables.find(args => args.target === entityMetadata.target);
            //     if (mergedArgs && mergedArgs.parent) {
            //         const parentEntityMetadata = entityMetadatas.find(entityMetadata => entityMetadata.target === (mergedArgs!.parent! as any).target); // todo: weird compiler error here, thats why type casing is used
            //         if (parentEntityMetadata)
            //             entityMetadata.parentEntityMetadata = parentEntityMetadata;
            //     }
            // }); 
        }
    };
});
System.register("typeorm/util/RandomGenerator", [], function (exports_137, context_137) {
    "use strict";
    var __moduleName = context_137 && context_137.id;
    var RandomGenerator;
    return {
        setters: [],
        execute: function () {
            RandomGenerator = (function () {
                function RandomGenerator() {
                }
                /**
                 *  discuss at: http://locutus.io/php/sha1/
                 * original by: Webtoolkit.info (http://www.webtoolkit.info/)
                 * improved by: Michael White (http://getsprink.com)
                 * improved by: Kevin van Zonneveld (http://kvz.io)
                 *    input by: Brett Zamir (http://brett-zamir.me)
                 *      note 1: Keep in mind that in accordance with PHP, the whole string is buffered and then
                 *      note 1: hashed. If available, we'd recommend using Node's native crypto modules directly
                 *      note 1: in a steaming fashion for faster and more efficient hashing
                 *   example 1: sha1('Kevin van Zonneveld')
                 *   returns 1: '54916d2e62f65b3afa6e192e6a601cdbe5cb5897'
                 */
                RandomGenerator.sha1 = function (str) {
                    var _rotLeft = function (n, s) {
                        var t4 = (n << s) | (n >>> (32 - s));
                        return t4;
                    };
                    var _cvtHex = function (val) {
                        var str = "";
                        var i;
                        var v;
                        for (i = 7; i >= 0; i--) {
                            v = (val >>> (i * 4)) & 0x0f;
                            str += v.toString(16);
                        }
                        return str;
                    };
                    var blockstart;
                    var i, j;
                    var W = new Array(80);
                    var H0 = 0x67452301;
                    var H1 = 0xEFCDAB89;
                    var H2 = 0x98BADCFE;
                    var H3 = 0x10325476;
                    var H4 = 0xC3D2E1F0;
                    var A, B, C, D, E;
                    var temp;
                    // utf8_encode
                    str = (encodeURIComponent(str));
                    var strLen = str.length;
                    var wordArray = [];
                    for (i = 0; i < strLen - 3; i += 4) {
                        j = str.charCodeAt(i) << 24 |
                            str.charCodeAt(i + 1) << 16 |
                            str.charCodeAt(i + 2) << 8 |
                            str.charCodeAt(i + 3);
                        wordArray.push(j);
                    }
                    switch (strLen % 4) {
                        case 0:
                            i = 0x080000000;
                            break;
                        case 1:
                            i = str.charCodeAt(strLen - 1) << 24 | 0x0800000;
                            break;
                        case 2:
                            i = str.charCodeAt(strLen - 2) << 24 | str.charCodeAt(strLen - 1) << 16 | 0x08000;
                            break;
                        case 3:
                            i = str.charCodeAt(strLen - 3) << 24 |
                                str.charCodeAt(strLen - 2) << 16 |
                                str.charCodeAt(strLen - 1) <<
                                    8 | 0x80;
                            break;
                    }
                    wordArray.push(i);
                    while ((wordArray.length % 16) !== 14) {
                        wordArray.push(0);
                    }
                    wordArray.push(strLen >>> 29);
                    wordArray.push((strLen << 3) & 0x0ffffffff);
                    for (blockstart = 0; blockstart < wordArray.length; blockstart += 16) {
                        for (i = 0; i < 16; i++) {
                            W[i] = wordArray[blockstart + i];
                        }
                        for (i = 16; i <= 79; i++) {
                            W[i] = _rotLeft(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
                        }
                        A = H0;
                        B = H1;
                        C = H2;
                        D = H3;
                        E = H4;
                        for (i = 0; i <= 19; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (~B & D)) + E + W[i] + 0x5A827999) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 20; i <= 39; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0x6ED9EBA1) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 40; i <= 59; i++) {
                            temp = (_rotLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + 0x8F1BBCDC) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        for (i = 60; i <= 79; i++) {
                            temp = (_rotLeft(A, 5) + (B ^ C ^ D) + E + W[i] + 0xCA62C1D6) & 0x0ffffffff;
                            E = D;
                            D = C;
                            C = _rotLeft(B, 30);
                            B = A;
                            A = temp;
                        }
                        H0 = (H0 + A) & 0x0ffffffff;
                        H1 = (H1 + B) & 0x0ffffffff;
                        H2 = (H2 + C) & 0x0ffffffff;
                        H3 = (H3 + D) & 0x0ffffffff;
                        H4 = (H4 + E) & 0x0ffffffff;
                    }
                    temp = _cvtHex(H0) + _cvtHex(H1) + _cvtHex(H2) + _cvtHex(H3) + _cvtHex(H4);
                    return temp.toLowerCase();
                };
                return RandomGenerator;
            }());
            exports_137("RandomGenerator", RandomGenerator);
        }
    };
});
System.register("typeorm/util/StringUtils", [], function (exports_138, context_138) {
    "use strict";
    var __moduleName = context_138 && context_138.id;
    /**
     * Converts string into camelCase.
     *
     * @see http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
     */
    function camelCase(str) {
        return str.replace(/^([A-Z])|[\s-_](\w)/g, function (match, p1, p2, offset) {
            if (p2)
                return p2.toUpperCase();
            return p1.toLowerCase();
        });
    }
    exports_138("camelCase", camelCase);
    /**
     * Converts string into snake-case.
     *
     * @see http://stackoverflow.com/questions/30521224/javascript-convert-pascalcase-to-underscore-case
     */
    function snakeCase(str) {
        return str.replace(/(?:^|\.?)([A-Z])/g, function (x, y) { return "_" + y.toLowerCase(); }).replace(/^_/, "");
    }
    exports_138("snakeCase", snakeCase);
    /**
     * Converts string into title-case.
     *
     * @see http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
     */
    function titleCase(str) {
        return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); });
    }
    exports_138("titleCase", titleCase);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/naming-strategy/DefaultNamingStrategy", ["typeorm/util/RandomGenerator", "typeorm/util/StringUtils"], function (exports_139, context_139) {
    "use strict";
    var __moduleName = context_139 && context_139.id;
    var RandomGenerator_1, StringUtils_1, DefaultNamingStrategy;
    return {
        setters: [
            function (RandomGenerator_1_1) {
                RandomGenerator_1 = RandomGenerator_1_1;
            },
            function (StringUtils_1_1) {
                StringUtils_1 = StringUtils_1_1;
            }
        ],
        execute: function () {
            /**
             * Naming strategy that is used by default.
             */
            DefaultNamingStrategy = (function () {
                function DefaultNamingStrategy() {
                }
                /**
                 * Normalizes table name.
                 *
                 * @param targetName Name of the target entity that can be used to generate a table name.
                 * @param userSpecifiedName For example if user specified a table name in a decorator, e.g. @Entity("name")
                 */
                DefaultNamingStrategy.prototype.tableName = function (targetName, userSpecifiedName) {
                    return userSpecifiedName ? userSpecifiedName : StringUtils_1.snakeCase(targetName);
                };
                /**
                 * Creates a table name for a junction table of a closure table.
                 *
                 * @param originalClosureTableName Name of the closure table which owns this junction table.
                 */
                DefaultNamingStrategy.prototype.closureJunctionTableName = function (originalClosureTableName) {
                    return originalClosureTableName + "_closure";
                };
                DefaultNamingStrategy.prototype.columnName = function (propertyName, customName, embeddedPrefixes) {
                    if (embeddedPrefixes.length)
                        return StringUtils_1.camelCase(embeddedPrefixes.join("_")) + (customName ? StringUtils_1.titleCase(customName) : StringUtils_1.titleCase(propertyName));
                    return customName ? customName : propertyName;
                };
                DefaultNamingStrategy.prototype.relationName = function (propertyName) {
                    return propertyName;
                };
                DefaultNamingStrategy.prototype.indexName = function (customName, tableName, columns) {
                    if (customName)
                        return customName;
                    var key = "ind_" + tableName + "_" + columns.join("_");
                    return "ind_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27);
                };
                DefaultNamingStrategy.prototype.joinColumnName = function (relationName, referencedColumnName) {
                    return StringUtils_1.camelCase(relationName + "_" + referencedColumnName);
                };
                DefaultNamingStrategy.prototype.joinTableName = function (firstTableName, secondTableName, firstPropertyName, secondPropertyName) {
                    return StringUtils_1.snakeCase(firstTableName + "_" + firstPropertyName.replace(/\./gi, "_") + "_" + secondTableName);
                };
                DefaultNamingStrategy.prototype.joinTableColumnDuplicationPrefix = function (columnName, index) {
                    return columnName + "_" + index;
                };
                DefaultNamingStrategy.prototype.joinTableColumnName = function (tableName, propertyName, columnName) {
                    return StringUtils_1.camelCase(tableName + "_" + (columnName ? columnName : propertyName));
                };
                DefaultNamingStrategy.prototype.foreignKeyName = function (tableName, columnNames, referencedTableName, referencedColumnNames) {
                    var key = tableName + "_" + columnNames.join("_") + "_" + referencedTableName + "_" + referencedColumnNames.join("_");
                    return "fk_" + RandomGenerator_1.RandomGenerator.sha1(key).substr(0, 27); // todo: use crypto instead?
                };
                DefaultNamingStrategy.prototype.classTableInheritanceParentColumnName = function (parentTableName, parentTableIdPropertyName) {
                    return StringUtils_1.camelCase(parentTableName + "_" + parentTableIdPropertyName);
                };
                /**
                 * Adds globally set prefix to the table name.
                 * This method is executed no matter if prefix was set or not.
                 * Table name is either user's given table name, either name generated from entity target.
                 * Note that table name comes here already normalized by #tableName method.
                 */
                DefaultNamingStrategy.prototype.prefixTableName = function (prefix, tableName) {
                    return prefix + tableName;
                };
                return DefaultNamingStrategy;
            }());
            exports_139("DefaultNamingStrategy", DefaultNamingStrategy);
        }
    };
});
System.register("typeorm/connection/error/CannotImportAlreadyConnectedError", [], function (exports_140, context_140) {
    "use strict";
    var __moduleName = context_140 && context_140.id;
    var CannotImportAlreadyConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to import entities / entity schemas / subscribers / naming strategies after connection
             * is established.
             */
            CannotImportAlreadyConnectedError = (function (_super) {
                __extends(CannotImportAlreadyConnectedError, _super);
                function CannotImportAlreadyConnectedError(importStuff, connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotImportAlreadyConnected";
                    _this.message = "Cannot import " + importStuff + " for \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotImportAlreadyConnectedError;
            }(Error));
            exports_140("CannotImportAlreadyConnectedError", CannotImportAlreadyConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotCloseNotConnectedError", [], function (exports_141, context_141) {
    "use strict";
    var __moduleName = context_141 && context_141.id;
    var CannotCloseNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries close not opened connection.
             */
            CannotCloseNotConnectedError = (function (_super) {
                __extends(CannotCloseNotConnectedError, _super);
                function CannotCloseNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotCloseNotConnectedError";
                    _this.message = "Cannot close \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotCloseNotConnectedError;
            }(Error));
            exports_141("CannotCloseNotConnectedError", CannotCloseNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotConnectAlreadyConnectedError", [], function (exports_142, context_142) {
    "use strict";
    var __moduleName = context_142 && context_142.id;
    var CannotConnectAlreadyConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to connect when he already connected.
             */
            CannotConnectAlreadyConnectedError = (function (_super) {
                __extends(CannotConnectAlreadyConnectedError, _super);
                function CannotConnectAlreadyConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotConnectAlreadyConnectedError";
                    _this.message = "Cannot create a \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotConnectAlreadyConnectedError;
            }(Error));
            exports_142("CannotConnectAlreadyConnectedError", CannotConnectAlreadyConnectedError);
        }
    };
});
System.register("typeorm/connection/error/NamingStrategyNotFoundError", [], function (exports_143, context_143) {
    "use strict";
    var __moduleName = context_143 && context_143.id;
    var NamingStrategyNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to use naming strategy that does not exist.
             */
            NamingStrategyNotFoundError = (function (_super) {
                __extends(NamingStrategyNotFoundError, _super);
                function NamingStrategyNotFoundError(strategyName, connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NamingStrategyNotFoundError";
                    var name = strategyName instanceof Function ? strategyName.name : strategyName;
                    _this.message = "Naming strategy \"" + name + "\" was not found. Looks like this naming strategy does not " +
                        ("exist or it was not registered in current \"" + connectionName + "\" connection?");
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NamingStrategyNotFoundError;
            }(Error));
            exports_143("NamingStrategyNotFoundError", NamingStrategyNotFoundError);
        }
    };
});
System.register("typeorm/decorator/options/JoinColumnOptions", [], function (exports_144, context_144) {
    "use strict";
    var __moduleName = context_144 && context_144.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/JoinTableMuplipleColumnsOptions", [], function (exports_145, context_145) {
    "use strict";
    var __moduleName = context_145 && context_145.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchema", [], function (exports_146, context_146) {
    "use strict";
    var __moduleName = context_146 && context_146.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/CannotSyncNotConnectedError", [], function (exports_147, context_147) {
    "use strict";
    var __moduleName = context_147 && context_147.id;
    var CannotSyncNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to sync a database schema after connection is established
             */
            CannotSyncNotConnectedError = (function (_super) {
                __extends(CannotSyncNotConnectedError, _super);
                function CannotSyncNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotSyncNotConnectedError";
                    _this.message = "Cannot sync schema of the \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotSyncNotConnectedError;
            }(Error));
            exports_147("CannotSyncNotConnectedError", CannotSyncNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/CannotUseNamingStrategyNotConnectedError", [], function (exports_148, context_148) {
    "use strict";
    var __moduleName = context_148 && context_148.id;
    var CannotUseNamingStrategyNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to change used naming strategy after connection is established.
             */
            CannotUseNamingStrategyNotConnectedError = (function (_super) {
                __extends(CannotUseNamingStrategyNotConnectedError, _super);
                function CannotUseNamingStrategyNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotUseNamingStrategyNotConnectedError";
                    _this.message = "Cannot use a given naming strategy for \"" + connectionName + "\" connection because connection to the database already established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotUseNamingStrategyNotConnectedError;
            }(Error));
            exports_148("CannotUseNamingStrategyNotConnectedError", CannotUseNamingStrategyNotConnectedError);
        }
    };
});
System.register("typeorm/subscriber/Broadcaster", ["typeorm/metadata/types/EventListenerTypes"], function (exports_149, context_149) {
    "use strict";
    var __moduleName = context_149 && context_149.id;
    var EventListenerTypes_1, Broadcaster;
    return {
        setters: [
            function (EventListenerTypes_1_1) {
                EventListenerTypes_1 = EventListenerTypes_1_1;
            }
        ],
        execute: function () {
            /**
             * Broadcaster provides a helper methods to broadcast events to the subscribers.
             */
            Broadcaster = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Broadcaster(connection, subscriberMetadatas) {
                    this.connection = connection;
                    this.subscriberMetadatas = subscriberMetadatas;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Broadcasts "BEFORE_INSERT", "BEFORE_UPDATE", "BEFORE_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastBeforeEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastBeforeInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastBeforeUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastBeforeRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT", "AFTER_UPDATE", "AFTER_REMOVE" events for all given subjects.
                 */
                Broadcaster.prototype.broadcastAfterEventsForAll = function (entityManager, insertSubjects, updateSubjects, removeSubjects) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var insertPromises, updatePromises, removePromises, allPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    insertPromises = insertSubjects.map(function (subject) { return _this.broadcastAfterInsertEvent(entityManager, subject); });
                                    updatePromises = updateSubjects.map(function (subject) { return _this.broadcastAfterUpdateEvent(entityManager, subject); });
                                    removePromises = removeSubjects.map(function (subject) { return _this.broadcastAfterRemoveEvent(entityManager, subject); });
                                    allPromises = insertPromises.concat(updatePromises).concat(removePromises);
                                    return [4 /*yield*/, Promise.all(allPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_INSERT" event.
                 * Before insert event is executed before entity is being inserted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeInsertEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_INSERT && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeInsert; })
                                        .map(function (subscriber) { return subscriber.beforeInsert({
                                        manager: manager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_UPDATE" event.
                 * Before update event is executed before entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeUpdateEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_UPDATE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeUpdate; })
                                        .map(function (subscriber) { return subscriber.beforeUpdate({
                                        manager: manager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "BEFORE_REMOVE" event.
                 * Before remove event is executed before entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastBeforeRemoveEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.BEFORE_REMOVE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.databaseEntity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.beforeRemove; })
                                        .map(function (subscriber) { return subscriber.beforeRemove({
                                        manager: manager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_INSERT" event.
                 * After insert event is executed after entity is being persisted to the database for the first time.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterInsertEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_INSERT && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterInsert; })
                                        .map(function (subscriber) { return subscriber.afterInsert({
                                        manager: manager,
                                        entity: subject.entity
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_UPDATE" event.
                 * After update event is executed after entity is being updated in the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterUpdateEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_UPDATE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterUpdate; })
                                        .map(function (subscriber) { return subscriber.afterUpdate({
                                        manager: manager,
                                        entity: subject.entity,
                                        databaseEntity: subject.databaseEntity,
                                        updatedColumns: subject.diffColumns,
                                        updatedRelations: subject.diffRelations,
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_REMOVE" event.
                 * After remove event is executed after entity is being removed from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastAfterRemoveEvent = function (manager, subject) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    listeners = subject.metadata.listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_REMOVE && listener.isAllowed(subject.entity); })
                                        .map(function (entityListener) { return subject.entity[entityListener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, subject.entityTarget) && subscriber.afterRemove; })
                                        .map(function (subscriber) { return subscriber.afterRemove({
                                        manager: manager,
                                        entity: subject.hasEntity ? subject.entity : undefined,
                                        databaseEntity: subject.databaseEntity,
                                        entityId: subject.metadata.getEntityIdMixedMap(subject.databaseEntity)
                                    }); });
                                    return [4 /*yield*/, Promise.all(listeners.concat(subscribers))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for all given entities, and their sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEventsForAll = function (target, entities) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, Promise.all(entities.map(function (entity) { return _this.broadcastLoadEvents(target, entity); }))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Broadcasts "AFTER_LOAD" event for the given entity and all its sub-entities.
                 * After load event is executed after entity has been loaded from the database.
                 * All subscribers and entity listeners who listened to this event will be executed at this point.
                 * Subscribers and entity listeners can return promises, it will wait until they are resolved.
                 */
                Broadcaster.prototype.broadcastLoadEvents = function (target, entity) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var children, listeners, subscribers;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (entity instanceof Promise)
                                        return [2 /*return*/];
                                    children = this.connection.getMetadata(target).relations.reduce(function (promises, relation) {
                                        if (!entity.hasOwnProperty(relation.propertyName))
                                            return promises;
                                        var value = relation.getEntityValue(entity);
                                        if (value instanceof Array) {
                                            promises = promises.concat(_this.broadcastLoadEventsForAll(relation.inverseEntityMetadata.target, value));
                                        }
                                        else if (value) {
                                            promises.push(_this.broadcastLoadEvents(relation.inverseEntityMetadata.target, value));
                                        }
                                        return promises;
                                    }, []);
                                    listeners = this.connection.getMetadata(target).listeners
                                        .filter(function (listener) { return listener.type === EventListenerTypes_1.EventListenerTypes.AFTER_LOAD && listener.isAllowed(entity); })
                                        .map(function (listener) { return entity[listener.propertyName](); });
                                    subscribers = this.subscriberMetadatas
                                        .filter(function (subscriber) { return _this.isAllowedSubscriber(subscriber, target) && subscriber.afterLoad; })
                                        .map(function (subscriber) { return subscriber.afterLoad(entity); });
                                    return [4 /*yield*/, Promise.all(children.concat(listeners.concat(subscribers)))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,
                 * or listens our entity.
                 */
                Broadcaster.prototype.isAllowedSubscriber = function (subscriber, target) {
                    return !subscriber.listenTo ||
                        !subscriber.listenTo() ||
                        subscriber.listenTo() === Object ||
                        subscriber.listenTo() === target;
                };
                return Broadcaster;
            }());
            exports_149("Broadcaster", Broadcaster);
        }
    };
});
System.register("typeorm/schema-builder/SchemaBuilder", ["typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/util/PromiseUtils"], function (exports_150, context_150) {
    "use strict";
    var __moduleName = context_150 && context_150.id;
    var TableSchema_5, ColumnSchema_6, ForeignKeySchema_5, IndexSchema_4, PrimaryKeySchema_5, PromiseUtils_2, SchemaBuilder;
    return {
        setters: [
            function (TableSchema_5_1) {
                TableSchema_5 = TableSchema_5_1;
            },
            function (ColumnSchema_6_1) {
                ColumnSchema_6 = ColumnSchema_6_1;
            },
            function (ForeignKeySchema_5_1) {
                ForeignKeySchema_5 = ForeignKeySchema_5_1;
            },
            function (IndexSchema_4_1) {
                IndexSchema_4 = IndexSchema_4_1;
            },
            function (PrimaryKeySchema_5_1) {
                PrimaryKeySchema_5 = PrimaryKeySchema_5_1;
            },
            function (PromiseUtils_2_1) {
                PromiseUtils_2 = PromiseUtils_2_1;
            }
        ],
        execute: function () {
            /**
             * Creates complete tables schemas in the database based on the entity metadatas.
             *
             * Steps how schema is being built:
             * 1. load list of all tables with complete column and keys information from the db
             * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata
             * 3. create new tables that does not exist in the db, but exist in the metadata
             * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata
             * 5. add columns from metadata which does not exist in the table
             * 6. update all exist columns which metadata has changed
             * 7. update primary keys - update old and create new primary key from changed columns
             * 8. create foreign keys which does not exist in the table yet
             * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore
             */
            SchemaBuilder = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                /**
                 * @param driver Driver needs to create a query runner
                 * @param logger Used to log schema creation events
                 * @param entityMetadatas All entities to create schema for
                 */
                function SchemaBuilder(driver, logger, entityMetadatas) {
                    this.driver = driver;
                    this.logger = logger;
                    this.entityMetadatas = entityMetadatas;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates complete schemas for the given entity metadatas.
                 */
                SchemaBuilder.prototype.build = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, _b, error_6;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    _a = this;
                                    return [4 /*yield*/, this.driver.createQueryRunner()];
                                case 1:
                                    _a.queryRunner = _c.sent();
                                    _b = this;
                                    return [4 /*yield*/, this.loadTableSchemas()];
                                case 2:
                                    _b.tableSchemas = _c.sent();
                                    return [4 /*yield*/, this.queryRunner.beginTransaction()];
                                case 3:
                                    _c.sent();
                                    _c.label = 4;
                                case 4:
                                    _c.trys.push([4, 14, 16, 18]);
                                    return [4 /*yield*/, this.dropOldForeignKeys()];
                                case 5:
                                    _c.sent();
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    return [4 /*yield*/, this.createNewTables()];
                                case 6:
                                    // await this.dropOldPrimaryKeys(); // todo: need to drop primary column because column updates are not possible
                                    _c.sent();
                                    return [4 /*yield*/, this.dropRemovedColumns()];
                                case 7:
                                    _c.sent();
                                    return [4 /*yield*/, this.addNewColumns()];
                                case 8:
                                    _c.sent();
                                    return [4 /*yield*/, this.updateExistColumns()];
                                case 9:
                                    _c.sent();
                                    return [4 /*yield*/, this.updatePrimaryKeys()];
                                case 10:
                                    _c.sent();
                                    return [4 /*yield*/, this.createIndices()];
                                case 11:
                                    _c.sent(); // we need to create indices before foreign keys because foreign keys rely on unique indices
                                    return [4 /*yield*/, this.createForeignKeys()];
                                case 12:
                                    _c.sent();
                                    return [4 /*yield*/, this.queryRunner.commitTransaction()];
                                case 13:
                                    _c.sent();
                                    return [3 /*break*/, 18];
                                case 14:
                                    error_6 = _c.sent();
                                    return [4 /*yield*/, this.queryRunner.rollbackTransaction()];
                                case 15:
                                    _c.sent();
                                    throw error_6;
                                case 16: return [4 /*yield*/, this.queryRunner.release()];
                                case 17:
                                    _c.sent();
                                    return [7 /*endfinally*/];
                                case 18: return [2 /*return*/];
                            }
                        });
                    });
                };
                Object.defineProperty(SchemaBuilder.prototype, "entityToSyncMetadatas", {
                    // -------------------------------------------------------------------------
                    // Private Methods
                    // -------------------------------------------------------------------------
                    get: function () {
                        return this.entityMetadatas.filter(function (metadata) { return !metadata.skipSchemaSync && metadata.tableType !== "single-table-child"; });
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Loads all table schemas from the database.
                 */
                SchemaBuilder.prototype.loadTableSchemas = function () {
                    var tableNames = this.entityToSyncMetadatas.map(function (metadata) { return metadata.tableName; });
                    return this.queryRunner.loadTableSchemas(tableNames);
                };
                /**
                 * Drops all (old) foreign keys that exist in the table schemas, but do not exist in the entity metadata.
                 */
                SchemaBuilder.prototype.dropOldForeignKeys = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var tableSchema, foreignKeySchemasToDrop;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                                    if (!tableSchema)
                                                        return [2 /*return*/];
                                                    foreignKeySchemasToDrop = tableSchema.foreignKeys.filter(function (foreignKeySchema) {
                                                        return !metadata.foreignKeys.find(function (metadataForeignKey) { return metadataForeignKey.name === foreignKeySchema.name; });
                                                    });
                                                    if (foreignKeySchemasToDrop.length === 0)
                                                        return [2 /*return*/];
                                                    this.logger.logSchemaBuild("dropping old foreign keys of " + tableSchema.name + ": " + foreignKeySchemasToDrop.map(function (dbForeignKey) { return dbForeignKey.name; }).join(", "));
                                                    // remove foreign keys from the table schema
                                                    tableSchema.removeForeignKeys(foreignKeySchemasToDrop);
                                                    // drop foreign keys from the database
                                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(tableSchema, foreignKeySchemasToDrop)];
                                                case 1:
                                                    // drop foreign keys from the database
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates tables that do not exist in the database yet.
                 * New tables are created without foreign and primary keys.
                 * Primary key only can be created in conclusion with auto generated column.
                 */
                SchemaBuilder.prototype.createNewTables = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var existTableSchema, tableSchema;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    existTableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                                    if (existTableSchema)
                                                        return [2 /*return*/];
                                                    this.logger.logSchemaBuild("creating a new table: " + metadata.tableName);
                                                    tableSchema = new TableSchema_5.TableSchema(metadata.tableName, this.metadataColumnsToColumnSchemas(metadata.columns), true);
                                                    this.tableSchemas.push(tableSchema);
                                                    return [4 /*yield*/, this.queryRunner.createTable(tableSchema)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); })];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all columns that exist in the table, but does not exist in the metadata (left old).
                 * We drop their keys too, since it should be safe.
                 */
                SchemaBuilder.prototype.dropRemovedColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, droppedColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    droppedColumnSchemas = tableSchema.columns.filter(function (columnSchema) {
                                        return !metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === columnSchema.name; });
                                    });
                                    if (droppedColumnSchemas.length === 0)
                                        return [2 /*return*/];
                                    // drop all foreign keys that has column to be removed in its columns
                                    return [4 /*yield*/, Promise.all(droppedColumnSchemas.map(function (droppedColumnSchema) {
                                            return _this.dropColumnReferencedForeignKeys(metadata.tableName, droppedColumnSchema.name);
                                        }))];
                                case 1:
                                    // drop all foreign keys that has column to be removed in its columns
                                    _a.sent();
                                    // drop all indices that point to this column
                                    return [4 /*yield*/, Promise.all(droppedColumnSchemas.map(function (droppedColumnSchema) {
                                            return _this.dropColumnReferencedIndices(metadata.tableName, droppedColumnSchema.name);
                                        }))];
                                case 2:
                                    // drop all indices that point to this column
                                    _a.sent();
                                    this.logger.logSchemaBuild("columns dropped in " + tableSchema.name + ": " + droppedColumnSchemas.map(function (column) { return column.name; }).join(", "));
                                    // remove columns from the table schema and primary keys of it if its used in the primary keys
                                    tableSchema.removeColumns(droppedColumnSchemas);
                                    tableSchema.removePrimaryKeysOfColumns(droppedColumnSchemas);
                                    // drop columns from the database
                                    return [4 /*yield*/, this.queryRunner.dropColumns(tableSchema, droppedColumnSchemas)];
                                case 3:
                                    // drop columns from the database
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Adds columns from metadata which does not exist in the table.
                 * Columns are created without keys.
                 */
                SchemaBuilder.prototype.addNewColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, newColumnMetadatas, newColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    newColumnMetadatas = metadata.columns.filter(function (columnMetadata) {
                                        return !tableSchema.columns.find(function (columnSchema) { return columnSchema.name === columnMetadata.databaseName; });
                                    });
                                    if (newColumnMetadatas.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("new columns added: " + newColumnMetadatas.map(function (column) { return column.databaseName; }).join(", "));
                                    newColumnSchemas = this.metadataColumnsToColumnSchemas(newColumnMetadatas);
                                    return [4 /*yield*/, this.queryRunner.addColumns(tableSchema, newColumnSchemas)];
                                case 1:
                                    _a.sent();
                                    tableSchema.addColumns(newColumnSchemas);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Update all exist columns which metadata has changed.
                 * Still don't create keys. Also we don't touch foreign keys of the changed columns.
                 */
                SchemaBuilder.prototype.updateExistColumns = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, updatedColumnSchemas, dropRelatedForeignKeysPromises, dropRelatedIndicesPromises, newAndOldColumnSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    updatedColumnSchemas = tableSchema.findChangedColumns(this.queryRunner, metadata.columns);
                                    if (updatedColumnSchemas.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("columns changed in " + tableSchema.name + ". updating: " + updatedColumnSchemas.map(function (column) { return column.name; }).join(", "));
                                    dropRelatedForeignKeysPromises = updatedColumnSchemas
                                        .filter(function (changedColumnSchema) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === changedColumnSchema.name; }); })
                                        .map(function (changedColumnSchema) { return _this.dropColumnReferencedForeignKeys(metadata.tableName, changedColumnSchema.name); });
                                    // wait until all related foreign keys are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedForeignKeysPromises)];
                                case 1:
                                    // wait until all related foreign keys are dropped
                                    _a.sent();
                                    dropRelatedIndicesPromises = updatedColumnSchemas
                                        .filter(function (changedColumnSchema) { return !!metadata.columns.find(function (columnMetadata) { return columnMetadata.databaseName === changedColumnSchema.name; }); })
                                        .map(function (changedColumnSchema) { return _this.dropColumnReferencedIndices(metadata.tableName, changedColumnSchema.name); });
                                    // wait until all related indices are dropped
                                    return [4 /*yield*/, Promise.all(dropRelatedIndicesPromises)];
                                case 2:
                                    // wait until all related indices are dropped
                                    _a.sent();
                                    newAndOldColumnSchemas = updatedColumnSchemas.map(function (changedColumnSchema) {
                                        var columnMetadata = metadata.columns.find(function (column) { return column.databaseName === changedColumnSchema.name; });
                                        var newColumnSchema = ColumnSchema_6.ColumnSchema.create(columnMetadata, _this.queryRunner.normalizeType(columnMetadata));
                                        tableSchema.replaceColumn(changedColumnSchema, newColumnSchema);
                                        return {
                                            newColumn: newColumnSchema,
                                            oldColumn: changedColumnSchema
                                        };
                                    });
                                    return [2 /*return*/, this.queryRunner.changeColumns(tableSchema, newAndOldColumnSchemas)];
                            }
                        });
                    }); });
                };
                /**
                 * Creates primary keys which does not exist in the table yet.
                 */
                SchemaBuilder.prototype.updatePrimaryKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, metadataPrimaryColumns, addedKeys, droppedKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName && !table.justCreated; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    metadataPrimaryColumns = metadata.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    addedKeys = metadataPrimaryColumns
                                        .filter(function (primaryKey) {
                                        return !tableSchema.primaryKeysWithoutGenerated.find(function (dbPrimaryKey) { return dbPrimaryKey.columnName === primaryKey.databaseName; });
                                    })
                                        .map(function (primaryKey) { return new PrimaryKeySchema_5.PrimaryKeySchema("", primaryKey.databaseName); });
                                    droppedKeys = tableSchema.primaryKeysWithoutGenerated.filter(function (primaryKeySchema) {
                                        return !metadataPrimaryColumns.find(function (primaryKeyMetadata) { return primaryKeyMetadata.databaseName === primaryKeySchema.columnName; });
                                    });
                                    if (addedKeys.length === 0 && droppedKeys.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("primary keys of " + tableSchema.name + " has changed: dropped - " + (droppedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing") + "; added - " + (addedKeys.map(function (key) { return key.columnName; }).join(", ") || "nothing"));
                                    tableSchema.addPrimaryKeys(addedKeys);
                                    tableSchema.removePrimaryKeys(droppedKeys);
                                    return [4 /*yield*/, this.queryRunner.updatePrimaryKeys(tableSchema)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates foreign keys which does not exist in the table yet.
                 */
                SchemaBuilder.prototype.createForeignKeys = function () {
                    var _this = this;
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var tableSchema, newKeys, dbForeignKeys;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    newKeys = metadata.foreignKeys.filter(function (foreignKey) {
                                        return !tableSchema.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === foreignKey.name; });
                                    });
                                    if (newKeys.length === 0)
                                        return [2 /*return*/];
                                    dbForeignKeys = newKeys.map(function (foreignKeyMetadata) { return ForeignKeySchema_5.ForeignKeySchema.create(foreignKeyMetadata); });
                                    this.logger.logSchemaBuild("creating a foreign keys: " + newKeys.map(function (key) { return key.name; }).join(", "));
                                    return [4 /*yield*/, this.queryRunner.createForeignKeys(tableSchema, dbForeignKeys)];
                                case 1:
                                    _a.sent();
                                    tableSchema.addForeignKeys(dbForeignKeys);
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Creates indices which are missing in db yet, and drops indices which exist in the db,
                 * but does not exist in the metadata anymore.
                 */
                SchemaBuilder.prototype.createIndices = function () {
                    var _this = this;
                    // return Promise.all(this.entityMetadatas.map(metadata => this.createIndices(metadata.table, metadata.indices)));
                    return PromiseUtils_2.PromiseUtils.runInSequence(this.entityToSyncMetadatas, function (metadata) { return __awaiter(_this, void 0, void 0, function () {
                        var _this = this;
                        var tableSchema, dropQueries, addQueries;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === metadata.tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dropQueries = tableSchema.indices
                                        .filter(function (indexSchema) { return !metadata.indices.find(function (indexMetadata) { return indexMetadata.name === indexSchema.name; }); })
                                        .map(function (indexSchema) { return __awaiter(_this, void 0, void 0, function () {
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    this.logger.logSchemaBuild("dropping an index: " + indexSchema.name);
                                                    tableSchema.removeIndex(indexSchema);
                                                    return [4 /*yield*/, this.queryRunner.dropIndex(metadata.tableName, indexSchema.name)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    addQueries = metadata.indices
                                        .filter(function (indexMetadata) { return !tableSchema.indices.find(function (indexSchema) { return indexSchema.name === indexMetadata.name; }); })
                                        .map(function (indexMetadata) { return __awaiter(_this, void 0, void 0, function () {
                                        var indexSchema;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    indexSchema = IndexSchema_4.IndexSchema.create(indexMetadata);
                                                    tableSchema.indices.push(indexSchema);
                                                    this.logger.logSchemaBuild("adding new index: " + indexSchema.name);
                                                    return [4 /*yield*/, this.queryRunner.createIndex(indexSchema.tableName, indexSchema)];
                                                case 1:
                                                    _a.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    return [4 /*yield*/, Promise.all(dropQueries.concat(addQueries))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                };
                /**
                 * Drops all indices where given column of the given table is being used.
                 */
                SchemaBuilder.prototype.dropColumnReferencedIndices = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var allIndexMetadatas, tableSchema, dependIndices, dependIndicesInTable, dropPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    allIndexMetadatas = this.entityMetadatas.reduce(function (all, metadata) { return all.concat(metadata.indices); }, []);
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dependIndices = allIndexMetadatas.filter(function (indexMetadata) {
                                        return indexMetadata.tableName === tableName && !!indexMetadata.columns.find(function (column) { return column.databaseName === columnName; });
                                    });
                                    if (!dependIndices.length)
                                        return [2 /*return*/];
                                    dependIndicesInTable = tableSchema.indices.filter(function (indexSchema) {
                                        return !!dependIndices.find(function (indexMetadata) { return indexSchema.name === indexMetadata.name; });
                                    });
                                    if (dependIndicesInTable.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("dropping related indices of " + tableName + "#" + columnName + ": " + dependIndicesInTable.map(function (index) { return index.name; }).join(", "));
                                    dropPromises = dependIndicesInTable.map(function (index) {
                                        tableSchema.removeIndex(index);
                                        return _this.queryRunner.dropIndex(tableSchema.name, index.name);
                                    });
                                    return [4 /*yield*/, Promise.all(dropPromises)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops all foreign keys where given column of the given table is being used.
                 */
                SchemaBuilder.prototype.dropColumnReferencedForeignKeys = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var allForeignKeyMetadatas, tableSchema, dependForeignKeys, dependForeignKeyInTable, foreignKeySchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    allForeignKeyMetadatas = this.entityMetadatas.reduce(function (all, metadata) { return all.concat(metadata.foreignKeys); }, []);
                                    tableSchema = this.tableSchemas.find(function (table) { return table.name === tableName; });
                                    if (!tableSchema)
                                        return [2 /*return*/];
                                    dependForeignKeys = allForeignKeyMetadatas.filter(function (foreignKey) {
                                        if (foreignKey.tableName === tableName) {
                                            return !!foreignKey.columns.find(function (fkColumn) {
                                                return fkColumn.databaseName === columnName;
                                            });
                                        }
                                        else if (foreignKey.referencedTableName === tableName) {
                                            return !!foreignKey.referencedColumns.find(function (fkColumn) {
                                                return fkColumn.databaseName === columnName;
                                            });
                                        }
                                        return false;
                                    });
                                    if (!dependForeignKeys.length)
                                        return [2 /*return*/];
                                    dependForeignKeyInTable = dependForeignKeys.filter(function (fk) {
                                        return !!tableSchema.foreignKeys.find(function (dbForeignKey) { return dbForeignKey.name === fk.name; });
                                    });
                                    if (dependForeignKeyInTable.length === 0)
                                        return [2 /*return*/];
                                    this.logger.logSchemaBuild("dropping related foreign keys of " + tableName + "#" + columnName + ": " + dependForeignKeyInTable.map(function (foreignKey) { return foreignKey.name; }).join(", "));
                                    foreignKeySchemas = dependForeignKeyInTable.map(function (foreignKeyMetadata) { return ForeignKeySchema_5.ForeignKeySchema.create(foreignKeyMetadata); });
                                    tableSchema.removeForeignKeys(foreignKeySchemas);
                                    return [4 /*yield*/, this.queryRunner.dropForeignKeys(tableSchema, foreignKeySchemas)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates new column schemas from the given column metadatas.
                 */
                SchemaBuilder.prototype.metadataColumnsToColumnSchemas = function (columns) {
                    var _this = this;
                    return columns.map(function (columnMetadata) {
                        return ColumnSchema_6.ColumnSchema.create(columnMetadata, _this.queryRunner.normalizeType(columnMetadata));
                    });
                };
                return SchemaBuilder;
            }());
            exports_150("SchemaBuilder", SchemaBuilder);
        }
    };
});
System.register("typeorm/metadata-args/error/EntityMetadataNotFound", [], function (exports_151, context_151) {
    "use strict";
    var __moduleName = context_151 && context_151.id;
    var EntityMetadataNotFound;
    return {
        setters: [],
        execute: function () {
            /**
             */
            EntityMetadataNotFound = (function (_super) {
                __extends(EntityMetadataNotFound, _super);
                function EntityMetadataNotFound(target) {
                    var _this = _super.call(this) || this;
                    _this.name = "EntityMetadataNotFound";
                    var targetName = typeof target === "function" && target.name ? target.name : target;
                    _this.message = "No metadata for \"" + targetName + "\" was found.";
                    return _this;
                }
                return EntityMetadataNotFound;
            }(Error));
            exports_151("EntityMetadataNotFound", EntityMetadataNotFound);
        }
    };
});
System.register("typeorm/migration/MigrationInterface", [], function (exports_152, context_152) {
    "use strict";
    var __moduleName = context_152 && context_152.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/migration/Migration", [], function (exports_153, context_153) {
    "use strict";
    var __moduleName = context_153 && context_153.id;
    var Migration;
    return {
        setters: [],
        execute: function () {
            /**
             * Represents entity of the migration in the database.
             */
            Migration = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Migration(timestamp, name, instance) {
                    this.timestamp = timestamp;
                    this.name = name;
                    this.instance = instance;
                }
                return Migration;
            }());
            exports_153("Migration", Migration);
        }
    };
});
System.register("typeorm/migration/MigrationExecutor", ["typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/types/ColumnTypes", "typeorm/query-builder/QueryBuilder", "typeorm/query-runner/QueryRunnerProvider", "typeorm/migration/Migration", "typeorm/util/PromiseUtils"], function (exports_154, context_154) {
    "use strict";
    var __moduleName = context_154 && context_154.id;
    var TableSchema_6, ColumnSchema_7, ColumnTypes_7, QueryBuilder_6, QueryRunnerProvider_4, Migration_1, PromiseUtils_3, MigrationExecutor;
    return {
        setters: [
            function (TableSchema_6_1) {
                TableSchema_6 = TableSchema_6_1;
            },
            function (ColumnSchema_7_1) {
                ColumnSchema_7 = ColumnSchema_7_1;
            },
            function (ColumnTypes_7_1) {
                ColumnTypes_7 = ColumnTypes_7_1;
            },
            function (QueryBuilder_6_1) {
                QueryBuilder_6 = QueryBuilder_6_1;
            },
            function (QueryRunnerProvider_4_1) {
                QueryRunnerProvider_4 = QueryRunnerProvider_4_1;
            },
            function (Migration_1_1) {
                Migration_1 = Migration_1_1;
            },
            function (PromiseUtils_3_1) {
                PromiseUtils_3 = PromiseUtils_3_1;
            }
        ],
        execute: function () {
            /**
             * Executes migrations: runs pending and reverts previously executed migrations.
             */
            MigrationExecutor = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function MigrationExecutor(connection, queryRunnerProvider) {
                    this.connection = connection;
                    this.queryRunnerProvider = queryRunnerProvider || new QueryRunnerProvider_4.QueryRunnerProvider(connection.driver, true);
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Executes all pending migrations. Pending migrations are migrations that are not yet executed,
                 * thus not saved in the database.
                 */
                MigrationExecutor.prototype.executePendingMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var queryRunner, entityManager, executedMigrations, lastTimeExecutedMigration, allMigrations, pendingMigrations, transactionStartedByUs, err_2;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    entityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(this.queryRunnerProvider);
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist()];
                                case 2:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations()];
                                case 3:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    allMigrations = this.getMigrations();
                                    pendingMigrations = allMigrations.filter(function (migration) {
                                        // check if we already have executed migration
                                        var executedMigration = executedMigrations.find(function (executedMigration) { return executedMigration.name === migration.name; });
                                        if (executedMigration)
                                            return false;
                                        // migration is new and not executed. now check if its timestamp is correct
                                        if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)
                                            throw new Error("New migration found: " + migration.name + ", however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.");
                                        // every check is passed means that migration was not run yet and we need to run it
                                        return true;
                                    });
                                    // if no migrations are pending then nothing to do here
                                    if (!pendingMigrations.length) {
                                        this.connection.logger.log("info", "No migrations are pending");
                                        return [2 /*return*/];
                                    }
                                    // log information about migration execution
                                    this.connection.logger.log("info", executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.log("info", allMigrations.length + " migrations were found in the source code.");
                                    if (lastTimeExecutedMigration)
                                        this.connection.logger.log("info", lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.log("info", pendingMigrations.length + " migrations are new migrations that needs to be executed.");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive()) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 4:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 5;
                                case 5:
                                    _a.trys.push([5, 9, , 12]);
                                    return [4 /*yield*/, PromiseUtils_3.PromiseUtils.runInSequence(pendingMigrations, function (migration) {
                                            return migration.instance.up(queryRunner, _this.connection, entityManager)
                                                .then(function () {
                                                return _this.insertExecutedMigration(migration);
                                            })
                                                .then(function () {
                                                _this.connection.logger.log("info", "Migration " + migration.name + " has been executed successfully.");
                                            });
                                        })];
                                case 6:
                                    _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 8];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 7:
                                    _a.sent();
                                    _a.label = 8;
                                case 8: return [3 /*break*/, 12];
                                case 9:
                                    err_2 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 11];
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 10:
                                    _a.sent();
                                    _a.label = 11;
                                case 11: throw err_2;
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last migration that were run.
                 */
                MigrationExecutor.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, entityManager, executedMigrations, lastTimeExecutedMigration, allMigrations, migrationToRevert, transactionStartedByUs, err_3;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    entityManager = this.connection.createEntityManagerWithSingleDatabaseConnection(this.queryRunnerProvider);
                                    // create migrations table if its not created yet
                                    return [4 /*yield*/, this.createMigrationsTableIfNotExist()];
                                case 2:
                                    // create migrations table if its not created yet
                                    _a.sent();
                                    return [4 /*yield*/, this.loadExecutedMigrations()];
                                case 3:
                                    executedMigrations = _a.sent();
                                    lastTimeExecutedMigration = this.getLatestMigration(executedMigrations);
                                    // if no migrations found in the database then nothing to revert
                                    if (!lastTimeExecutedMigration) {
                                        this.connection.logger.log("info", "No migrations was found in the database. Nothing to revert!");
                                        return [2 /*return*/];
                                    }
                                    allMigrations = this.getMigrations();
                                    migrationToRevert = allMigrations.find(function (migration) { return migration.name === lastTimeExecutedMigration.name; });
                                    // if no migrations found in the database then nothing to revert
                                    if (!migrationToRevert)
                                        throw new Error("No migration " + lastTimeExecutedMigration.name + " was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.");
                                    // log information about migration execution
                                    this.connection.logger.log("info", executedMigrations.length + " migrations are already loaded in the database.");
                                    this.connection.logger.log("info", lastTimeExecutedMigration.name + " is the last executed migration. It was executed on " + new Date(lastTimeExecutedMigration.timestamp * 1000).toString() + ".");
                                    this.connection.logger.log("info", "Now reverting it...");
                                    transactionStartedByUs = false;
                                    if (!!queryRunner.isTransactionActive()) return [3 /*break*/, 5];
                                    return [4 /*yield*/, queryRunner.beginTransaction()];
                                case 4:
                                    _a.sent();
                                    transactionStartedByUs = true;
                                    _a.label = 5;
                                case 5:
                                    _a.trys.push([5, 10, , 13]);
                                    return [4 /*yield*/, migrationToRevert.instance.down(queryRunner, this.connection, entityManager)];
                                case 6:
                                    _a.sent();
                                    return [4 /*yield*/, this.deleteExecutedMigration(migrationToRevert)];
                                case 7:
                                    _a.sent();
                                    this.connection.logger.log("info", "Migration " + migrationToRevert.name + " has been reverted successfully.");
                                    if (!transactionStartedByUs) return [3 /*break*/, 9];
                                    return [4 /*yield*/, queryRunner.commitTransaction()];
                                case 8:
                                    _a.sent();
                                    _a.label = 9;
                                case 9: return [3 /*break*/, 13];
                                case 10:
                                    err_3 = _a.sent();
                                    if (!transactionStartedByUs) return [3 /*break*/, 12];
                                    return [4 /*yield*/, queryRunner.rollbackTransaction()];
                                case 11:
                                    _a.sent();
                                    _a.label = 12;
                                case 12: throw err_3;
                                case 13: return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Creates table "migrations" that will store information about executed migrations.
                 */
                MigrationExecutor.prototype.createMigrationsTableIfNotExist = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner, tableExist;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.hasTable("migrations")];
                                case 2:
                                    tableExist = _a.sent();
                                    if (!!tableExist) return [3 /*break*/, 4];
                                    return [4 /*yield*/, queryRunner.createTable(new TableSchema_6.TableSchema("migrations", [
                                            new ColumnSchema_7.ColumnSchema({
                                                name: "timestamp",
                                                type: queryRunner.normalizeType({
                                                    type: ColumnTypes_7.ColumnTypes.NUMBER
                                                }),
                                                isPrimary: true,
                                                isNullable: false
                                            }),
                                            new ColumnSchema_7.ColumnSchema({
                                                name: "name",
                                                type: queryRunner.normalizeType({
                                                    type: ColumnTypes_7.ColumnTypes.STRING
                                                }),
                                                isNullable: false
                                            }),
                                        ]))];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Loads all migrations that were executed and saved into the database.
                 */
                MigrationExecutor.prototype.loadExecutedMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationsRaw;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, new QueryBuilder_6.QueryBuilder(this.connection, this.queryRunnerProvider)
                                        .select()
                                        .fromTable("migrations", "migrations")
                                        .getRawMany()];
                                case 1:
                                    migrationsRaw = _a.sent();
                                    return [2 /*return*/, migrationsRaw.map(function (migrationRaw) {
                                            return new Migration_1.Migration(parseInt(migrationRaw["timestamp"]), migrationRaw["name"]);
                                        })];
                            }
                        });
                    });
                };
                /**
                 * Gets all migrations that setup for this connection.
                 */
                MigrationExecutor.prototype.getMigrations = function () {
                    var migrations = this.connection.getMigrations().map(function (migration) {
                        var migrationClassName = migration.constructor.name;
                        var migrationTimestamp = parseInt(migrationClassName.substr(-13));
                        if (!migrationTimestamp)
                            throw new Error("Migration class name should contain a class name at the end of the file. " + migrationClassName + " migration name is wrong.");
                        return new Migration_1.Migration(migrationTimestamp, migrationClassName, migration);
                    });
                    // sort them by timestamp
                    return migrations.sort(function (a, b) { return a.timestamp - b.timestamp; });
                };
                /**
                 * Finds the latest migration (sorts by timestamp) in the given array of migrations.
                 */
                MigrationExecutor.prototype.getLatestMigration = function (migrations) {
                    var sortedMigrations = migrations.map(function (migration) { return migration; }).sort(function (a, b) { return (a.timestamp - b.timestamp) * -1; });
                    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;
                };
                /**
                 * Inserts new executed migration's data into migrations table.
                 */
                MigrationExecutor.prototype.insertExecutedMigration = function (migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.insert("migrations", {
                                            timestamp: migration.timestamp,
                                            name: migration.name,
                                        })];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Delete previously executed migration's data from the migrations table.
                 */
                MigrationExecutor.prototype.deleteExecutedMigration = function (migration) {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.queryRunnerProvider.provide()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.delete("migrations", {
                                            timestamp: migration.timestamp,
                                            name: migration.name,
                                        })];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                return MigrationExecutor;
            }());
            exports_154("MigrationExecutor", MigrationExecutor);
        }
    };
});
System.register("typeorm/connection/error/CannotRunMigrationNotConnectedError", [], function (exports_155, context_155) {
    "use strict";
    var __moduleName = context_155 && context_155.id;
    var CannotRunMigrationNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to run/revert migrations without connection set.
             */
            CannotRunMigrationNotConnectedError = (function (_super) {
                __extends(CannotRunMigrationNotConnectedError, _super);
                function CannotRunMigrationNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotRunMigrationNotConnectedError";
                    _this.message = "Cannot run/revert migrations on \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotRunMigrationNotConnectedError;
            }(Error));
            exports_155("CannotRunMigrationNotConnectedError", CannotRunMigrationNotConnectedError);
        }
    };
});
System.register("typeorm/repository/error/CustomRepositoryReusedError", [], function (exports_156, context_156) {
    "use strict";
    var __moduleName = context_156 && context_156.id;
    var CustomRepositoryReusedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if same custom repository instance is reused between different connections.
             */
            CustomRepositoryReusedError = (function (_super) {
                __extends(CustomRepositoryReusedError, _super);
                function CustomRepositoryReusedError(repository) {
                    var _this = _super.call(this, "Custom entity repository " + (repository instanceof Function ? repository.name : repository.constructor.name) + " " +
                        "was already used in the different connection. You can't share entity repositories between different connections " +
                        "when useContainer is set to true for the entity repository.") || this;
                    _this.name = "CustomRepositoryReusedError";
                    return _this;
                }
                return CustomRepositoryReusedError;
            }(Error));
            exports_156("CustomRepositoryReusedError", CustomRepositoryReusedError);
        }
    };
});
System.register("typeorm/decorator/options/JoinTableOptions", [], function (exports_157, context_157) {
    "use strict";
    var __moduleName = context_157 && context_157.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/entity-schema/EntitySchemaTransformer", ["typeorm/metadata-args/MetadataArgsStorage"], function (exports_158, context_158) {
    "use strict";
    var __moduleName = context_158 && context_158.id;
    var MetadataArgsStorage_1, EntitySchemaTransformer;
    return {
        setters: [
            function (MetadataArgsStorage_1_1) {
                MetadataArgsStorage_1 = MetadataArgsStorage_1_1;
            }
        ],
        execute: function () {
            EntitySchemaTransformer = (function () {
                function EntitySchemaTransformer() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                EntitySchemaTransformer.prototype.transform = function (schemas) {
                    var metadataArgsStorage = new MetadataArgsStorage_1.MetadataArgsStorage();
                    schemas.forEach(function (schema) {
                        // add table metadata args from the schema
                        var tableSchema = schema.table || {};
                        var table = {
                            target: schema.target || schema.name,
                            name: tableSchema.name,
                            type: tableSchema.type || "regular",
                            orderBy: tableSchema.orderBy
                        };
                        metadataArgsStorage.tables.push(table);
                        // add columns metadata args from the schema
                        Object.keys(schema.columns).forEach(function (columnName) {
                            var columnSchema = schema.columns[columnName];
                            var mode = "regular";
                            if (columnSchema.createDate)
                                mode = "createDate";
                            if (columnSchema.updateDate)
                                mode = "updateDate";
                            if (columnSchema.version)
                                mode = "version";
                            if (columnSchema.treeChildrenCount)
                                mode = "treeChildrenCount";
                            if (columnSchema.treeLevel)
                                mode = "treeLevel";
                            var column = {
                                target: schema.target || schema.name,
                                mode: mode,
                                propertyName: columnName,
                                options: {
                                    type: columnSchema.type,
                                    name: columnSchema.name,
                                    length: columnSchema.length,
                                    primary: columnSchema.primary,
                                    generated: columnSchema.generated,
                                    unique: columnSchema.unique,
                                    nullable: columnSchema.nullable,
                                    comment: columnSchema.comment,
                                    default: columnSchema.default,
                                    precision: columnSchema.precision,
                                    scale: columnSchema.scale
                                }
                            };
                            metadataArgsStorage.columns.push(column);
                        });
                        // add relation metadata args from the schema
                        if (schema.relations) {
                            Object.keys(schema.relations).forEach(function (relationName) {
                                var relationSchema = schema.relations[relationName];
                                var relation = {
                                    target: schema.target || schema.name,
                                    propertyName: relationName,
                                    relationType: relationSchema.type,
                                    isLazy: relationSchema.isLazy || false,
                                    type: relationSchema.target,
                                    inverseSideProperty: relationSchema.inverseSide,
                                    isTreeParent: relationSchema.isTreeParent,
                                    isTreeChildren: relationSchema.isTreeChildren,
                                    options: {
                                        cascadeAll: relationSchema.cascadeAll,
                                        cascadeInsert: relationSchema.cascadeInsert,
                                        cascadeUpdate: relationSchema.cascadeUpdate,
                                        cascadeRemove: relationSchema.cascadeRemove,
                                        nullable: relationSchema.nullable,
                                        onDelete: relationSchema.onDelete
                                    }
                                };
                                metadataArgsStorage.relations.push(relation);
                                // add join column
                                if (relationSchema.joinColumn) {
                                    if (typeof relationSchema.joinColumn === "boolean") {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinColumns.push(joinColumn);
                                    }
                                    else {
                                        var joinColumn = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinColumn.name,
                                            referencedColumnName: relationSchema.joinColumn.referencedColumnName
                                        };
                                        metadataArgsStorage.joinColumns.push(joinColumn);
                                    }
                                }
                                // add join table
                                if (relationSchema.joinTable) {
                                    if (typeof relationSchema.joinTable === "boolean") {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName
                                        };
                                        metadataArgsStorage.joinTables.push(joinTable);
                                    }
                                    else {
                                        var joinTable = {
                                            target: schema.target || schema.name,
                                            propertyName: relationName,
                                            name: relationSchema.joinTable.name,
                                            joinColumns: (relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns),
                                            inverseJoinColumns: (relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns),
                                        };
                                        metadataArgsStorage.joinTables.push(joinTable);
                                    }
                                }
                            });
                        }
                    });
                    return metadataArgsStorage;
                };
                return EntitySchemaTransformer;
            }());
            exports_158("EntitySchemaTransformer", EntitySchemaTransformer);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingPrimaryColumnError", [], function (exports_159, context_159) {
    "use strict";
    var __moduleName = context_159 && context_159.id;
    var MissingPrimaryColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingPrimaryColumnError = (function (_super) {
                __extends(MissingPrimaryColumnError, _super);
                function MissingPrimaryColumnError(entityMetadata) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingPrimaryColumnError";
                    _this.message = "Entity \"" + entityMetadata.name + "\" does not have a primary column. Primary column is required to " +
                        "have in all your entities. Use @PrimaryColumn decorator to add a primary column to your entity.";
                    return _this;
                }
                return MissingPrimaryColumnError;
            }(Error));
            exports_159("MissingPrimaryColumnError", MissingPrimaryColumnError);
        }
    };
});
System.register("typeorm/metadata-builder/error/CircularRelationsError", [], function (exports_160, context_160) {
    "use strict";
    var __moduleName = context_160 && context_160.id;
    var CircularRelationsError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when circular relations detected with nullable set to false.
             */
            CircularRelationsError = (function (_super) {
                __extends(CircularRelationsError, _super);
                function CircularRelationsError(path) {
                    var _this = _super.call(this, "Circular relations detected: " + path + ". To resolve this issue you need to set nullable: false somewhere in this dependency structure.") || this;
                    _this.name = "CircularRelationsError";
                    return _this;
                }
                return CircularRelationsError;
            }(Error));
            exports_160("CircularRelationsError", CircularRelationsError);
        }
    };
});
/**
 * This source code is from https://github.com/jriecken/dependency-graph
 * Just added "any" types here, wrapper everything into exported class.
 * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
 */
System.register("typeorm/util/DepGraph", [], function (exports_161, context_161) {
    "use strict";
    var __moduleName = context_161 && context_161.id;
    /**
     * A simple dependency graph
     */
    /**
     * Helper for creating a Depth-First-Search on
     * a set of edges.
     *
     * Detects cycles and throws an Error if one is detected.
     *
     * @param edges The set of edges to DFS through
     * @param leavesOnly Whether to only return "leaf" nodes (ones who have no edges)
     * @param result An array in which the results will be populated
     */
    function createDFS(edges, leavesOnly, result) {
        var currentPath = [];
        var visited = {};
        return function DFS(currentNode) {
            visited[currentNode] = true;
            currentPath.push(currentNode);
            edges[currentNode].forEach(function (node) {
                if (!visited[node]) {
                    DFS(node);
                }
                else if (currentPath.indexOf(node) >= 0) {
                    currentPath.push(node);
                    throw new Error("Dependency Cycle Found: " + currentPath.join(" -> "));
                }
            });
            currentPath.pop();
            if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {
                result.push(currentNode);
            }
        };
    }
    var DepGraph;
    return {
        setters: [],
        execute: function () {/**
             * This source code is from https://github.com/jriecken/dependency-graph
             * Just added "any" types here, wrapper everything into exported class.
             * We cant use a package itself because we want to package "everything-in-it" for the frontend users of TypeORM.
             */
            DepGraph = (function () {
                function DepGraph() {
                    this.nodes = {};
                    this.outgoingEdges = {}; // Node -> [Dependency Node]
                    this.incomingEdges = {}; // Node -> [Dependant Node]
                }
                /**
                 * Add a node to the dependency graph. If a node already exists, this method will do nothing.
                 */
                DepGraph.prototype.addNode = function (node, data) {
                    if (!this.hasNode(node)) {
                        // Checking the arguments length allows the user to add a node with undefined data
                        if (arguments.length === 2) {
                            this.nodes[node] = data;
                        }
                        else {
                            this.nodes[node] = node;
                        }
                        this.outgoingEdges[node] = [];
                        this.incomingEdges[node] = [];
                    }
                };
                /**
                 * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
                 */
                DepGraph.prototype.removeNode = function (node) {
                    if (this.hasNode(node)) {
                        delete this.nodes[node];
                        delete this.outgoingEdges[node];
                        delete this.incomingEdges[node];
                        [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {
                            Object.keys(edgeList).forEach(function (key) {
                                var idx = edgeList[key].indexOf(node);
                                if (idx >= 0) {
                                    edgeList[key].splice(idx, 1);
                                }
                            }, this);
                        });
                    }
                };
                /**
                 * Check if a node exists in the graph
                 */
                DepGraph.prototype.hasNode = function (node) {
                    return this.nodes.hasOwnProperty(node);
                };
                /**
                 * Get the data associated with a node name
                 */
                DepGraph.prototype.getNodeData = function (node) {
                    if (this.hasNode(node)) {
                        return this.nodes[node];
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Set the associated data for a given node name. If the node does not exist, this method will throw an error
                 */
                DepGraph.prototype.setNodeData = function (node, data) {
                    if (this.hasNode(node)) {
                        this.nodes[node] = data;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Add a dependency between two nodes. If either of the nodes does not exist,
                 * an Error will be thrown.
                 */
                DepGraph.prototype.addDependency = function (from, to) {
                    if (!this.hasNode(from)) {
                        throw new Error("Node does not exist: " + from);
                    }
                    if (!this.hasNode(to)) {
                        throw new Error("Node does not exist: " + to);
                    }
                    if (this.outgoingEdges[from].indexOf(to) === -1) {
                        this.outgoingEdges[from].push(to);
                    }
                    if (this.incomingEdges[to].indexOf(from) === -1) {
                        this.incomingEdges[to].push(from);
                    }
                    return true;
                };
                /**
                 * Remove a dependency between two nodes.
                 */
                DepGraph.prototype.removeDependency = function (from, to) {
                    var idx;
                    if (this.hasNode(from)) {
                        idx = this.outgoingEdges[from].indexOf(to);
                        if (idx >= 0) {
                            this.outgoingEdges[from].splice(idx, 1);
                        }
                    }
                    if (this.hasNode(to)) {
                        idx = this.incomingEdges[to].indexOf(from);
                        if (idx >= 0) {
                            this.incomingEdges[to].splice(idx, 1);
                        }
                    }
                };
                /**
                 * Get an array containing the nodes that the specified node depends on (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
                 * in the array.
                 */
                DepGraph.prototype.dependenciesOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.outgoingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * get an array containing the nodes that depend on the specified node (transitively).
                 *
                 * Throws an Error if the graph has a cycle, or the specified node does not exist.
                 *
                 * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
                 */
                DepGraph.prototype.dependantsOf = function (node, leavesOnly) {
                    if (this.hasNode(node)) {
                        var result = [];
                        var DFS = createDFS(this.incomingEdges, leavesOnly, result);
                        DFS(node);
                        var idx = result.indexOf(node);
                        if (idx >= 0) {
                            result.splice(idx, 1);
                        }
                        return result;
                    }
                    else {
                        throw new Error("Node does not exist: " + node);
                    }
                };
                /**
                 * Construct the overall processing order for the dependency graph.
                 *
                 * Throws an Error if the graph has a cycle.
                 *
                 * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
                 */
                DepGraph.prototype.overallOrder = function (leavesOnly) {
                    var self = this;
                    var result = [];
                    var keys = Object.keys(this.nodes);
                    if (keys.length === 0) {
                        return result; // Empty graph
                    }
                    else {
                        // Look for cycles - we run the DFS starting at all the nodes in case there
                        // are several disconnected subgraphs inside this dependency graph.
                        var CycleDFS_1 = createDFS(this.outgoingEdges, false, []);
                        keys.forEach(function (n) {
                            CycleDFS_1(n);
                        });
                        var DFS_1 = createDFS(this.outgoingEdges, leavesOnly, result);
                        // Find all potential starting points (nodes with nothing depending on them) an
                        // run a DFS starting at these points to get the order
                        keys.filter(function (node) {
                            return self.incomingEdges[node].length === 0;
                        }).forEach(function (n) {
                            DFS_1(n);
                        });
                        return result;
                    }
                };
                return DepGraph;
            }());
            exports_161("DepGraph", DepGraph);
        }
    };
});
System.register("typeorm/metadata-builder/EntityMetadataValidator", ["typeorm/metadata-builder/error/MissingPrimaryColumnError", "typeorm/metadata-builder/error/CircularRelationsError", "typeorm/util/DepGraph"], function (exports_162, context_162) {
    "use strict";
    var __moduleName = context_162 && context_162.id;
    var MissingPrimaryColumnError_1, CircularRelationsError_1, DepGraph_1, EntityMetadataValidator;
    return {
        setters: [
            function (MissingPrimaryColumnError_1_1) {
                MissingPrimaryColumnError_1 = MissingPrimaryColumnError_1_1;
            },
            function (CircularRelationsError_1_1) {
                CircularRelationsError_1 = CircularRelationsError_1_1;
            },
            function (DepGraph_1_1) {
                DepGraph_1 = DepGraph_1_1;
            }
        ],
        execute: function () {
            /// todo: add check if there are multiple tables with the same name
            /// todo: add checks when generated column / table names are too long for the specific driver
            // todo: type in function validation, inverse side function validation
            // todo: check on build for duplicate names, since naming checking was removed from MetadataStorage
            // todo: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
            // todo: check if multiple tree parent metadatas in validator
            // todo: tree decorators can be used only on closure table (validation)
            // todo: throw error if parent tree metadata was not specified in a closure table
            // todo: MetadataArgsStorage: type in function validation, inverse side function validation
            // todo: MetadataArgsStorage: check on build for duplicate names, since naming checking was removed from MetadataStorage
            // todo: MetadataArgsStorage: duplicate name checking for: table, relation, column, index, naming strategy, join tables/columns?
            // todo: MetadataArgsStorage: check for duplicate targets too since this check has been removed too
            /**
             * Validates built entity metadatas.
             */
            EntityMetadataValidator = (function () {
                function EntityMetadataValidator() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Validates all given entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateMany = function (entityMetadatas) {
                    var _this = this;
                    entityMetadatas.forEach(function (entityMetadata) { return _this.validate(entityMetadata, entityMetadatas); });
                    this.validateDependencies(entityMetadatas);
                };
                /**
                 * Validates given entity metadata.
                 */
                EntityMetadataValidator.prototype.validate = function (entityMetadata, allEntityMetadatas) {
                    // check if table metadata has an id
                    if (!entityMetadata.isClassTableChild && !entityMetadata.primaryColumns.length && !entityMetadata.isJunction)
                        throw new MissingPrimaryColumnError_1.MissingPrimaryColumnError(entityMetadata);
                    // validate if table is using inheritance it has a discriminator
                    // also validate if discriminator values are not empty and not repeated
                    if (entityMetadata.inheritanceType === "single-table") {
                        if (!entityMetadata.discriminatorColumn)
                            throw new Error("Entity " + entityMetadata.name + " using single-table inheritance, it should also have a discriminator column. Did you forget to put @DiscriminatorColumn decorator?");
                        if (["", undefined, null].indexOf(entityMetadata.discriminatorValue) !== -1)
                            throw new Error("Entity " + entityMetadata.name + " has empty discriminator value. Discriminator value should not be empty.");
                        var sameDiscriminatorValueEntityMetadata = allEntityMetadatas.find(function (metadata) {
                            return metadata !== entityMetadata && metadata.discriminatorValue === entityMetadata.discriminatorValue;
                        });
                        if (sameDiscriminatorValueEntityMetadata)
                            throw new Error("Entities " + entityMetadata.name + " and " + sameDiscriminatorValueEntityMetadata.name + " as equal discriminator values. Make sure their discriminator values are not equal using @DiscriminatorValue decorator.");
                    }
                    entityMetadata.relationCounts.forEach(function (relationCount) {
                        if (relationCount.relation.isManyToOne || relationCount.relation.isOneToOne)
                            throw new Error("Relation count can not be implemented on ManyToOne or OneToOne relations.");
                    });
                    // validate relations
                    entityMetadata.relations.forEach(function (relation) {
                        // check join tables:
                        // using JoinTable is possible only on one side of the many-to-many relation
                        // todo(dima): fix
                        // if (relation.joinTable) {
                        //     if (!relation.isManyToMany)
                        //         throw new UsingJoinTableIsNotAllowedError(entityMetadata, relation);
                        //     // if there is inverse side of the relation, then check if it does not have join table too
                        //     if (relation.hasInverseSide && relation.inverseRelation.joinTable)
                        //         throw new UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation);
                        // }
                        // check join columns:
                        // using JoinColumn is possible only on one side of the relation and on one-to-one, many-to-one relation types
                        // first check if relation is one-to-one or many-to-one
                        // todo(dima): fix
                        /*if (relation.joinColumn) {
            
                            // join column can be applied only on one-to-one and many-to-one relations
                            if (!relation.isOneToOne && !relation.isManyToOne)
                                throw new UsingJoinColumnIsNotAllowedError(entityMetadata, relation);
            
                            // if there is inverse side of the relation, then check if it does not have join table too
                            if (relation.hasInverseSide && relation.inverseRelation.joinColumn && relation.isOneToOne)
                                throw new UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation);
            
                            // check if join column really has referenced column
                            if (relation.joinColumn && !relation.joinColumn.referencedColumn)
                                throw new Error(`Join column does not have referenced column set`);
            
                        }
            
                        // if its a one-to-one relation and JoinColumn is missing on both sides of the relation
                        // or its one-side relation without JoinColumn we should give an error
                        if (!relation.joinColumn && relation.isOneToOne && (!relation.hasInverseSide || !relation.inverseRelation.joinColumn))
                            throw new MissingJoinColumnError(entityMetadata, relation);*/
                        // if its a many-to-many relation and JoinTable is missing on both sides of the relation
                        // or its one-side relation without JoinTable we should give an error
                        // todo(dima): fix it
                        // if (!relation.joinTable && relation.isManyToMany && (!relation.hasInverseSide || !relation.inverseRelation.joinTable))
                        //     throw new MissingJoinTableError(entityMetadata, relation);
                        // todo: validate if its one-to-one and side which does not have join column MUST have inverse side
                        // todo: validate if its many-to-many and side which does not have join table MUST have inverse side
                        // todo: if there is a relation, and inverse side is specified only on one side, shall we give error
                        // todo: with message like: "Inverse side is specified only on one side of the relationship. Specify on other side too to prevent confusion".
                        // todo: add validation if there two entities with the same target, and show error message with description of the problem (maybe file was renamed/moved but left in output directory)
                        // todo: check if there are multiple columns on the same column applied.
                        // todo: check column type if is missing in relational databases (throw new Error(`Column type of ${type} cannot be determined.`);)
                        // todo: include driver-specific checks. for example in mongodb empty prefixes are not allowed
                        // todo: if multiple columns with same name - throw exception, including cases when columns are in embeds with same prefixes or without prefix at all
                        // todo: if multiple primary key used, at least one of them must be unique or @Index decorator must be set on entity
                        // todo: check if entity with duplicate names, some decorators exist
                    });
                    // make sure cascade remove is not set for both sides of relationships (can be set in OneToOne decorators)
                    entityMetadata.relations.forEach(function (relation) {
                        var isCircularCascadeRemove = relation.isCascadeRemove && relation.inverseRelation && relation.inverseRelation.isCascadeRemove;
                        if (isCircularCascadeRemove)
                            throw new Error("Relation " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseRelation.entityMetadata.name + "#" + relation.inverseRelation.propertyName + " both has cascade remove set. " +
                                "This may lead to unexpected circular removals. Please set cascade remove only from one side of relationship.");
                    }); // todo: maybe better just deny removal from one to one relation without join column?
                };
                /**
                 * Validates dependencies of the entity metadatas.
                 */
                EntityMetadataValidator.prototype.validateDependencies = function (entityMetadatas) {
                    var graph = new DepGraph_1.DepGraph();
                    entityMetadatas.forEach(function (entityMetadata) {
                        graph.addNode(entityMetadata.name);
                    });
                    entityMetadatas.forEach(function (entityMetadata) {
                        entityMetadata.relationsWithJoinColumns
                            .filter(function (relation) { return !relation.isNullable; })
                            .forEach(function (relation) {
                            graph.addDependency(entityMetadata.name, relation.inverseEntityMetadata.name);
                        });
                    });
                    try {
                        graph.overallOrder();
                    }
                    catch (err) {
                        throw new CircularRelationsError_1.CircularRelationsError(err.toString().replace("Error: Dependency Cycle Found: ", ""));
                    }
                };
                return EntityMetadataValidator;
            }());
            exports_162("EntityMetadataValidator", EntityMetadataValidator);
        }
    };
});
System.register("typeorm/connection/Connection", ["typeorm/connection/error/RepositoryNotFoundError", "typeorm/entity-manager/EntityManager", "typeorm/util/DirectoryExportedClassesLoader", "typeorm/index", "typeorm/metadata-builder/EntityMetadataBuilder", "typeorm/naming-strategy/DefaultNamingStrategy", "typeorm/connection/error/CannotImportAlreadyConnectedError", "typeorm/connection/error/CannotCloseNotConnectedError", "typeorm/connection/error/CannotConnectAlreadyConnectedError", "typeorm/connection/error/NamingStrategyNotFoundError", "typeorm/connection/error/RepositoryNotTreeError", "typeorm/connection/error/CannotSyncNotConnectedError", "typeorm/connection/error/CannotUseNamingStrategyNotConnectedError", "typeorm/subscriber/Broadcaster", "typeorm/lazy-loading/LazyRelationsWrapper", "typeorm/repository/RepositoryAggregator", "typeorm/schema-builder/SchemaBuilder", "typeorm/query-runner/QueryRunnerProvider", "typeorm/metadata-args/error/EntityMetadataNotFound", "typeorm/migration/MigrationExecutor", "typeorm/connection/error/CannotRunMigrationNotConnectedError", "typeorm/platform/PlatformTools", "typeorm/driver/mongodb/MongoDriver", "typeorm/entity-manager/MongoEntityManager", "typeorm/entity-schema/EntitySchemaTransformer", "typeorm/metadata-builder/EntityMetadataValidator"], function (exports_163, context_163) {
    "use strict";
    var __moduleName = context_163 && context_163.id;
    var RepositoryNotFoundError_1, EntityManager_2, DirectoryExportedClassesLoader_1, index_3, EntityMetadataBuilder_1, DefaultNamingStrategy_1, CannotImportAlreadyConnectedError_1, CannotCloseNotConnectedError_1, CannotConnectAlreadyConnectedError_1, NamingStrategyNotFoundError_1, RepositoryNotTreeError_2, CannotSyncNotConnectedError_1, CannotUseNamingStrategyNotConnectedError_1, Broadcaster_1, LazyRelationsWrapper_1, RepositoryAggregator_2, SchemaBuilder_1, QueryRunnerProvider_5, EntityMetadataNotFound_1, MigrationExecutor_1, CannotRunMigrationNotConnectedError_1, PlatformTools_8, MongoDriver_4, MongoEntityManager_1, EntitySchemaTransformer_1, EntityMetadataValidator_1, Connection;
    return {
        setters: [
            function (RepositoryNotFoundError_1_1) {
                RepositoryNotFoundError_1 = RepositoryNotFoundError_1_1;
            },
            function (EntityManager_2_1) {
                EntityManager_2 = EntityManager_2_1;
            },
            function (DirectoryExportedClassesLoader_1_1) {
                DirectoryExportedClassesLoader_1 = DirectoryExportedClassesLoader_1_1;
            },
            function (index_3_1) {
                index_3 = index_3_1;
            },
            function (EntityMetadataBuilder_1_1) {
                EntityMetadataBuilder_1 = EntityMetadataBuilder_1_1;
            },
            function (DefaultNamingStrategy_1_1) {
                DefaultNamingStrategy_1 = DefaultNamingStrategy_1_1;
            },
            function (CannotImportAlreadyConnectedError_1_1) {
                CannotImportAlreadyConnectedError_1 = CannotImportAlreadyConnectedError_1_1;
            },
            function (CannotCloseNotConnectedError_1_1) {
                CannotCloseNotConnectedError_1 = CannotCloseNotConnectedError_1_1;
            },
            function (CannotConnectAlreadyConnectedError_1_1) {
                CannotConnectAlreadyConnectedError_1 = CannotConnectAlreadyConnectedError_1_1;
            },
            function (NamingStrategyNotFoundError_1_1) {
                NamingStrategyNotFoundError_1 = NamingStrategyNotFoundError_1_1;
            },
            function (RepositoryNotTreeError_2_1) {
                RepositoryNotTreeError_2 = RepositoryNotTreeError_2_1;
            },
            function (CannotSyncNotConnectedError_1_1) {
                CannotSyncNotConnectedError_1 = CannotSyncNotConnectedError_1_1;
            },
            function (CannotUseNamingStrategyNotConnectedError_1_1) {
                CannotUseNamingStrategyNotConnectedError_1 = CannotUseNamingStrategyNotConnectedError_1_1;
            },
            function (Broadcaster_1_1) {
                Broadcaster_1 = Broadcaster_1_1;
            },
            function (LazyRelationsWrapper_1_1) {
                LazyRelationsWrapper_1 = LazyRelationsWrapper_1_1;
            },
            function (RepositoryAggregator_2_1) {
                RepositoryAggregator_2 = RepositoryAggregator_2_1;
            },
            function (SchemaBuilder_1_1) {
                SchemaBuilder_1 = SchemaBuilder_1_1;
            },
            function (QueryRunnerProvider_5_1) {
                QueryRunnerProvider_5 = QueryRunnerProvider_5_1;
            },
            function (EntityMetadataNotFound_1_1) {
                EntityMetadataNotFound_1 = EntityMetadataNotFound_1_1;
            },
            function (MigrationExecutor_1_1) {
                MigrationExecutor_1 = MigrationExecutor_1_1;
            },
            function (CannotRunMigrationNotConnectedError_1_1) {
                CannotRunMigrationNotConnectedError_1 = CannotRunMigrationNotConnectedError_1_1;
            },
            function (PlatformTools_8_1) {
                PlatformTools_8 = PlatformTools_8_1;
            },
            function (MongoDriver_4_1) {
                MongoDriver_4 = MongoDriver_4_1;
            },
            function (MongoEntityManager_1_1) {
                MongoEntityManager_1 = MongoEntityManager_1_1;
            },
            function (EntitySchemaTransformer_1_1) {
                EntitySchemaTransformer_1 = EntitySchemaTransformer_1_1;
            },
            function (EntityMetadataValidator_1_1) {
                EntityMetadataValidator_1 = EntityMetadataValidator_1_1;
            }
        ],
        execute: function () {
            /**
             * Connection is a single database connection to a specific database of a database management system.
             * You can have multiple connections to multiple databases in your application.
             */
            Connection = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function Connection(name, driver, logger) {
                    /**
                     * All entity metadatas that are registered for this connection.
                     */
                    this.entityMetadatas = [];
                    /**
                     * Stores all registered repositories.
                     */
                    this.repositoryAggregators = [];
                    /**
                     * Stores all entity repository instances.
                     */
                    this.entityRepositories = [];
                    /**
                     * Entity subscribers that are registered for this connection.
                     */
                    this.entitySubscribers = [];
                    /**
                     * Registered entity classes to be used for this connection.
                     */
                    this.entityClasses = [];
                    /**
                     * Registered entity schemas to be used for this connection.
                     */
                    this.entitySchemas = [];
                    /**
                     * Registered subscriber classes to be used for this connection.
                     */
                    this.subscriberClasses = [];
                    /**
                     * Registered naming strategy classes to be used for this connection.
                     */
                    this.namingStrategyClasses = [];
                    /**
                     * Registered migration classes to be used for this connection.
                     */
                    this.migrationClasses = [];
                    /**
                     * Indicates if connection has been done or not.
                     */
                    this._isConnected = false;
                    this.name = name;
                    this.driver = driver;
                    this.logger = logger;
                    this.manager = this.createEntityManager();
                    this.broadcaster = this.createBroadcaster();
                }
                Object.defineProperty(Connection.prototype, "isConnected", {
                    // -------------------------------------------------------------------------
                    // Accessors
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection to the database already established for this connection.
                     */
                    get: function () {
                        return this._isConnected;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Connection.prototype, "entityManager", {
                    /**
                     * Gets entity manager that allows to perform repository operations with any entity in this connection.
                     *
                     * @deprecated use manager instead.
                     */
                    get: function () {
                        return this.manager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Connection.prototype, "mongoEntityManager", {
                    /**
                     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations
                     * with any entity in this connection.
                     */
                    get: function () {
                        if (!(this.manager instanceof MongoEntityManager_1.MongoEntityManager))
                            throw new Error("MongoEntityManager is only available for MongoDB databases.");
                        return this.manager;
                    },
                    enumerable: true,
                    configurable: true
                });
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                Connection.prototype.connect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var error_7;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isConnected)
                                        throw new CannotConnectAlreadyConnectedError_1.CannotConnectAlreadyConnectedError(this.name);
                                    // connect to the database via its driver
                                    return [4 /*yield*/, this.driver.connect()];
                                case 1:
                                    // connect to the database via its driver
                                    _a.sent();
                                    // set connected status for the current connection
                                    this._isConnected = true;
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 3, , 5]);
                                    this.buildMetadatas();
                                    return [3 /*break*/, 5];
                                case 3:
                                    error_7 = _a.sent();
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    return [4 /*yield*/, this.close()];
                                case 4:
                                    // if for some reason build metadata fail (for example validation error during entity metadata check)
                                    // connection needs to be closed
                                    _a.sent();
                                    throw error_7;
                                case 5: return [2 /*return*/, this];
                            }
                        });
                    });
                };
                /**
                 * Closes connection with the database.
                 * Once connection is closed, you cannot use repositories and perform any operations except
                 * opening connection again.
                 */
                Connection.prototype.close = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        throw new CannotCloseNotConnectedError_1.CannotCloseNotConnectedError(this.name);
                                    return [4 /*yield*/, this.driver.disconnect()];
                                case 1:
                                    _a.sent();
                                    this._isConnected = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops the database and all its data.
                 */
                Connection.prototype.dropDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var queryRunner;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.driver.createQueryRunner()];
                                case 1:
                                    queryRunner = _a.sent();
                                    return [4 /*yield*/, queryRunner.clearDatabase()];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates database schema for all entities registered in this connection.
                 *
                 * @param dropBeforeSync If set to true then it drops the database with all its tables and data
                 */
                Connection.prototype.syncSchema = function (dropBeforeSync) {
                    if (dropBeforeSync === void 0) { dropBeforeSync = false; }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotSyncNotConnectedError_1.CannotSyncNotConnectedError(this.name))];
                                    if (!dropBeforeSync) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.dropDatabase()];
                                case 1:
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    if (!(this.driver instanceof MongoDriver_4.MongoDriver)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, this.driver.syncSchema(this.entityMetadatas)];
                                case 3:
                                    _a.sent();
                                    return [3 /*break*/, 6];
                                case 4: return [4 /*yield*/, this.createSchemaBuilder().build()];
                                case 5:
                                    _a.sent();
                                    _a.label = 6;
                                case 6: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Runs all pending migrations.
                 */
                Connection.prototype.runMigrations = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotRunMigrationNotConnectedError_1.CannotRunMigrationNotConnectedError(this.name))];
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.executePendingMigrations()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Reverts last executed migration.
                 */
                Connection.prototype.undoLastMigration = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var migrationExecutor;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.isConnected)
                                        return [2 /*return*/, Promise.reject(new CannotRunMigrationNotConnectedError_1.CannotRunMigrationNotConnectedError(this.name))];
                                    migrationExecutor = new MigrationExecutor_1.MigrationExecutor(this);
                                    return [4 /*yield*/, migrationExecutor.undoLastMigration()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Imports entities from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importEntitiesFromDirectories = function (paths) {
                    this.importEntities(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports entity schemas from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importEntitySchemaFromDirectories = function (paths) {
                    this.importEntitySchemas(DirectoryExportedClassesLoader_1.importJsonsFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports subscribers from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importSubscribersFromDirectories = function (paths) {
                    this.importSubscribers(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports naming strategies from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importNamingStrategiesFromDirectories = function (paths) {
                    this.importNamingStrategies(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports migrations from the given paths (directories) and registers them in the current connection.
                 */
                Connection.prototype.importMigrationsFromDirectories = function (paths) {
                    this.importMigrations(DirectoryExportedClassesLoader_1.importClassesFromDirectories(paths));
                    return this;
                };
                /**
                 * Imports entities and registers them in the current connection.
                 */
                Connection.prototype.importEntities = function (entities) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("entities", this.name);
                    entities.forEach(function (cls) { return _this.entityClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports schemas and registers them in the current connection.
                 */
                Connection.prototype.importEntitySchemas = function (schemas) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("schemas", this.name);
                    schemas.forEach(function (schema) { return _this.entitySchemas.push(schema); });
                    return this;
                };
                /**
                 * Imports subscribers and registers them in the current connection.
                 */
                Connection.prototype.importSubscribers = function (subscriberClasses) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("entity subscribers", this.name);
                    subscriberClasses.forEach(function (cls) { return _this.subscriberClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports naming strategies and registers them in the current connection.
                 */
                Connection.prototype.importNamingStrategies = function (strategies) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("naming strategies", this.name);
                    strategies.forEach(function (cls) { return _this.namingStrategyClasses.push(cls); });
                    return this;
                };
                /**
                 * Imports migrations and registers them in the current connection.
                 */
                Connection.prototype.importMigrations = function (migrations) {
                    var _this = this;
                    if (this.isConnected)
                        throw new CannotImportAlreadyConnectedError_1.CannotImportAlreadyConnectedError("migrations", this.name);
                    migrations.forEach(function (cls) { return _this.migrationClasses.push(cls); });
                    return this;
                };
                /**
                 * Sets given naming strategy to be used.
                 * Naming strategy must be set to be used before connection is established.
                 */
                Connection.prototype.useNamingStrategy = function (strategyClassOrName) {
                    if (this.isConnected)
                        throw new CannotUseNamingStrategyNotConnectedError_1.CannotUseNamingStrategyNotConnectedError(this.name);
                    this.usedNamingStrategy = strategyClassOrName;
                    return this;
                };
                /**
                 Gets entity metadata for the given entity class or schema name.
                 */
                Connection.prototype.getMetadata = function (target) {
                    var metadata = this.entityMetadatas.find(function (metadata) { return metadata.target === target || (typeof target === "string" && metadata.targetName === target); });
                    if (!metadata)
                        throw new EntityMetadataNotFound_1.EntityMetadataNotFound(target);
                    return metadata;
                };
                /**
                 * Gets repository for the given entity class or name.
                 */
                Connection.prototype.getRepository = function (entityClassOrName) {
                    return this.findRepositoryAggregator(entityClassOrName).repository;
                };
                /**
                 * Gets tree repository for the given entity class or name.
                 * Only tree-type entities can have a TreeRepository,
                 * like ones decorated with @ClosureEntity decorator.
                 */
                Connection.prototype.getTreeRepository = function (entityClassOrName) {
                    // todo: add checks if tree repository is supported by driver (not supported by mongodb at least)
                    var repository = this.findRepositoryAggregator(entityClassOrName).treeRepository;
                    if (!repository)
                        throw new RepositoryNotTreeError_2.RepositoryNotTreeError(entityClassOrName);
                    return repository;
                };
                /**
                 * Gets mongodb-specific repository for the given entity class or name.
                 */
                Connection.prototype.getMongoRepository = function (entityClassOrName) {
                    if (!(this.driver instanceof MongoDriver_4.MongoDriver))
                        throw new Error("You can use getMongoRepository only for MongoDB connections.");
                    return this.findRepositoryAggregator(entityClassOrName).repository;
                };
                /**
                 * Gets specific repository for the given entity class or name.
                 * SpecificRepository is a special repository that contains specific and non standard repository methods.
                 *
                 * @experimental
                 */
                Connection.prototype.getSpecificRepository = function (entityClassOrName) {
                    return this.findRepositoryAggregator(entityClassOrName).specificRepository;
                };
                /**
                 * Creates a new entity manager with a single opened connection to the database.
                 * This may be useful if you want to perform all db queries within one connection.
                 * After finishing with entity manager, don't forget to release it, to release connection back to pool.
                 */
                Connection.prototype.createEntityManagerWithSingleDatabaseConnection = function (queryRunnerProvider) {
                    if (!queryRunnerProvider)
                        queryRunnerProvider = new QueryRunnerProvider_5.QueryRunnerProvider(this.driver, true);
                    return new EntityManager_2.EntityManager(this, queryRunnerProvider);
                };
                /**
                 * Gets migration instances that are registered for this connection.
                 */
                Connection.prototype.getMigrations = function () {
                    if (this.migrationClasses && this.migrationClasses.length) {
                        return this.migrationClasses.map(function (migrationClass) {
                            return index_3.getFromContainer(migrationClass);
                        });
                    }
                    return [];
                };
                /**
                 * Gets custom entity repository marked with @EntityRepository decorator.
                 */
                Connection.prototype.getCustomRepository = function (customRepository) {
                    return this.manager.getCustomRepository(customRepository);
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Finds repository aggregator of the given entity class or name.
                 */
                Connection.prototype.findRepositoryAggregator = function (entityClassOrName) {
                    // if (!this.isConnected)
                    //     throw new NoConnectionForRepositoryError(this.name);
                    if (!this.entityMetadatas.find(function (metadata) { return metadata.target === entityClassOrName || (typeof entityClassOrName === "string" && metadata.targetName === entityClassOrName); }))
                        throw new RepositoryNotFoundError_1.RepositoryNotFoundError(this.name, entityClassOrName);
                    var metadata = this.getMetadata(entityClassOrName);
                    var repositoryAggregator = this.repositoryAggregators.find(function (repositoryAggregate) { return repositoryAggregate.metadata === metadata; });
                    if (!repositoryAggregator)
                        throw new RepositoryNotFoundError_1.RepositoryNotFoundError(this.name, entityClassOrName);
                    return repositoryAggregator;
                };
                /**
                 * Builds all registered metadatas.
                 */
                Connection.prototype.buildMetadatas = function () {
                    var _this = this;
                    this.entitySubscribers.length = 0;
                    this.repositoryAggregators.length = 0;
                    this.entityMetadatas.length = 0;
                    this.driver.namingStrategy = this.createNamingStrategy(); // todo: why they are in the driver
                    this.driver.lazyRelationsWrapper = this.createLazyRelationsWrapper(); // todo: why they are in the driver
                    var entityMetadataValidator = new EntityMetadataValidator_1.EntityMetadataValidator();
                    // take imported event subscribers
                    if (this.subscriberClasses && this.subscriberClasses.length && !PlatformTools_8.PlatformTools.getEnvVariable("SKIP_SUBSCRIBERS_LOADING")) {
                        index_3.getMetadataArgsStorage()
                            .filterSubscribers(this.subscriberClasses)
                            .map(function (metadata) { return index_3.getFromContainer(metadata.target); })
                            .forEach(function (subscriber) { return _this.entitySubscribers.push(subscriber); });
                    }
                    // take imported entity listeners
                    if (this.entityClasses && this.entityClasses.length) {
                        // build entity metadatas from metadata args storage (collected from decorators)
                        new EntityMetadataBuilder_1.EntityMetadataBuilder(this, index_3.getMetadataArgsStorage())
                            .build(this.entityClasses)
                            .forEach(function (metadata) {
                            _this.entityMetadatas.push(metadata);
                            _this.repositoryAggregators.push(new RepositoryAggregator_2.RepositoryAggregator(_this, metadata));
                        });
                    }
                    // build entity metadatas from given entity schemas
                    if (this.entitySchemas && this.entitySchemas.length) {
                        var metadataArgsStorage = index_3.getFromContainer(EntitySchemaTransformer_1.EntitySchemaTransformer).transform(this.entitySchemas);
                        new EntityMetadataBuilder_1.EntityMetadataBuilder(this, metadataArgsStorage)
                            .build()
                            .forEach(function (metadata) {
                            _this.entityMetadatas.push(metadata);
                            _this.repositoryAggregators.push(new RepositoryAggregator_2.RepositoryAggregator(_this, metadata));
                        });
                    }
                    entityMetadataValidator.validateMany(this.entityMetadatas);
                };
                /**
                 * Creates a naming strategy to be used for this connection.
                 */
                Connection.prototype.createNamingStrategy = function () {
                    var _this = this;
                    // if naming strategies are not loaded, or used naming strategy is not set then use default naming strategy
                    if (!this.namingStrategyClasses || !this.namingStrategyClasses.length || !this.usedNamingStrategy)
                        return index_3.getFromContainer(DefaultNamingStrategy_1.DefaultNamingStrategy);
                    // try to find used naming strategy in the list of loaded naming strategies
                    var namingMetadata = index_3.getMetadataArgsStorage()
                        .filterNamingStrategies(this.namingStrategyClasses)
                        .find(function (strategy) {
                        if (typeof _this.usedNamingStrategy === "string") {
                            return strategy.name === _this.usedNamingStrategy;
                        }
                        else {
                            return strategy.target === _this.usedNamingStrategy;
                        }
                    });
                    // throw an error if not found
                    if (!namingMetadata)
                        throw new NamingStrategyNotFoundError_1.NamingStrategyNotFoundError(this.usedNamingStrategy, this.name);
                    // initialize a naming strategy instance
                    return index_3.getFromContainer(namingMetadata.target);
                };
                /**
                 * Creates a new default entity manager without single connection setup.
                 */
                Connection.prototype.createEntityManager = function () {
                    if (this.driver instanceof MongoDriver_4.MongoDriver)
                        return new MongoEntityManager_1.MongoEntityManager(this);
                    return new EntityManager_2.EntityManager(this);
                };
                /**
                 * Creates a new entity broadcaster using in this connection.
                 */
                Connection.prototype.createBroadcaster = function () {
                    return new Broadcaster_1.Broadcaster(this, this.entitySubscribers);
                };
                /**
                 * Creates a schema builder used to build a database schema for the entities of the current connection.
                 */
                Connection.prototype.createSchemaBuilder = function () {
                    return new SchemaBuilder_1.SchemaBuilder(this.driver, this.logger, this.entityMetadatas);
                };
                /**
                 * Creates a lazy relations wrapper.
                 */
                Connection.prototype.createLazyRelationsWrapper = function () {
                    return new LazyRelationsWrapper_1.LazyRelationsWrapper(this);
                };
                return Connection;
            }());
            exports_163("Connection", Connection);
        }
    };
});
System.register("typeorm/connection/error/ConnectionNotFoundError", [], function (exports_164, context_164) {
    "use strict";
    var __moduleName = context_164 && context_164.id;
    var ConnectionNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to get connection that does not exist.
             */
            ConnectionNotFoundError = (function (_super) {
                __extends(ConnectionNotFoundError, _super);
                function ConnectionNotFoundError(name) {
                    var _this = _super.call(this) || this;
                    _this.name = "ConnectionNotFoundError";
                    _this.message = "Connection \"" + name + "\" was not found.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return ConnectionNotFoundError;
            }(Error));
            exports_164("ConnectionNotFoundError", ConnectionNotFoundError);
        }
    };
});
System.register("typeorm/connection/ConnectionOptions", [], function (exports_165, context_165) {
    "use strict";
    var __moduleName = context_165 && context_165.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/MissingDriverError", [], function (exports_166, context_166) {
    "use strict";
    var __moduleName = context_166 && context_166.id;
    var MissingDriverError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer specifies driver type that does not exist or supported.
             */
            MissingDriverError = (function (_super) {
                __extends(MissingDriverError, _super);
                function MissingDriverError(driverType) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingDriverError";
                    _this.message = "Wrong driver " + driverType + " given. Supported drivers are: \"mysql\", \"postgres\", \"mssql\", \"oracle\", \"mariadb\", \"sqlite\".";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return MissingDriverError;
            }(Error));
            exports_166("MissingDriverError", MissingDriverError);
        }
    };
});
System.register("typeorm/connection/error/AlreadyHasActiveConnectionError", [], function (exports_167, context_167) {
    "use strict";
    var __moduleName = context_167 && context_167.id;
    var AlreadyHasActiveConnectionError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to recreate connection with the same name, but previous connection was not closed yet.
             */
            AlreadyHasActiveConnectionError = (function (_super) {
                __extends(AlreadyHasActiveConnectionError, _super);
                function AlreadyHasActiveConnectionError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "AlreadyHasActiveConnectionError";
                    _this.message = "Cannot create a new connection named \"" + connectionName + "\", because connection with such name " +
                        "already exist and it now has an active connection session.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return AlreadyHasActiveConnectionError;
            }(Error));
            exports_167("AlreadyHasActiveConnectionError", AlreadyHasActiveConnectionError);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/ColumnMetadata", "typeorm/schema-builder/schema/TableSchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_168, context_168) {
    "use strict";
    var __moduleName = context_168 && context_168.id;
    var TransactionAlreadyStartedError_5, TransactionNotStartedError_5, DataTypeNotSupportedByDriverError_5, ColumnSchema_8, ColumnMetadata_5, TableSchema_7, IndexSchema_5, ForeignKeySchema_6, PrimaryKeySchema_6, QueryRunnerAlreadyReleasedError_5, SqliteQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_5_1) {
                TransactionAlreadyStartedError_5 = TransactionAlreadyStartedError_5_1;
            },
            function (TransactionNotStartedError_5_1) {
                TransactionNotStartedError_5 = TransactionNotStartedError_5_1;
            },
            function (DataTypeNotSupportedByDriverError_5_1) {
                DataTypeNotSupportedByDriverError_5 = DataTypeNotSupportedByDriverError_5_1;
            },
            function (ColumnSchema_8_1) {
                ColumnSchema_8 = ColumnSchema_8_1;
            },
            function (ColumnMetadata_5_1) {
                ColumnMetadata_5 = ColumnMetadata_5_1;
            },
            function (TableSchema_7_1) {
                TableSchema_7 = TableSchema_7_1;
            },
            function (IndexSchema_5_1) {
                IndexSchema_5 = IndexSchema_5_1;
            },
            function (ForeignKeySchema_6_1) {
                ForeignKeySchema_6 = ForeignKeySchema_6_1;
            },
            function (PrimaryKeySchema_6_1) {
                PrimaryKeySchema_6 = PrimaryKeySchema_6_1;
            },
            function (QueryRunnerAlreadyReleasedError_5_1) {
                QueryRunnerAlreadyReleasedError_5 = QueryRunnerAlreadyReleasedError_5_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single sqlite database connection.
             *
             * Does not support compose primary keys with autoincrement field.
             * todo: need to throw exception for this case.
             */
            SqliteQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 */
                SqliteQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                SqliteQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_8;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.query("PRAGMA foreign_keys = OFF;")];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    _a.trys.push([3, 7, 9, 12]);
                                    selectDropsQuery = "select 'drop table ' || name || ';' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 4:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 5:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 6:
                                    _a.sent();
                                    return [3 /*break*/, 12];
                                case 7:
                                    error_8 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 8:
                                    _a.sent();
                                    throw error_8;
                                case 9: return [4 /*yield*/, this.release()];
                                case 10:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("PRAGMA foreign_keys = ON;")];
                                case 11:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 12: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                SqliteQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    if (this.databaseConnection.isTransactionActive)
                                        throw new TransactionAlreadyStartedError_5.TransactionAlreadyStartedError();
                                    this.databaseConnection.isTransactionActive = true;
                                    return [4 /*yield*/, this.query("BEGIN TRANSACTION")];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                SqliteQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("COMMIT")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                SqliteQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    if (!this.databaseConnection.isTransactionActive)
                                        throw new TransactionNotStartedError_5.TransactionNotStartedError();
                                    return [4 /*yield*/, this.query("ROLLBACK")];
                                case 1:
                                    _a.sent();
                                    this.databaseConnection.isTransactionActive = false;
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                SqliteQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                SqliteQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        _this.databaseConnection.connection.all(query, parameters, function (err, result) {
                            if (err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                fail(err);
                            }
                            else {
                                ok(result);
                            }
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                SqliteQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            sql = columns.length > 0 ? ("INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")") : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.logger.logQuery(sql, parameters);
                                    var __this = _this;
                                    _this.databaseConnection.connection.run(sql, parameters, function (err) {
                                        if (err) {
                                            __this.logger.logFailedQuery(sql, parameters);
                                            __this.logger.logQueryError(err);
                                            fail(err);
                                        }
                                        else {
                                            if (generatedColumn)
                                                return ok(this["lastID"]);
                                            ok();
                                        }
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                SqliteQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                SqliteQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                SqliteQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                SqliteQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                SqliteQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var _this = this;
                                            var tableSchema, _a, dbColumns, dbIndices, dbForeignKeys, autoIncrementColumnName, tableSql, comma, bracket, indicesPromises, indices;
                                            return __generator(this, function (_b) {
                                                switch (_b.label) {
                                                    case 0:
                                                        tableSchema = new TableSchema_7.TableSchema(dbTable["name"]);
                                                        return [4 /*yield*/, Promise.all([
                                                                this.query("PRAGMA table_info(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA index_list(\"" + dbTable["name"] + "\")"),
                                                                this.query("PRAGMA foreign_key_list(\"" + dbTable["name"] + "\")"),
                                                            ])];
                                                    case 1:
                                                        _a = _b.sent(), dbColumns = _a[0], dbIndices = _a[1], dbForeignKeys = _a[2];
                                                        autoIncrementColumnName = undefined;
                                                        tableSql = dbTable["sql"];
                                                        if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                            autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                            comma = autoIncrementColumnName.lastIndexOf(",");
                                                            bracket = autoIncrementColumnName.lastIndexOf("(");
                                                            if (comma !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                            else if (bracket !== -1) {
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                                autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                            }
                                                        }
                                                        // create column schemas from the loaded columns
                                                        tableSchema.columns = dbColumns.map(function (dbColumn) {
                                                            var columnSchema = new ColumnSchema_8.ColumnSchema();
                                                            columnSchema.name = dbColumn["name"];
                                                            columnSchema.type = dbColumn["type"].toLowerCase();
                                                            columnSchema.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                            columnSchema.isNullable = dbColumn["notnull"] === 0;
                                                            columnSchema.isPrimary = dbColumn["pk"] === 1;
                                                            columnSchema.comment = ""; // todo later
                                                            columnSchema.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                            var columnForeignKeys = dbForeignKeys
                                                                .filter(function (foreignKey) { return foreignKey["from"] === dbColumn["name"]; })
                                                                .map(function (foreignKey) {
                                                                var keyName = _this.driver.namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                                return new ForeignKeySchema_6.ForeignKeySchema(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                            });
                                                            tableSchema.addForeignKeys(columnForeignKeys);
                                                            return columnSchema;
                                                        });
                                                        // create primary key schema
                                                        return [4 /*yield*/, Promise.all(dbIndices
                                                                .filter(function (index) { return index["origin"] === "pk"; })
                                                                .map(function (index) { return __awaiter(_this, void 0, void 0, function () {
                                                                var indexInfos, indexColumns;
                                                                return __generator(this, function (_a) {
                                                                    switch (_a.label) {
                                                                        case 0: return [4 /*yield*/, this.query("PRAGMA index_info(\"" + index["name"] + "\")")];
                                                                        case 1:
                                                                            indexInfos = _a.sent();
                                                                            indexColumns = indexInfos.map(function (indexInfo) { return indexInfo["name"]; });
                                                                            indexColumns.forEach(function (indexColumn) {
                                                                                tableSchema.primaryKeys.push(new PrimaryKeySchema_6.PrimaryKeySchema(index["name"], indexColumn));
                                                                            });
                                                                            return [2 /*return*/];
                                                                    }
                                                                });
                                                            }); }))];
                                                    case 2:
                                                        // create primary key schema
                                                        _b.sent();
                                                        indicesPromises = dbIndices
                                                            .filter(function (dbIndex) {
                                                            return dbIndex["origin"] !== "pk" &&
                                                                (!tableSchema.foreignKeys.find(function (foreignKey) { return foreignKey.name === dbIndex["name"]; })) &&
                                                                (!tableSchema.primaryKeys.find(function (primaryKey) { return primaryKey.name === dbIndex["name"]; }));
                                                        })
                                                            .map(function (dbIndex) { return dbIndex["name"]; })
                                                            .filter(function (value, index, self) { return self.indexOf(value) === index; }) // unqiue
                                                            .map(function (dbIndexName) { return __awaiter(_this, void 0, void 0, function () {
                                                            var dbIndex, indexInfos, indexColumns;
                                                            return __generator(this, function (_a) {
                                                                switch (_a.label) {
                                                                    case 0:
                                                                        dbIndex = dbIndices.find(function (dbIndex) { return dbIndex["name"] === dbIndexName; });
                                                                        return [4 /*yield*/, this.query("PRAGMA index_info(\"" + dbIndex["name"] + "\")")];
                                                                    case 1:
                                                                        indexInfos = _a.sent();
                                                                        indexColumns = indexInfos.map(function (indexInfo) { return indexInfo["name"]; });
                                                                        // check if db index is generated by sqlite itself and has special use case
                                                                        if (dbIndex["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                                            if (dbIndex["unique"] === 1) {
                                                                                // so we find and update the column
                                                                                indexColumns.forEach(function (columnName) {
                                                                                    var column = tableSchema.columns.find(function (column) { return column.name === columnName; });
                                                                                    if (column)
                                                                                        column.isUnique = true;
                                                                                });
                                                                            }
                                                                            return [2 /*return*/, Promise.resolve(undefined)];
                                                                        }
                                                                        else {
                                                                            return [2 /*return*/, new IndexSchema_5.IndexSchema(dbTable["name"], dbIndex["name"], indexColumns, dbIndex["unique"] === "1")];
                                                                        }
                                                                        return [2 /*return*/];
                                                                }
                                                            });
                                                        }); });
                                                        return [4 /*yield*/, Promise.all(indicesPromises)];
                                                    case 3:
                                                        indices = _b.sent();
                                                        tableSchema.indices = indices.filter(function (index) { return !!index; });
                                                        return [2 /*return*/, tableSchema];
                                                }
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                SqliteQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM sqlite_master WHERE type = 'table' AND name = '" + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                SqliteQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generates a wrong schema
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                SqliteQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "PRAGMA table_info(\"" + tableName + "\")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    columns = _a.sent();
                                    return [2 /*return*/, !!columns.find(function (column) { return column["name"] === columnName; })];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                SqliteQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns([column]);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                SqliteQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns(columns);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                SqliteQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_7.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                SqliteQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_7.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_8.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    // todo: fix it. it should not depend on tableSchema
                                    return [2 /*return*/, this.recreateTable(tableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 * Changed column looses all its keys in the db.
                 */
                SqliteQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            // todo: fix it. it should not depend on tableSchema
                            return [2 /*return*/, this.recreateTable(tableSchema)];
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                SqliteQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropColumns(tableSchemaOrName, [columnSchemaOrName])];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                SqliteQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, updatingTableSchema, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    updatingTableSchema = tableSchema.clone();
                                    columns = columnSchemasOrNames.map(function (columnSchemasOrName) {
                                        if (typeof columnSchemasOrName === "string") {
                                            var column = tableSchema.columns.find(function (column) { return column.name === columnSchemasOrName; });
                                            if (!column)
                                                throw new Error("Cannot drop a column - column \"" + columnSchemasOrName + "\" was not found in the \"" + tableSchema.name + "\" table.");
                                            return column;
                                        }
                                        else {
                                            return columnSchemasOrName;
                                        }
                                    });
                                    updatingTableSchema.removeColumns(columns);
                                    return [2 /*return*/, this.recreateTable(updatingTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                SqliteQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.recreateTable(dbTable)];
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                SqliteQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.createForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                SqliteQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.addForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                SqliteQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.dropForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                SqliteQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.removeForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                SqliteQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                SqliteQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_5.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                SqliteQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_5.DataTypeNotSupportedByDriverError(typeOptions.type, "SQLite");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                SqliteQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                SqliteQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DELETE FROM " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                SqliteQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                SqliteQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\"";
                    if (column instanceof ColumnMetadata_5.ColumnMetadata) {
                        c += " " + this.normalizeType(column);
                    }
                    else {
                        c += " " + column.type;
                    }
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated === true)
                        c += " PRIMARY KEY AUTOINCREMENT";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "1" : "0") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                SqliteQueryRunner.prototype.recreateTable = function (tableSchema, oldTableSchema, migrateData) {
                    if (migrateData === void 0) { migrateData = true; }
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, columnNames, sql1, primaryKeyColumns, oldColumnNames, sql2, sql3, sql4, indexPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = tableSchema.columns.map(function (dbColumn) { return _this.buildCreateColumnSql(dbColumn); }).join(", ");
                                    columnNames = tableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ");
                                    sql1 = "CREATE TABLE \"temporary_" + tableSchema.name + "\" (" + columnDefinitions;
                                    // if (options && options.createForeignKeys) {
                                    tableSchema.foreignKeys.forEach(function (foreignKey) {
                                        var columnNames = foreignKey.columnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        var referencedColumnNames = foreignKey.referencedColumnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        sql1 += ", FOREIGN KEY(" + columnNames + ") REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")";
                                        if (foreignKey.onDelete)
                                            sql1 += " ON DELETE " + foreignKey.onDelete;
                                    });
                                    primaryKeyColumns = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql1 += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generate a wrong schema
                                    sql1 += ")";
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    return [4 /*yield*/, this.query(sql1)];
                                case 1:
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    _a.sent();
                                    oldColumnNames = oldTableSchema ? oldTableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") : columnNames;
                                    if (!migrateData) return [3 /*break*/, 3];
                                    sql2 = "INSERT INTO \"temporary_" + tableSchema.name + "\"(" + oldColumnNames + ") SELECT " + oldColumnNames + " FROM \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql2)];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    sql3 = "DROP TABLE \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql3)];
                                case 4:
                                    _a.sent();
                                    sql4 = "ALTER TABLE \"temporary_" + tableSchema.name + "\" RENAME TO \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql4)];
                                case 5:
                                    _a.sent();
                                    indexPromises = tableSchema.indices.map(function (index) { return _this.createIndex(tableSchema.name, index); });
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    return [4 /*yield*/, Promise.all(indexPromises /*.concat(uniquePromises)*/)];
                                case 6:
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * If given value is a table name then it loads its table schema representation from the database.
                 */
                SqliteQueryRunner.prototype.getTableSchema = function (tableSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(tableSchemaOrName instanceof TableSchema_7.TableSchema)) return [3 /*break*/, 1];
                                    return [2 /*return*/, tableSchemaOrName];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    if (!tableSchema)
                                        throw new Error("Table named " + tableSchemaOrName + " was not found in the database.");
                                    return [2 /*return*/, tableSchema];
                            }
                        });
                    });
                };
                return SqliteQueryRunner;
            }());
            exports_168("SqliteQueryRunner", SqliteQueryRunner);
        }
    };
});
System.register("typeorm/driver/sqlite/SqliteDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/error/DriverPackageNotInstalledError", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/sqlite/SqliteQueryRunner", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/platform/PlatformTools"], function (exports_169, context_169) {
    "use strict";
    var __moduleName = context_169 && context_169.id;
    var ConnectionIsNotSetError_6, DriverPackageNotInstalledError_6, ColumnTypes_8, SqliteQueryRunner_1, DriverOptionNotSetError_6, DataTransformationUtils_6, PlatformTools_9, SqliteDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_6_1) {
                ConnectionIsNotSetError_6 = ConnectionIsNotSetError_6_1;
            },
            function (DriverPackageNotInstalledError_6_1) {
                DriverPackageNotInstalledError_6 = DriverPackageNotInstalledError_6_1;
            },
            function (ColumnTypes_8_1) {
                ColumnTypes_8 = ColumnTypes_8_1;
            },
            function (SqliteQueryRunner_1_1) {
                SqliteQueryRunner_1 = SqliteQueryRunner_1_1;
            },
            function (DriverOptionNotSetError_6_1) {
                DriverOptionNotSetError_6 = DriverOptionNotSetError_6_1;
            },
            function (DataTransformationUtils_6_1) {
                DataTransformationUtils_6 = DataTransformationUtils_6_1;
            },
            function (PlatformTools_9_1) {
                PlatformTools_9 = PlatformTools_9_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with sqlite DBMS.
             */
            SqliteDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function SqliteDriver(connectionOptions, logger, sqlite) {
                    this.options = connectionOptions;
                    this.logger = logger;
                    this.sqlite = sqlite;
                    // validate options to make sure everything is set
                    if (!this.options.storage)
                        throw new DriverOptionNotSetError_6.DriverOptionNotSetError("storage");
                    // if sqlite package instance was not set explicitly then try to load it
                    if (!sqlite)
                        this.loadDependencies();
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 */
                SqliteDriver.prototype.connect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        var connection = new _this.sqlite.Database(_this.options.storage, function (err) {
                            if (err)
                                return fail(err);
                            _this.databaseConnection = {
                                id: 1,
                                connection: connection,
                                isTransactionActive: false
                            };
                            // we need to enable foreign keys in sqlite to make sure all foreign key related features
                            // working properly. this also makes onDelete to work with sqlite.
                            connection.run("PRAGMA foreign_keys = ON;", function (err, result) {
                                ok();
                            });
                        });
                    });
                };
                /**
                 * Closes connection with database.
                 */
                SqliteDriver.prototype.disconnect = function () {
                    var _this = this;
                    return new Promise(function (ok, fail) {
                        var handler = function (err) { return err ? fail(err) : ok(); };
                        if (!_this.databaseConnection)
                            return fail(new ConnectionIsNotSetError_6.ConnectionIsNotSetError("sqlite"));
                        _this.databaseConnection.connection.close(handler);
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                SqliteDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_6.ConnectionIsNotSetError("sqlite"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new SqliteQueryRunner_1.SqliteQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                SqliteDriver.prototype.nativeInterface = function () {
                    return {
                        driver: this.sqlite,
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined
                    };
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                SqliteDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_8.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_8.ColumnTypes.DATE:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_8.ColumnTypes.TIME:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_8.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_6.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_6.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_8.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_8.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_6.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                SqliteDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_8.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_8.ColumnTypes.DATETIME:
                            return DataTransformationUtils_6.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_8.ColumnTypes.DATE:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_8.ColumnTypes.TIME:
                            return DataTransformationUtils_6.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_8.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_8.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_6.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                SqliteDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var builtParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        var value = parameters[key.substr(1)];
                        if (value instanceof Array) {
                            return value.map(function (v) {
                                builtParameters.push(v);
                                return "$" + builtParameters.length;
                            }).join(", ");
                        }
                        else {
                            builtParameters.push(value);
                        }
                        return "$" + builtParameters.length;
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, builtParameters];
                };
                /**
                 * Escapes a column name.
                 */
                SqliteDriver.prototype.escapeColumnName = function (columnName) {
                    return "\"" + columnName + "\"";
                };
                /**
                 * Escapes an alias.
                 */
                SqliteDriver.prototype.escapeAliasName = function (aliasName) {
                    return "\"" + aliasName + "\"";
                };
                /**
                 * Escapes a table name.
                 */
                SqliteDriver.prototype.escapeTableName = function (tableName) {
                    return "\"" + tableName + "\"";
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                SqliteDriver.prototype.retrieveDatabaseConnection = function () {
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_6.ConnectionIsNotSetError("sqlite");
                };
                /**
                 * If driver dependency is not given explicitly, then try to load it via "require".
                 */
                SqliteDriver.prototype.loadDependencies = function () {
                    try {
                        this.sqlite = PlatformTools_9.PlatformTools.load("sqlite3").verbose();
                    }
                    catch (e) {
                        throw new DriverPackageNotInstalledError_6.DriverPackageNotInstalledError("SQLite", "sqlite3");
                    }
                };
                return SqliteDriver;
            }());
            exports_169("SqliteDriver", SqliteDriver);
        }
    };
});
System.register("typeorm/connection/error/CannotDetermineConnectionOptionsError", [], function (exports_170, context_170) {
    "use strict";
    var __moduleName = context_170 && context_170.id;
    var CannotDetermineConnectionOptionsError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when connection is trying to be created automatically from connection options found in the ormconfig.json
             * or environment variables, but failed due to missing these configurations.
             */
            CannotDetermineConnectionOptionsError = (function (_super) {
                __extends(CannotDetermineConnectionOptionsError, _super);
                function CannotDetermineConnectionOptionsError() {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotDetermineConnectionOptionsError";
                    _this.message = "Cannot create connection, because connection options are missing. " +
                        "You either need to explicitly pass connection options, either create a ormconfig.json with connection options " +
                        "and \"default\" connection name, either to set proper environment variables. Also, if you are using environment-specific " +
                        "configurations in your ormconfig.json make sure your are running under correct NODE_ENV.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotDetermineConnectionOptionsError;
            }(Error));
            exports_170("CannotDetermineConnectionOptionsError", CannotDetermineConnectionOptionsError);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlQueryRunner", ["typeorm/driver/error/TransactionAlreadyStartedError", "typeorm/driver/error/TransactionNotStartedError", "typeorm/driver/error/DataTypeNotSupportedByDriverError", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/metadata/ColumnMetadata", "typeorm/schema-builder/schema/TableSchema", "typeorm/query-runner/error/QueryRunnerAlreadyReleasedError"], function (exports_171, context_171) {
    "use strict";
    var __moduleName = context_171 && context_171.id;
    var TransactionAlreadyStartedError_6, TransactionNotStartedError_6, DataTypeNotSupportedByDriverError_6, ColumnSchema_9, ColumnMetadata_6, TableSchema_8, QueryRunnerAlreadyReleasedError_6, WebsqlQueryRunner;
    return {
        setters: [
            function (TransactionAlreadyStartedError_6_1) {
                TransactionAlreadyStartedError_6 = TransactionAlreadyStartedError_6_1;
            },
            function (TransactionNotStartedError_6_1) {
                TransactionNotStartedError_6 = TransactionNotStartedError_6_1;
            },
            function (DataTypeNotSupportedByDriverError_6_1) {
                DataTypeNotSupportedByDriverError_6 = DataTypeNotSupportedByDriverError_6_1;
            },
            function (ColumnSchema_9_1) {
                ColumnSchema_9 = ColumnSchema_9_1;
            },
            function (ColumnMetadata_6_1) {
                ColumnMetadata_6 = ColumnMetadata_6_1;
            },
            function (TableSchema_8_1) {
                TableSchema_8 = TableSchema_8_1;
            },
            function (QueryRunnerAlreadyReleasedError_6_1) {
                QueryRunnerAlreadyReleasedError_6 = QueryRunnerAlreadyReleasedError_6_1;
            }
        ],
        execute: function () {
            /**
             * Runs queries on a single websql database connection.
             */
            WebsqlQueryRunner = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlQueryRunner(databaseConnection, driver, logger) {
                    this.databaseConnection = databaseConnection;
                    this.driver = driver;
                    this.logger = logger;
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * Indicates if connection for this query runner is released.
                     * Once its released, query runner cannot run queries anymore.
                     */
                    this.isReleased = false;
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Releases database connection. This is needed when using connection pooling.
                 * If connection is not from a pool, it should not be released.
                 * You cannot use this class's methods after its released.
                 */
                WebsqlQueryRunner.prototype.release = function () {
                    if (this.databaseConnection.releaseCallback) {
                        this.isReleased = true;
                        return this.databaseConnection.releaseCallback();
                    }
                    return Promise.resolve();
                };
                /**
                 * Removes all tables from the currently connected database.
                 */
                WebsqlQueryRunner.prototype.clearDatabase = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var selectDropsQuery, dropQueries, error_9;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    // await this.query(`PRAGMA foreign_keys = OFF;`);
                                    return [4 /*yield*/, this.beginTransaction()];
                                case 1:
                                    // await this.query(`PRAGMA foreign_keys = OFF;`);
                                    _a.sent();
                                    _a.label = 2;
                                case 2:
                                    _a.trys.push([2, 6, 8, 10]);
                                    selectDropsQuery = "select 'drop table ' || name || ';' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'";
                                    return [4 /*yield*/, this.query(selectDropsQuery)];
                                case 3:
                                    dropQueries = _a.sent();
                                    return [4 /*yield*/, Promise.all(dropQueries.map(function (q) { return _this.query(q["query"]); }))];
                                case 4:
                                    _a.sent();
                                    return [4 /*yield*/, this.commitTransaction()];
                                case 5:
                                    _a.sent();
                                    return [3 /*break*/, 10];
                                case 6:
                                    error_9 = _a.sent();
                                    return [4 /*yield*/, this.rollbackTransaction()];
                                case 7:
                                    _a.sent();
                                    throw error_9;
                                case 8: return [4 /*yield*/, this.release()];
                                case 9:
                                    _a.sent();
                                    return [7 /*endfinally*/];
                                case 10: return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Starts transaction.
                 */
                WebsqlQueryRunner.prototype.beginTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (this.databaseConnection.isTransactionActive)
                                throw new TransactionAlreadyStartedError_6.TransactionAlreadyStartedError();
                            this.databaseConnection.isTransactionActive = true;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Commits transaction.
                 */
                WebsqlQueryRunner.prototype.commitTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("COMMIT");
                            this.databaseConnection.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Rollbacks transaction.
                 */
                WebsqlQueryRunner.prototype.rollbackTransaction = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            if (!this.databaseConnection.isTransactionActive)
                                throw new TransactionNotStartedError_6.TransactionNotStartedError();
                            // await this.query("ROLLBACK");
                            this.databaseConnection.isTransactionActive = false;
                            return [2 /*return*/];
                        });
                    });
                };
                /**
                 * Checks if transaction is in progress.
                 */
                WebsqlQueryRunner.prototype.isTransactionActive = function () {
                    return this.databaseConnection.isTransactionActive;
                };
                /**
                 * Executes a given SQL query.
                 */
                WebsqlQueryRunner.prototype.query = function (query, parameters) {
                    var _this = this;
                    if (this.isReleased)
                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                    return new Promise(function (ok, fail) {
                        _this.logger.logQuery(query, parameters);
                        var db = _this.databaseConnection.connection;
                        // todo: check if transaction is not active
                        db.transaction(function (tx) {
                            tx.executeSql(query, parameters, function (tx, result) {
                                var rows = Object
                                    .keys(result.rows)
                                    .filter(function (key) { return key !== "length"; })
                                    .map(function (key) { return result.rows[key]; });
                                ok(rows);
                            }, function (tx, err) {
                                _this.logger.logFailedQuery(query, parameters);
                                _this.logger.logQueryError(err);
                                return fail(err);
                            });
                        });
                    });
                };
                /**
                 * Insert a new row into given table.
                 */
                WebsqlQueryRunner.prototype.insert = function (tableName, keyValues, generatedColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var keys, columns, values, sql, parameters;
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            keys = Object.keys(keyValues);
                            columns = keys.map(function (key) { return _this.driver.escapeColumnName(key); }).join(", ");
                            values = keys.map(function (key, index) { return "$" + (index + 1); }).join(",");
                            sql = columns.length > 0 ? ("INSERT INTO " + this.driver.escapeTableName(tableName) + "(" + columns + ") VALUES (" + values + ")") : "INSERT INTO " + this.driver.escapeTableName(tableName) + " DEFAULT VALUES";
                            parameters = keys.map(function (key) { return keyValues[key]; });
                            return [2 /*return*/, new Promise(function (ok, fail) {
                                    _this.logger.logQuery(sql, parameters);
                                    var db = _this.databaseConnection.connection;
                                    // todo: check if transaction is not active
                                    db.transaction(function (tx) {
                                        tx.executeSql(sql, parameters, function (tx, result) {
                                            if (generatedColumn)
                                                return ok(result["insertId"]);
                                            ok();
                                        }, function (tx, err) {
                                            _this.logger.logFailedQuery(sql, parameters);
                                            _this.logger.logQueryError(err);
                                            return fail(err);
                                        });
                                    });
                                })];
                        });
                    });
                };
                /**
                 * Updates rows that match given conditions in the given table.
                 */
                WebsqlQueryRunner.prototype.update = function (tableName, valuesMap, conditions) {
                    return __awaiter(this, void 0, void 0, function () {
                        var updateValues, conditionString, query, updateParams, conditionParams, allParameters;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    updateValues = this.parametrize(valuesMap).join(", ");
                                    conditionString = this.parametrize(conditions, Object.keys(valuesMap).length).join(" AND ");
                                    query = "UPDATE " + this.driver.escapeTableName(tableName) + " SET " + updateValues + " " + (conditionString ? (" WHERE " + conditionString) : "");
                                    updateParams = Object.keys(valuesMap).map(function (key) { return valuesMap[key]; });
                                    conditionParams = Object.keys(conditions).map(function (key) { return conditions[key]; });
                                    allParameters = updateParams.concat(conditionParams);
                                    return [4 /*yield*/, this.query(query, allParameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Deletes from the given table by a given conditions.
                 */
                WebsqlQueryRunner.prototype.delete = function (tableName, conditions, maybeParameters) {
                    return __awaiter(this, void 0, void 0, function () {
                        var conditionString, parameters, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    conditionString = typeof conditions === "string" ? conditions : this.parametrize(conditions).join(" AND ");
                                    parameters = conditions instanceof Object ? Object.keys(conditions).map(function (key) { return conditions[key]; }) : maybeParameters;
                                    sql = "DELETE FROM " + this.driver.escapeTableName(tableName) + " WHERE " + conditionString;
                                    return [4 /*yield*/, this.query(sql, parameters)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Inserts rows into closure table.
                 */
                WebsqlQueryRunner.prototype.insertIntoClosureTable = function (tableName, newEntityId, parentId, hasLevel) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, results;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    sql = "";
                                    if (hasLevel) {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant, level) " +
                                            ("SELECT ancestor, " + newEntityId + ", level + 1 FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId + ", 1");
                                    }
                                    else {
                                        sql = "INSERT INTO " + this.driver.escapeTableName(tableName) + "(ancestor, descendant) " +
                                            ("SELECT ancestor, " + newEntityId + " FROM " + this.driver.escapeTableName(tableName) + " WHERE descendant = " + parentId + " ") +
                                            ("UNION ALL SELECT " + newEntityId + ", " + newEntityId);
                                    }
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/, this.query("SELECT MAX(level) as level FROM " + tableName + " WHERE descendant = " + parentId)];
                                case 2:
                                    results = _a.sent();
                                    return [2 /*return*/, results && results[0] && results[0]["level"] ? parseInt(results[0]["level"]) + 1 : 1];
                            }
                        });
                    });
                };
                /**
                 * Loads given table's data from the database.
                 */
                WebsqlQueryRunner.prototype.loadTableSchema = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchemas;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.loadTableSchemas([tableName])];
                                case 1:
                                    tableSchemas = _a.sent();
                                    return [2 /*return*/, tableSchemas.length > 0 ? tableSchemas[0] : undefined];
                            }
                        });
                    });
                };
                /**
                 * Loads all tables (with given names) from the database and creates a TableSchema from them.
                 */
                WebsqlQueryRunner.prototype.loadTableSchemas = function (tableNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var tableNamesString, dbTables;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    // if no tables given then no need to proceed
                                    if (!tableNames || !tableNames.length)
                                        return [2 /*return*/, []];
                                    tableNamesString = tableNames.map(function (tableName) { return "'" + tableName + "'"; }).join(", ");
                                    return [4 /*yield*/, this.query("SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (" + tableNamesString + ")")];
                                case 1:
                                    dbTables = _a.sent();
                                    // if tables were not found in the db, no need to proceed
                                    if (!dbTables || !dbTables.length)
                                        return [2 /*return*/, []];
                                    // create table schemas for loaded tables
                                    return [2 /*return*/, Promise.all(dbTables.map(function (dbTable) { return __awaiter(_this, void 0, void 0, function () {
                                            var tableSchema;
                                            return __generator(this, function (_a) {
                                                tableSchema = new TableSchema_8.TableSchema(dbTable["name"]);
                                                // load columns and indices
                                                /*const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([
                                                    this.query(`PRAGMA table_info("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA index_list("${dbTable["name"]}")`),
                                                    this.query(`PRAGMA foreign_key_list("${dbTable["name"]}")`),
                                                ]);
                                    
                                                // find column name with auto increment
                                                let autoIncrementColumnName: string|undefined = undefined;
                                                const tableSql: string = dbTable["sql"];
                                                if (tableSql.indexOf("AUTOINCREMENT") !== -1) {
                                                    autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf("AUTOINCREMENT"));
                                                    const comma = autoIncrementColumnName.lastIndexOf(",");
                                                    const bracket = autoIncrementColumnName.lastIndexOf("(");
                                                    if (comma !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(comma);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                    
                                                    } else if (bracket !== -1) {
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(bracket);
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf("\""));
                                                        autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf("\"") + 1);
                                                    }
                                                }
                                    
                                                // create column schemas from the loaded columns
                                                tableSchema.columns = dbColumns.map(dbColumn => {
                                                    const columnSchema = new ColumnSchema();
                                                    columnSchema.name = dbColumn["name"];
                                                    columnSchema.type = dbColumn["type"].toLowerCase();
                                                    columnSchema.default = dbColumn["dflt_value"] !== null && dbColumn["dflt_value"] !== undefined ? dbColumn["dflt_value"] : undefined;
                                                    columnSchema.isNullable = dbColumn["notnull"] === 0;
                                                    columnSchema.isPrimary = dbColumn["pk"] === 1;
                                                    columnSchema.comment = ""; // todo later
                                                    columnSchema.isGenerated = autoIncrementColumnName === dbColumn["name"];
                                                    const columnForeignKeys = dbForeignKeys
                                                        .filter(foreignKey => foreignKey["from"] === dbColumn["name"])
                                                        .map(foreignKey => {
                                                            const keyName = namingStrategy.foreignKeyName(dbTable["name"], [foreignKey["from"]], foreignKey["table"], [foreignKey["to"]]);
                                                            return new ForeignKeySchema(keyName, [foreignKey["from"]], [foreignKey["to"]], foreignKey["table"], foreignKey["on_delete"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)
                                                        });
                                                    tableSchema.addForeignKeys(columnForeignKeys);
                                                    return columnSchema;
                                                });
                                    
                                                // create primary key schema
                                                await Promise.all(dbIndices
                                                    .filter(index => index["origin"] === "pk")
                                                    .map(async index => {
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${index["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                                        indexColumns.forEach(indexColumn => {
                                                            tableSchema.primaryKeys.push(new PrimaryKeySchema(index["name"], indexColumn));
                                                        });
                                                    }));
                                    
                                                // create index schemas from the loaded indices
                                                const indicesPromises = dbIndices
                                                    .filter(dbIndex => {
                                                        return  dbIndex["origin"] !== "pk" &&
                                                            (!tableSchema.foreignKeys.find(foreignKey => foreignKey.name === dbIndex["name"])) &&
                                                            (!tableSchema.primaryKeys.find(primaryKey => primaryKey.name === dbIndex["name"]));
                                                    })
                                                    .map(dbIndex => dbIndex["name"])
                                                    .filter((value, index, self) => self.indexOf(value) === index) // unqiue
                                                    .map(async dbIndexName => {
                                                        const dbIndex = dbIndices.find(dbIndex => dbIndex["name"] === dbIndexName);
                                                        const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info("${dbIndex!["name"]}")`);
                                                        const indexColumns = indexInfos.map(indexInfo => indexInfo["name"]);
                                    
                                                        // check if db index is generated by sqlite itself and has special use case
                                                        if (dbIndex!["name"].substr(0, "sqlite_autoindex".length) === "sqlite_autoindex") {
                                                            if (dbIndex!["unique"] === 1) { // this means we have a special index generated for a column
                                                                // so we find and update the column
                                                                indexColumns.forEach(columnName => {
                                                                    const column = tableSchema.columns.find(column => column.name === columnName);
                                                                    if (column)
                                                                        column.isUnique = true;
                                                                });
                                                            }
                                    
                                                            return Promise.resolve(undefined);
                                    
                                                        } else {
                                                            return new IndexSchema(dbTable["name"], dbIndex!["name"], indexColumns, dbIndex!["unique"] === "1");
                                                        }
                                                    });
                                    
                                                const indices = await Promise.all(indicesPromises);
                                                tableSchema.indices = indices.filter(index => !!index) as IndexSchema[];*/
                                                return [2 /*return*/, tableSchema];
                                            });
                                        }); }))];
                            }
                        });
                    });
                };
                /**
                 * Checks if table with the given name exist in the database.
                 */
                WebsqlQueryRunner.prototype.hasTable = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "SELECT * FROM sqlite_master WHERE type = 'table' AND name = " + tableName + "'";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    result = _a.sent();
                                    return [2 /*return*/, result.length ? true : false];
                            }
                        });
                    });
                };
                /**
                 * Creates a new table from the given table metadata and column metadatas.
                 */
                WebsqlQueryRunner.prototype.createTable = function (table) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, sql, primaryKeyColumns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    columnDefinitions = table.columns.map(function (column) { return _this.buildCreateColumnSql(column); }).join(", ");
                                    sql = "CREATE TABLE \"" + table.name + "\" (" + columnDefinitions;
                                    primaryKeyColumns = table.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generates a wrong schema
                                    sql += ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Checks if column with the given name exist in the given table.
                 */
                WebsqlQueryRunner.prototype.hasColumn = function (tableName, columnName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    sql = "PRAGMA table_info(\"" + tableName + "\")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    columns = _a.sent();
                                    return [2 /*return*/, !!columns.find(function (column) { return column["name"] === columnName; })];
                            }
                        });
                    });
                };
                /**
                 * Creates a new column from the column schema in the table.
                 */
                WebsqlQueryRunner.prototype.addColumn = function (tableSchemaOrName, column) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns([column]);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a new columns from the column schema in the table.
                 */
                WebsqlQueryRunner.prototype.addColumns = function (tableSchemaOrName, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, newTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    newTableSchema = tableSchema.clone();
                                    newTableSchema.addColumns(columns);
                                    return [4 /*yield*/, this.recreateTable(newTableSchema, tableSchema)];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Renames column in the given table.
                 */
                WebsqlQueryRunner.prototype.renameColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn, newColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    newColumn = undefined;
                                    if (newColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        newColumn = newColumnSchemaOrName;
                                    }
                                    else {
                                        newColumn = oldColumn.clone();
                                        newColumn.name = newColumnSchemaOrName;
                                    }
                                    return [2 /*return*/, this.changeColumn(tableSchema, oldColumn, newColumn)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 */
                WebsqlQueryRunner.prototype.changeColumn = function (tableSchemaOrName, oldColumnSchemaOrName, newColumn) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, oldColumn;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    tableSchema = undefined;
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    tableSchema = tableSchemaOrName;
                                    return [3 /*break*/, 3];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!tableSchema)
                                        throw new Error("Table " + tableSchemaOrName + " was not found.");
                                    oldColumn = undefined;
                                    if (oldColumnSchemaOrName instanceof ColumnSchema_9.ColumnSchema) {
                                        oldColumn = oldColumnSchemaOrName;
                                    }
                                    else {
                                        oldColumn = tableSchema.columns.find(function (column) { return column.name === oldColumnSchemaOrName; });
                                    }
                                    if (!oldColumn)
                                        throw new Error("Column \"" + oldColumnSchemaOrName + "\" was not found in the \"" + tableSchemaOrName + "\" table.");
                                    // todo: fix it. it should not depend on tableSchema
                                    return [2 /*return*/, this.recreateTable(tableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Changes a column in the table.
                 * Changed column looses all its keys in the db.
                 */
                WebsqlQueryRunner.prototype.changeColumns = function (tableSchema, changedColumns) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            // todo: fix it. it should not depend on tableSchema
                            return [2 /*return*/, this.recreateTable(tableSchema)];
                        });
                    });
                };
                /**
                 * Drops column in the table.
                 */
                WebsqlQueryRunner.prototype.dropColumn = function (tableSchemaOrName, columnSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.dropColumns(tableSchemaOrName, [columnSchemaOrName])];
                        });
                    });
                };
                /**
                 * Drops the columns in the table.
                 */
                WebsqlQueryRunner.prototype.dropColumns = function (tableSchemaOrName, columnSchemasOrNames) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, updatingTableSchema, columns;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    updatingTableSchema = tableSchema.clone();
                                    columns = columnSchemasOrNames.map(function (columnSchemasOrName) {
                                        if (typeof columnSchemasOrName === "string") {
                                            var column = tableSchema.columns.find(function (column) { return column.name === columnSchemasOrName; });
                                            if (!column)
                                                throw new Error("Cannot drop a column - column \"" + columnSchemasOrName + "\" was not found in the \"" + tableSchema.name + "\" table.");
                                            return column;
                                        }
                                        else {
                                            return columnSchemasOrName;
                                        }
                                    });
                                    updatingTableSchema.removeColumns(columns);
                                    return [2 /*return*/, this.recreateTable(updatingTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Updates table's primary keys.
                 */
                WebsqlQueryRunner.prototype.updatePrimaryKeys = function (dbTable) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.recreateTable(dbTable)];
                        });
                    });
                };
                /**
                 * Creates a new foreign key.
                 */
                WebsqlQueryRunner.prototype.createForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.createForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Creates a new foreign keys.
                 */
                WebsqlQueryRunner.prototype.createForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.addForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Drops a foreign key from the table.
                 */
                WebsqlQueryRunner.prototype.dropForeignKey = function (tableSchemaOrName, foreignKey) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            if (this.isReleased)
                                throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                            return [2 /*return*/, this.dropForeignKeys(tableSchemaOrName, [foreignKey])];
                        });
                    });
                };
                /**
                 * Drops a foreign keys from the table.
                 */
                WebsqlQueryRunner.prototype.dropForeignKeys = function (tableSchemaOrName, foreignKeys) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema, changedTableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    return [4 /*yield*/, this.getTableSchema(tableSchemaOrName)];
                                case 1:
                                    tableSchema = _a.sent();
                                    changedTableSchema = tableSchema.clone();
                                    changedTableSchema.removeForeignKeys(foreignKeys);
                                    return [2 /*return*/, this.recreateTable(changedTableSchema)];
                            }
                        });
                    });
                };
                /**
                 * Creates a new index.
                 */
                WebsqlQueryRunner.prototype.createIndex = function (tableName, index) {
                    return __awaiter(this, void 0, void 0, function () {
                        var columnNames, sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    columnNames = index.columnNames.map(function (columnName) { return "\"" + columnName + "\""; }).join(",");
                                    sql = "CREATE " + (index.isUnique ? "UNIQUE " : "") + "INDEX \"" + index.name + "\" ON \"" + tableName + "\"(" + columnNames + ")";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Drops an index from the table.
                 */
                WebsqlQueryRunner.prototype.dropIndex = function (tableName, indexName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var sql;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (this.isReleased)
                                        throw new QueryRunnerAlreadyReleasedError_6.QueryRunnerAlreadyReleasedError();
                                    sql = "DROP INDEX \"" + indexName + "\"";
                                    return [4 /*yield*/, this.query(sql)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * Creates a database type from a given column metadata.
                 */
                WebsqlQueryRunner.prototype.normalizeType = function (typeOptions) {
                    switch (typeOptions.type) {
                        case "string":
                            return "character varying(" + (typeOptions.length ? typeOptions.length : 255) + ")";
                        case "text":
                            return "text";
                        case "boolean":
                            return "boolean";
                        case "integer":
                        case "int":
                            return "integer";
                        case "smallint":
                            return "smallint";
                        case "bigint":
                            return "bigint";
                        case "float":
                            return "real";
                        case "double":
                        case "number":
                            return "double precision";
                        case "decimal":
                            if (typeOptions.precision && typeOptions.scale) {
                                return "decimal(" + typeOptions.precision + "," + typeOptions.scale + ")";
                            }
                            else if (typeOptions.scale) {
                                return "decimal(" + typeOptions.scale + ")";
                            }
                            else if (typeOptions.precision) {
                                return "decimal(" + typeOptions.precision + ")";
                            }
                            else {
                                return "decimal";
                            }
                        case "date":
                            return "date";
                        case "time":
                            if (typeOptions.timezone) {
                                return "time with time zone";
                            }
                            else {
                                return "time without time zone";
                            }
                        case "datetime":
                            if (typeOptions.timezone) {
                                return "timestamp with time zone";
                            }
                            else {
                                return "timestamp without time zone";
                            }
                        case "json":
                            return "json";
                        case "simple_array":
                            return typeOptions.length ? "character varying(" + typeOptions.length + ")" : "text";
                    }
                    throw new DataTypeNotSupportedByDriverError_6.DataTypeNotSupportedByDriverError(typeOptions.type, "WebSQL");
                };
                /**
                 * Checks if "DEFAULT" values in the column metadata and in the database schema are equal.
                 */
                WebsqlQueryRunner.prototype.compareDefaultValues = function (columnMetadataValue, databaseValue) {
                    if (typeof columnMetadataValue === "number")
                        return columnMetadataValue === parseInt(databaseValue);
                    if (typeof columnMetadataValue === "boolean")
                        return columnMetadataValue === (!!databaseValue || databaseValue === "false");
                    if (typeof columnMetadataValue === "function")
                        return columnMetadataValue() === databaseValue;
                    return columnMetadataValue === databaseValue;
                };
                /**
                 * Truncates table.
                 */
                WebsqlQueryRunner.prototype.truncate = function (tableName) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.query("DELETE FROM " + this.driver.escapeTableName(tableName))];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Parametrizes given object of values. Used to create column=value queries.
                 */
                WebsqlQueryRunner.prototype.parametrize = function (objectLiteral, startIndex) {
                    var _this = this;
                    if (startIndex === void 0) { startIndex = 0; }
                    return Object.keys(objectLiteral).map(function (key, index) { return _this.driver.escapeColumnName(key) + "=$" + (startIndex + index + 1); });
                };
                /**
                 * Builds a query for create column.
                 */
                WebsqlQueryRunner.prototype.buildCreateColumnSql = function (column) {
                    var c = "\"" + column.name + "\"";
                    if (column instanceof ColumnMetadata_6.ColumnMetadata) {
                        c += " " + this.normalizeType(column);
                    }
                    else {
                        c += " " + column.type;
                    }
                    if (column.isNullable !== true)
                        c += " NOT NULL";
                    if (column.isUnique === true)
                        c += " UNIQUE";
                    if (column.isGenerated === true)
                        c += " PRIMARY KEY AUTOINCREMENT";
                    if (column.default !== undefined && column.default !== null) {
                        if (typeof column.default === "number") {
                            c += " DEFAULT " + column.default + "";
                        }
                        else if (typeof column.default === "boolean") {
                            c += " DEFAULT " + (column.default === true ? "TRUE" : "FALSE") + "";
                        }
                        else if (typeof column.default === "function") {
                            c += " DEFAULT " + column.default() + "";
                        }
                        else if (typeof column.default === "string") {
                            c += " DEFAULT '" + column.default + "'";
                        }
                        else {
                            c += " DEFAULT " + column.default + "";
                        }
                    }
                    return c;
                };
                WebsqlQueryRunner.prototype.recreateTable = function (tableSchema, oldTableSchema) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var columnDefinitions, columnNames, sql1, primaryKeyColumns, oldColumnNames, sql2, sql3, sql4, indexPromises;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    columnDefinitions = tableSchema.columns.map(function (dbColumn) { return _this.buildCreateColumnSql(dbColumn); }).join(", ");
                                    columnNames = tableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ");
                                    sql1 = "CREATE TABLE \"temporary_" + tableSchema.name + "\" (" + columnDefinitions;
                                    // if (options && options.createForeignKeys) {
                                    tableSchema.foreignKeys.forEach(function (foreignKey) {
                                        var columnNames = foreignKey.columnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        var referencedColumnNames = foreignKey.referencedColumnNames.map(function (name) { return "\"" + name + "\""; }).join(", ");
                                        sql1 += ", FOREIGN KEY(" + columnNames + ") REFERENCES \"" + foreignKey.referencedTableName + "\"(" + referencedColumnNames + ")";
                                        if (foreignKey.onDelete)
                                            sql1 += " ON DELETE " + foreignKey.onDelete;
                                    });
                                    primaryKeyColumns = tableSchema.columns.filter(function (column) { return column.isPrimary && !column.isGenerated; });
                                    if (primaryKeyColumns.length > 0)
                                        sql1 += ", PRIMARY KEY(" + primaryKeyColumns.map(function (column) { return "" + column.name; }).join(", ") + ")"; // for some reason column escaping here generate a wrong schema
                                    sql1 += ")";
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    return [4 /*yield*/, this.query(sql1)];
                                case 1:
                                    // todo: need also create uniques and indices?
                                    // recreate a table with a temporary name
                                    _a.sent();
                                    oldColumnNames = oldTableSchema ? oldTableSchema.columns.map(function (column) { return "\"" + column.name + "\""; }).join(", ") : columnNames;
                                    sql2 = "INSERT INTO \"temporary_" + tableSchema.name + "\"(" + oldColumnNames + ") SELECT " + oldColumnNames + " FROM \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql2)];
                                case 2:
                                    _a.sent();
                                    sql3 = "DROP TABLE \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql3)];
                                case 3:
                                    _a.sent();
                                    sql4 = "ALTER TABLE \"temporary_" + tableSchema.name + "\" RENAME TO \"" + tableSchema.name + "\"";
                                    return [4 /*yield*/, this.query(sql4)];
                                case 4:
                                    _a.sent();
                                    indexPromises = tableSchema.indices.map(function (index) { return _this.createIndex(tableSchema.name, index); });
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    return [4 /*yield*/, Promise.all(indexPromises /*.concat(uniquePromises)*/)];
                                case 5:
                                    // const uniquePromises = tableSchema.uniqueKeys.map(key => this.createIndex(key));
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    });
                };
                /**
                 * If given value is a table name then it loads its table schema representation from the database.
                 */
                WebsqlQueryRunner.prototype.getTableSchema = function (tableSchemaOrName) {
                    return __awaiter(this, void 0, void 0, function () {
                        var tableSchema;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(tableSchemaOrName instanceof TableSchema_8.TableSchema)) return [3 /*break*/, 1];
                                    return [2 /*return*/, tableSchemaOrName];
                                case 1: return [4 /*yield*/, this.loadTableSchema(tableSchemaOrName)];
                                case 2:
                                    tableSchema = _a.sent();
                                    if (!tableSchema)
                                        throw new Error("Table named " + tableSchemaOrName + " was not found in the database.");
                                    return [2 /*return*/, tableSchema];
                            }
                        });
                    });
                };
                return WebsqlQueryRunner;
            }());
            exports_171("WebsqlQueryRunner", WebsqlQueryRunner);
        }
    };
});
System.register("typeorm/driver/websql/WebsqlDriver", ["typeorm/driver/error/ConnectionIsNotSetError", "typeorm/driver/DriverUtils", "typeorm/metadata/types/ColumnTypes", "typeorm/driver/error/DriverOptionNotSetError", "typeorm/util/DataTransformationUtils", "typeorm/driver/websql/WebsqlQueryRunner"], function (exports_172, context_172) {
    "use strict";
    var __moduleName = context_172 && context_172.id;
    var ConnectionIsNotSetError_7, DriverUtils_5, ColumnTypes_9, DriverOptionNotSetError_7, DataTransformationUtils_7, WebsqlQueryRunner_1, WebsqlDriver;
    return {
        setters: [
            function (ConnectionIsNotSetError_7_1) {
                ConnectionIsNotSetError_7 = ConnectionIsNotSetError_7_1;
            },
            function (DriverUtils_5_1) {
                DriverUtils_5 = DriverUtils_5_1;
            },
            function (ColumnTypes_9_1) {
                ColumnTypes_9 = ColumnTypes_9_1;
            },
            function (DriverOptionNotSetError_7_1) {
                DriverOptionNotSetError_7 = DriverOptionNotSetError_7_1;
            },
            function (DataTransformationUtils_7_1) {
                DataTransformationUtils_7 = DataTransformationUtils_7_1;
            },
            function (WebsqlQueryRunner_1_1) {
                WebsqlQueryRunner_1 = WebsqlQueryRunner_1_1;
            }
        ],
        execute: function () {
            /**
             * Organizes communication with WebSQL in the browser.
             */
            WebsqlDriver = (function () {
                // -------------------------------------------------------------------------
                // Constructor
                // -------------------------------------------------------------------------
                function WebsqlDriver(options, logger) {
                    this.options = DriverUtils_5.DriverUtils.buildDriverOptions(options);
                    this.logger = logger;
                    // validate options to make sure everything is set
                    // if (!this.options.host)
                    //     throw new DriverOptionNotSetError("host");
                    // if (!this.options.username)
                    //     throw new DriverOptionNotSetError("username");
                    if (!this.options.database)
                        throw new DriverOptionNotSetError_7.DriverOptionNotSetError("database");
                    // todo: what about extra options: version, description, size
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Performs connection to the database.
                 * Based on pooling options, it can either create connection immediately,
                 * either create a pool and create connection when needed.
                 */
                WebsqlDriver.prototype.connect = function () {
                    var _this = this;
                    // build connection options for the driver
                    var options = Object.assign({}, {
                        database: this.options.database,
                    }, this.options.extra || {});
                    return new Promise(function (ok, fail) {
                        var connection = openDatabase(options.database, options.version, options.description, options.size);
                        _this.databaseConnection = {
                            id: 1,
                            connection: connection,
                            isTransactionActive: false
                        };
                        ok();
                    });
                };
                /**
                 * Closes connection with the database.
                 */
                WebsqlDriver.prototype.disconnect = function () {
                    if (!this.databaseConnection)
                        throw new ConnectionIsNotSetError_7.ConnectionIsNotSetError("websql");
                    return new Promise(function (ok, fail) {
                        // const handler = (err: any) => err ? fail(err) : ok();
                        // todo: find out how to close connection
                        ok();
                    });
                };
                /**
                 * Creates a query runner used for common queries.
                 */
                WebsqlDriver.prototype.createQueryRunner = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        var databaseConnection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.databaseConnection)
                                        return [2 /*return*/, Promise.reject(new ConnectionIsNotSetError_7.ConnectionIsNotSetError("websql"))];
                                    return [4 /*yield*/, this.retrieveDatabaseConnection()];
                                case 1:
                                    databaseConnection = _a.sent();
                                    return [2 /*return*/, new WebsqlQueryRunner_1.WebsqlQueryRunner(databaseConnection, this, this.logger)];
                            }
                        });
                    });
                };
                /**
                 * Access to the native implementation of the database.
                 */
                WebsqlDriver.prototype.nativeInterface = function () {
                    return {
                        connection: this.databaseConnection ? this.databaseConnection.connection : undefined
                    };
                };
                /**
                 * Replaces parameters in the given sql with special escaping character
                 * and an array of parameter names to be passed to a query.
                 */
                WebsqlDriver.prototype.escapeQueryWithParameters = function (sql, parameters) {
                    if (!parameters || !Object.keys(parameters).length)
                        return [sql, []];
                    var escapedParameters = [];
                    var keys = Object.keys(parameters).map(function (parameter) { return "(:" + parameter + "\\b)"; }).join("|");
                    sql = sql.replace(new RegExp(keys, "g"), function (key) {
                        escapedParameters.push(parameters[key.substr(1)]);
                        return "?";
                    }); // todo: make replace only in value statements, otherwise problems
                    return [sql, escapedParameters];
                };
                /**
                 * Escapes a column name.
                 */
                WebsqlDriver.prototype.escapeColumnName = function (columnName) {
                    return columnName; // "`" + columnName + "`";
                };
                /**
                 * Escapes an alias.
                 */
                WebsqlDriver.prototype.escapeAliasName = function (aliasName) {
                    return aliasName; // "`" + aliasName + "`";
                };
                /**
                 * Escapes a table name.
                 */
                WebsqlDriver.prototype.escapeTableName = function (tableName) {
                    return tableName; // "`" + tableName + "`";
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type and metadata.
                 */
                WebsqlDriver.prototype.preparePersistentValue = function (value, columnMetadata) {
                    if (value === null || value === undefined)
                        return null;
                    switch (columnMetadata.type) {
                        case ColumnTypes_9.ColumnTypes.BOOLEAN:
                            return value === true ? 1 : 0;
                        case ColumnTypes_9.ColumnTypes.DATE:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_9.ColumnTypes.TIME:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedDateToTimeString(value);
                        case ColumnTypes_9.ColumnTypes.DATETIME:
                            if (columnMetadata.localTimezone) {
                                return DataTransformationUtils_7.DataTransformationUtils.mixedDateToDatetimeString(value);
                            }
                            else {
                                return DataTransformationUtils_7.DataTransformationUtils.mixedDateToUtcDatetimeString(value);
                            }
                        case ColumnTypes_9.ColumnTypes.JSON:
                            return JSON.stringify(value);
                        case ColumnTypes_9.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_7.DataTransformationUtils.simpleArrayToString(value);
                    }
                    return value;
                };
                /**
                 * Prepares given value to a value to be persisted, based on its column type or metadata.
                 */
                WebsqlDriver.prototype.prepareHydratedValue = function (value, columnMetadata) {
                    switch (columnMetadata.type) {
                        case ColumnTypes_9.ColumnTypes.BOOLEAN:
                            return value ? true : false;
                        case ColumnTypes_9.ColumnTypes.DATETIME:
                            return DataTransformationUtils_7.DataTransformationUtils.normalizeHydratedDate(value, columnMetadata.localTimezone === true);
                        case ColumnTypes_9.ColumnTypes.DATE:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedDateToDateString(value);
                        case ColumnTypes_9.ColumnTypes.TIME:
                            return DataTransformationUtils_7.DataTransformationUtils.mixedTimeToString(value);
                        case ColumnTypes_9.ColumnTypes.JSON:
                            return JSON.parse(value);
                        case ColumnTypes_9.ColumnTypes.SIMPLE_ARRAY:
                            return DataTransformationUtils_7.DataTransformationUtils.stringToSimpleArray(value);
                    }
                    return value;
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Retrieves a new database connection.
                 * If pooling is enabled then connection from the pool will be retrieved.
                 * Otherwise active connection will be returned.
                 */
                WebsqlDriver.prototype.retrieveDatabaseConnection = function () {
                    if (this.databaseConnection)
                        return Promise.resolve(this.databaseConnection);
                    throw new ConnectionIsNotSetError_7.ConnectionIsNotSetError("websql");
                };
                return WebsqlDriver;
            }());
            exports_172("WebsqlDriver", WebsqlDriver);
        }
    };
});
System.register("typeorm/connection/ConnectionManager", ["typeorm/connection/Connection", "typeorm/connection/error/ConnectionNotFoundError", "typeorm/driver/mysql/MysqlDriver", "typeorm/connection/error/MissingDriverError", "typeorm/driver/postgres/PostgresDriver", "typeorm/connection/error/AlreadyHasActiveConnectionError", "typeorm/logger/Logger", "typeorm/driver/sqlite/SqliteDriver", "typeorm/driver/oracle/OracleDriver", "typeorm/driver/sqlserver/SqlServerDriver", "typeorm/util/OrmUtils", "typeorm/connection/error/CannotDetermineConnectionOptionsError", "typeorm/platform/PlatformTools", "typeorm/driver/websql/WebsqlDriver", "typeorm/driver/mongodb/MongoDriver"], function (exports_173, context_173) {
    "use strict";
    var __moduleName = context_173 && context_173.id;
    var Connection_1, ConnectionNotFoundError_1, MysqlDriver_2, MissingDriverError_1, PostgresDriver_2, AlreadyHasActiveConnectionError_1, Logger_1, SqliteDriver_1, OracleDriver_2, SqlServerDriver_2, OrmUtils_6, CannotDetermineConnectionOptionsError_1, PlatformTools_10, WebsqlDriver_1, MongoDriver_5, ConnectionManager;
    return {
        setters: [
            function (Connection_1_1) {
                Connection_1 = Connection_1_1;
            },
            function (ConnectionNotFoundError_1_1) {
                ConnectionNotFoundError_1 = ConnectionNotFoundError_1_1;
            },
            function (MysqlDriver_2_1) {
                MysqlDriver_2 = MysqlDriver_2_1;
            },
            function (MissingDriverError_1_1) {
                MissingDriverError_1 = MissingDriverError_1_1;
            },
            function (PostgresDriver_2_1) {
                PostgresDriver_2 = PostgresDriver_2_1;
            },
            function (AlreadyHasActiveConnectionError_1_1) {
                AlreadyHasActiveConnectionError_1 = AlreadyHasActiveConnectionError_1_1;
            },
            function (Logger_1_1) {
                Logger_1 = Logger_1_1;
            },
            function (SqliteDriver_1_1) {
                SqliteDriver_1 = SqliteDriver_1_1;
            },
            function (OracleDriver_2_1) {
                OracleDriver_2 = OracleDriver_2_1;
            },
            function (SqlServerDriver_2_1) {
                SqlServerDriver_2 = SqlServerDriver_2_1;
            },
            function (OrmUtils_6_1) {
                OrmUtils_6 = OrmUtils_6_1;
            },
            function (CannotDetermineConnectionOptionsError_1_1) {
                CannotDetermineConnectionOptionsError_1 = CannotDetermineConnectionOptionsError_1_1;
            },
            function (PlatformTools_10_1) {
                PlatformTools_10 = PlatformTools_10_1;
            },
            function (WebsqlDriver_1_1) {
                WebsqlDriver_1 = WebsqlDriver_1_1;
            },
            function (MongoDriver_5_1) {
                MongoDriver_5 = MongoDriver_5_1;
            }
        ],
        execute: function () {
            /**
             * ConnectionManager is used to store and manage all these different connections.
             * It also provides useful factory methods to simplify connection creation.
             */
            ConnectionManager = (function () {
                function ConnectionManager() {
                    // -------------------------------------------------------------------------
                    // Protected Properties
                    // -------------------------------------------------------------------------
                    /**
                     * List of connections registered in this connection manager.
                     */
                    this.connections = [];
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if connection with the given name exist in the manager.
                 */
                ConnectionManager.prototype.has = function (name) {
                    return !!this.connections.find(function (connection) { return connection.name === name; });
                };
                /**
                 * Gets registered connection with the given name.
                 * If connection name is not given then it will get a default connection.
                 * Throws exception if connection with the given name was not found.
                 */
                ConnectionManager.prototype.get = function (name) {
                    if (name === void 0) { name = "default"; }
                    var connection = this.connections.find(function (connection) { return connection.name === name; });
                    if (!connection)
                        throw new ConnectionNotFoundError_1.ConnectionNotFoundError(name);
                    return connection;
                };
                /**
                 * Creates a new connection based on the given connection options and registers it in the manager.
                 * You need to manually call #connect method to establish connection.
                 * Note that dropSchemaOnConnection and autoSchemaSync options of a ConnectionOptions will not work there - use
                 * createAndConnect method to use them.
                 */
                ConnectionManager.prototype.create = function (options) {
                    var logger = new Logger_1.Logger(options.logging || {});
                    var driver = this.createDriver(options.driver, logger);
                    var connection = this.createConnection(options.name || "default", driver, logger);
                    // import entity schemas
                    if (options.entitySchemas) {
                        var _a = this.splitStringsAndClasses(options.entitySchemas), directories = _a[0], classes = _a[1];
                        connection
                            .importEntitySchemas(classes)
                            .importEntitySchemaFromDirectories(directories);
                    }
                    // import entities
                    if (options.entities) {
                        var _b = this.splitStringsAndClasses(options.entities), directories = _b[0], classes = _b[1];
                        connection
                            .importEntities(classes)
                            .importEntitiesFromDirectories(directories);
                    }
                    // import subscriber
                    if (options.subscribers) {
                        var _c = this.splitStringsAndClasses(options.subscribers), directories = _c[0], classes = _c[1];
                        connection
                            .importSubscribers(classes)
                            .importSubscribersFromDirectories(directories);
                    }
                    // import naming strategies
                    if (options.namingStrategies) {
                        var _d = this.splitStringsAndClasses(options.namingStrategies), directories = _d[0], classes = _d[1];
                        connection
                            .importNamingStrategies(classes)
                            .importNamingStrategiesFromDirectories(directories);
                    }
                    // import migrations
                    if (options.migrations) {
                        var _e = this.splitStringsAndClasses(options.migrations), directories = _e[0], classes = _e[1];
                        connection
                            .importMigrations(classes)
                            .importMigrationsFromDirectories(directories);
                    }
                    // set naming strategy to be used for this connection
                    if (options.usedNamingStrategy)
                        connection.useNamingStrategy(options.usedNamingStrategy);
                    return connection;
                };
                /**
                 * Creates connection and and registers it in the manager.
                 */
                ConnectionManager.prototype.createAndConnect = function (optionsOrConnectionNameFromConfig, ormConfigPath) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            // if connection options are given, then create connection from them
                            if (optionsOrConnectionNameFromConfig && optionsOrConnectionNameFromConfig instanceof Object)
                                return [2 /*return*/, this.createAndConnectByConnectionOptions(optionsOrConnectionNameFromConfig)];
                            // if connection name is specified then explicitly try to load connection options from it
                            if (typeof optionsOrConnectionNameFromConfig === "string")
                                return [2 /*return*/, this.createFromConfigAndConnect(optionsOrConnectionNameFromConfig || "default", ormConfigPath)];
                            // if nothing is specified then try to silently load config from ormconfig.json
                            if (this.hasDefaultConfigurationInConfigurationFile())
                                return [2 /*return*/, this.createFromConfigAndConnect("default")];
                            // if driver type is set in environment variables then try to create connection from env variables
                            if (this.hasDefaultConfigurationInEnvironmentVariables())
                                return [2 /*return*/, this.createFromEnvAndConnect()];
                            throw new CannotDetermineConnectionOptionsError_1.CannotDetermineConnectionOptionsError();
                        });
                    });
                };
                /**
                 * Creates connections and and registers them in the manager.
                 */
                ConnectionManager.prototype.createAndConnectToAll = function (optionsOrOrmConfigFilePath) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // if connection options are given, then create connection from them
                                    if (optionsOrOrmConfigFilePath && optionsOrOrmConfigFilePath instanceof Array)
                                        return [2 /*return*/, Promise.all(optionsOrOrmConfigFilePath.map(function (options) {
                                                return _this.createAndConnectByConnectionOptions(options);
                                            }))];
                                    // if connection name is specified then explicitly try to load connection options from it
                                    if (typeof optionsOrOrmConfigFilePath === "string")
                                        return [2 /*return*/, this.createFromConfigAndConnectToAll(optionsOrOrmConfigFilePath)];
                                    // if nothing is specified then try to silently load config from ormconfig.json
                                    if (this.hasOrmConfigurationFile())
                                        return [2 /*return*/, this.createFromConfigAndConnectToAll()];
                                    if (!this.hasDefaultConfigurationInEnvironmentVariables()) return [3 /*break*/, 2];
                                    return [4 /*yield*/, this.createFromEnvAndConnect()];
                                case 1: return [2 /*return*/, [_a.sent()]];
                                case 2: throw new CannotDetermineConnectionOptionsError_1.CannotDetermineConnectionOptionsError();
                            }
                        });
                    });
                };
                // -------------------------------------------------------------------------
                // Protected Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if ormconfig.json exists.
                 */
                ConnectionManager.prototype.hasOrmConfigurationFile = function () {
                    var path = PlatformTools_10.PlatformTools.load("app-root-path").path + "/ormconfig.json";
                    if (!PlatformTools_10.PlatformTools.fileExist(path))
                        return false;
                    var configuration = PlatformTools_10.PlatformTools.load(path);
                    if (configuration instanceof Array) {
                        return configuration
                            .filter(function (options) { return !options.environment || options.environment === PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"); })
                            .length > 0;
                    }
                    else if (configuration instanceof Object) {
                        if (configuration.environment && configuration.environment !== PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"))
                            return false;
                        return Object.keys(configuration).length > 0;
                    }
                    return false;
                };
                /**
                 * Checks if there is a default connection in the ormconfig.json file.
                 */
                ConnectionManager.prototype.hasDefaultConfigurationInConfigurationFile = function () {
                    var path = PlatformTools_10.PlatformTools.load("app-root-path").path + "/ormconfig.json";
                    if (!PlatformTools_10.PlatformTools.fileExist(path))
                        return false;
                    var configuration = PlatformTools_10.PlatformTools.load(path);
                    if (configuration instanceof Array) {
                        return !!configuration
                            .filter(function (options) { return !options.environment || options.environment === PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"); })
                            .find(function (config) { return !!config.name || config.name === "default"; });
                    }
                    else if (configuration instanceof Object) {
                        if (!configuration.name ||
                            configuration.name !== "default")
                            return false;
                        if (configuration.environment && configuration.environment !== PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"))
                            return false;
                        return true;
                    }
                    return false;
                };
                /**
                 * Checks if environment variables contains connection options.
                 */
                ConnectionManager.prototype.hasDefaultConfigurationInEnvironmentVariables = function () {
                    return !!PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_DRIVER_TYPE");
                };
                /**
                 * Allows to quickly create a connection based on the environment variable values.
                 */
                ConnectionManager.prototype.createFromEnvAndConnect = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, this.createAndConnectByConnectionOptions({
                                    driver: {
                                        type: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_DRIVER_TYPE"),
                                        url: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_URL"),
                                        host: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_HOST"),
                                        port: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_PORT"),
                                        username: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_USERNAME"),
                                        password: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_PASSWORD"),
                                        database: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_DATABASE"),
                                        sid: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_SID"),
                                        storage: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_STORAGE"),
                                        usePool: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_USE_POOL") !== undefined ? OrmUtils_6.OrmUtils.toBoolean(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_USE_POOL")) : undefined,
                                        extra: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA") ? JSON.parse(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_DRIVER_EXTRA")) : undefined
                                    },
                                    autoSchemaSync: OrmUtils_6.OrmUtils.toBoolean(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_AUTO_SCHEMA_SYNC")),
                                    entities: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_ENTITIES") ? PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_ENTITIES").split(",") : [],
                                    subscribers: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS") ? PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_SUBSCRIBERS").split(",") : [],
                                    entitySchemas: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_ENTITY_SCHEMAS") ? PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_ENTITY_SCHEMAS").split(",") : [],
                                    namingStrategies: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_NAMING_STRATEGIES") ? PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_NAMING_STRATEGIES").split(",") : [],
                                    usedNamingStrategy: PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_USED_NAMING_STRATEGY"),
                                    logging: {
                                        logQueries: OrmUtils_6.OrmUtils.toBoolean(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_LOGGING_QUERIES")),
                                        logFailedQueryError: OrmUtils_6.OrmUtils.toBoolean(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_LOGGING_FAILED_QUERIES")),
                                        logOnlyFailedQueries: OrmUtils_6.OrmUtils.toBoolean(PlatformTools_10.PlatformTools.getEnvVariable("TYPEORM_LOGGING_ONLY_FAILED_QUERIES")),
                                    }
                                })];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the connection options from "ormconfig.json"
                 * and registers a new connection in the manager.
                 * Optionally you can specify a path to the json configuration.
                 * If path is not given, then ormconfig.json file will be searched near node_modules directory.
                 */
                ConnectionManager.prototype.createFromConfigAndConnectToAll = function (path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        var optionsArray, promises;
                        return __generator(this, function (_a) {
                            optionsArray = PlatformTools_10.PlatformTools.load(path || (PlatformTools_10.PlatformTools.load("app-root-path").path + "/ormconfig.json"));
                            if (!optionsArray)
                                throw new Error("Configuration " + (path || "ormconfig.json") + " was not found. Add connection configuration inside ormconfig.json file.");
                            promises = optionsArray
                                .filter(function (options) { return !options.environment || options.environment === PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"); }) // skip connection creation if environment is set in the options, and its not equal to the value in the NODE_ENV variable
                                .map(function (options) { return _this.createAndConnectByConnectionOptions(options); });
                            return [2 /*return*/, Promise.all(promises)];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the connection options from "ormconfig.json"
                 * and registers a new connection in the manager.
                 * Optionally you can specify a path to the json configuration.
                 * If path is not given, then ormconfig.json file will be searched near node_modules directory.
                 */
                ConnectionManager.prototype.createFromConfigAndConnect = function (connectionName, path) {
                    return __awaiter(this, void 0, void 0, function () {
                        var optionsArray, environmentLessOptions, options;
                        return __generator(this, function (_a) {
                            optionsArray = PlatformTools_10.PlatformTools.load(path || (PlatformTools_10.PlatformTools.load("app-root-path").path + "/ormconfig.json"));
                            if (!optionsArray)
                                throw new Error("Configuration " + (path || "ormconfig.json") + " was not found. Add connection configuration inside ormconfig.json file.");
                            environmentLessOptions = optionsArray.filter(function (options) { return (options.name || "default") === connectionName; });
                            options = environmentLessOptions.filter(function (options) { return !options.environment || options.environment === PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV"); });
                            if (!options.length)
                                throw new Error("Connection \"" + connectionName + "\" " + (PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV") ? "for the environment " + PlatformTools_10.PlatformTools.getEnvVariable("NODE_ENV") + " " : "") + "was not found in the json configuration file." +
                                    (environmentLessOptions.length ? " However there are such configurations for other environments: " + environmentLessOptions.map(function (options) { return options.environment; }).join(", ") + "." : ""));
                            return [2 /*return*/, this.createAndConnectByConnectionOptions(options[0])];
                        });
                    });
                };
                /**
                 * Creates a new connection based on the given connection options and registers a new connection in the manager.
                 */
                ConnectionManager.prototype.createAndConnectByConnectionOptions = function (options) {
                    return __awaiter(this, void 0, void 0, function () {
                        var connection;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    connection = this.create(options);
                                    // connect to the database
                                    return [4 /*yield*/, connection.connect()];
                                case 1:
                                    // connect to the database
                                    _a.sent();
                                    if (!(options.dropSchemaOnConnection && !PlatformTools_10.PlatformTools.getEnvVariable("SKIP_SCHEMA_CREATION"))) return [3 /*break*/, 3];
                                    return [4 /*yield*/, connection.dropDatabase()];
                                case 2:
                                    _a.sent();
                                    _a.label = 3;
                                case 3:
                                    if (!(options.autoSchemaSync && !PlatformTools_10.PlatformTools.getEnvVariable("SKIP_SCHEMA_CREATION"))) return [3 /*break*/, 5];
                                    return [4 /*yield*/, connection.syncSchema()];
                                case 4:
                                    _a.sent();
                                    _a.label = 5;
                                case 5:
                                    if (!(options.autoMigrationsRun && !PlatformTools_10.PlatformTools.getEnvVariable("SKIP_MIGRATIONS_RUN"))) return [3 /*break*/, 7];
                                    return [4 /*yield*/, connection.runMigrations()];
                                case 6:
                                    _a.sent();
                                    _a.label = 7;
                                case 7: return [2 /*return*/, connection];
                            }
                        });
                    });
                };
                /**
                 * Splits given array of mixed strings and / or functions into two separate array of string and array of functions.
                 */
                ConnectionManager.prototype.splitStringsAndClasses = function (strAndClses) {
                    return [
                        strAndClses.filter(function (str) { return typeof str === "string"; }),
                        strAndClses.filter(function (cls) { return typeof cls !== "string"; }),
                    ];
                };
                /**
                 * Creates a new driver based on the given driver type and options.
                 */
                ConnectionManager.prototype.createDriver = function (options, logger) {
                    switch (options.type) {
                        case "mysql":
                            return new MysqlDriver_2.MysqlDriver(options, logger, undefined);
                        case "postgres":
                            return new PostgresDriver_2.PostgresDriver(options, logger);
                        case "mariadb":
                            return new MysqlDriver_2.MysqlDriver(options, logger);
                        case "sqlite":
                            return new SqliteDriver_1.SqliteDriver(options, logger);
                        case "oracle":
                            return new OracleDriver_2.OracleDriver(options, logger);
                        case "mssql":
                            return new SqlServerDriver_2.SqlServerDriver(options, logger);
                        case "websql":
                            return new WebsqlDriver_1.WebsqlDriver(options, logger);
                        case "mongodb":
                            return new MongoDriver_5.MongoDriver(options, logger);
                        default:
                            throw new MissingDriverError_1.MissingDriverError(options.type);
                    }
                };
                /**
                 * Creates a new connection and registers it in the connection manager.
                 */
                ConnectionManager.prototype.createConnection = function (name, driver, logger) {
                    var existConnection = this.connections.find(function (connection) { return connection.name === name; });
                    if (existConnection) {
                        if (existConnection.isConnected)
                            throw new AlreadyHasActiveConnectionError_1.AlreadyHasActiveConnectionError(name);
                        this.connections.splice(this.connections.indexOf(existConnection), 1);
                    }
                    var connection = new Connection_1.Connection(name, driver, logger);
                    this.connections.push(connection);
                    return connection;
                };
                return ConnectionManager;
            }());
            exports_173("ConnectionManager", ConnectionManager);
        }
    };
});
System.register("typeorm/decorator/error/GeneratedOnlyForPrimaryError", [], function (exports_174, context_174) {
    "use strict";
    var __moduleName = context_174 && context_174.id;
    var GeneratedOnlyForPrimaryError;
    return {
        setters: [],
        execute: function () {
            GeneratedOnlyForPrimaryError = (function (_super) {
                __extends(GeneratedOnlyForPrimaryError, _super);
                function GeneratedOnlyForPrimaryError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "GeneratedOnlyForPrimaryError";
                    _this.message = "Column for property " + object.constructor.name + "#" + propertyName + " cannot have a generated " +
                        "value because its not a primary column. Try to use @PrimaryColumn decorator.";
                    return _this;
                }
                return GeneratedOnlyForPrimaryError;
            }(Error));
            exports_174("GeneratedOnlyForPrimaryError", GeneratedOnlyForPrimaryError);
        }
    };
});
System.register("typeorm/decorator/columns/Column", ["typeorm/decorator/error/GeneratedOnlyForPrimaryError", "typeorm/index", "typeorm/metadata/types/ColumnTypes"], function (exports_175, context_175) {
    "use strict";
    var __moduleName = context_175 && context_175.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     */
    function Column(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        }
        else if (typeOrOptions) {
            options = typeOrOptions;
            type = typeOrOptions.type;
        }
        return function (object, propertyName) {
            // todo: need to store not string type, but original type instead? (like in relation metadata)
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if type is not given implicitly then try to guess it
            if (!type) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                if (reflectMetadataType)
                    type = ColumnTypes_10.ColumnTypes.determineTypeFromFunction(reflectMetadataType);
            }
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set type from first function argument, or guessed one
            if (!options.type && type)
                options = Object.assign({ type: type }, options);
            // if we still don't have a type then we need to give error to user that type is required
            // if (!options.type)
            //     throw new ColumnTypeUndefinedError(object, propertyName);
            // check if auto increment is not set for simple column
            if (options.generated)
                throw new GeneratedOnlyForPrimaryError_1.GeneratedOnlyForPrimaryError(object, propertyName);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_4.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_175("Column", Column);
    var GeneratedOnlyForPrimaryError_1, index_4, ColumnTypes_10;
    return {
        setters: [
            function (GeneratedOnlyForPrimaryError_1_1) {
                GeneratedOnlyForPrimaryError_1 = GeneratedOnlyForPrimaryError_1_1;
            },
            function (index_4_1) {
                index_4 = index_4_1;
            },
            function (ColumnTypes_10_1) {
                ColumnTypes_10 = ColumnTypes_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/CreateDateColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_176, context_176) {
    "use strict";
    var __moduleName = context_176 && context_176.id;
    /**
     * This column will store a creation date of the inserted object.
     * Creation date is generated and inserted only once,
     * at the first time when you create an object, the value is inserted into the table, and is never touched again.
     */
    function CreateDateColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_11.ColumnTypes.DATETIME }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "createDate",
                options: options
            };
            index_5.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_176("CreateDateColumn", CreateDateColumn);
    var ColumnTypes_11, index_5;
    return {
        setters: [
            function (ColumnTypes_11_1) {
                ColumnTypes_11 = ColumnTypes_11_1;
            },
            function (index_5_1) {
                index_5 = index_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/DiscriminatorColumn", ["typeorm/index"], function (exports_177, context_177) {
    "use strict";
    var __moduleName = context_177 && context_177.id;
    /**
     * DiscriminatorColumn is a special type column used on entity class (not entity property)
     * and creates a special column which will contain an entity type.
     * This type is required for entities which use single table inheritance pattern.
     */
    function DiscriminatorColumn(discriminatorOptions) {
        return function (target) {
            // if column options are not given then create a new empty options
            var options = {
                name: discriminatorOptions.name,
                type: discriminatorOptions.type
            };
            // create and register a new column metadata
            var args = {
                target: target,
                mode: "discriminator",
                propertyName: discriminatorOptions.name,
                options: options
            };
            index_6.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_177("DiscriminatorColumn", DiscriminatorColumn);
    var index_6;
    return {
        setters: [
            function (index_6_1) {
                index_6 = index_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/error/PrimaryColumnCannotBeNullableError", [], function (exports_178, context_178) {
    "use strict";
    var __moduleName = context_178 && context_178.id;
    var PrimaryColumnCannotBeNullableError;
    return {
        setters: [],
        execute: function () {
            PrimaryColumnCannotBeNullableError = (function (_super) {
                __extends(PrimaryColumnCannotBeNullableError, _super);
                function PrimaryColumnCannotBeNullableError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "PrimaryColumnCannotBeNullableError";
                    _this.message = "Primary column " + object.constructor.name + "#" + propertyName + " cannot be nullable. " +
                        "Its not allowed for primary keys. Try to remove nullable option.";
                    return _this;
                }
                return PrimaryColumnCannotBeNullableError;
            }(Error));
            exports_178("PrimaryColumnCannotBeNullableError", PrimaryColumnCannotBeNullableError);
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryGeneratedColumn", ["typeorm/index", "typeorm/decorator/error/PrimaryColumnCannotBeNullableError"], function (exports_179, context_179) {
    "use strict";
    var __moduleName = context_179 && context_179.id;
    // todo: add overloads for PrimaryGeneratedColumn(generationType: "sequence"|"uuid" = "sequence", options?: ColumnOptions)
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * This column creates an integer PRIMARY COLUMN with generated set to true.
     * This column creates is an alias for @PrimaryColumn("int", { generated: true }).
     */
    function PrimaryGeneratedColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set the int type - by default for auto generated column
            options = Object.assign({ type: "int" }, options);
            // check if column is not nullable, because we cannot allow a primary key to be nullable
            if (options.nullable)
                throw new PrimaryColumnCannotBeNullableError_1.PrimaryColumnCannotBeNullableError(object, propertyName);
            // implicitly set a primary and generated to column options
            options = Object.assign({ primary: true, generated: true }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_7.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_179("PrimaryGeneratedColumn", PrimaryGeneratedColumn);
    var index_7, PrimaryColumnCannotBeNullableError_1;
    return {
        setters: [
            function (index_7_1) {
                index_7 = index_7_1;
            },
            function (PrimaryColumnCannotBeNullableError_1_1) {
                PrimaryColumnCannotBeNullableError_1 = PrimaryColumnCannotBeNullableError_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/error/ColumnTypeUndefinedError", [], function (exports_180, context_180) {
    "use strict";
    var __moduleName = context_180 && context_180.id;
    var ColumnTypeUndefinedError;
    return {
        setters: [],
        execute: function () {
            ColumnTypeUndefinedError = (function (_super) {
                __extends(ColumnTypeUndefinedError, _super);
                function ColumnTypeUndefinedError(object, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "ColumnTypeUndefinedError";
                    _this.message = "Column type for " + object.constructor.name + "#" + propertyName + " is not defined or cannot be guessed. " +
                        "Try to implicitly provide a column type to @Column decorator.";
                    return _this;
                }
                return ColumnTypeUndefinedError;
            }(Error));
            exports_180("ColumnTypeUndefinedError", ColumnTypeUndefinedError);
        }
    };
});
System.register("typeorm/decorator/columns/PrimaryColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/decorator/error/ColumnTypeUndefinedError", "typeorm/index", "typeorm/decorator/error/PrimaryColumnCannotBeNullableError"], function (exports_181, context_181) {
    "use strict";
    var __moduleName = context_181 && context_181.id;
    /**
     * Column decorator is used to mark a specific class property as a table column.
     * Only properties decorated with this decorator will be persisted to the database when entity be saved.
     * Primary columns also creates a PRIMARY KEY for this column in a db.
     */
    function PrimaryColumn(typeOrOptions, options) {
        var type;
        if (typeof typeOrOptions === "string") {
            type = typeOrOptions;
        }
        else {
            options = typeOrOptions;
        }
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if type is not given implicitly then try to guess it
            if (!type) {
                var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
                if (reflectMetadataType)
                    type = ColumnTypes_12.ColumnTypes.determineTypeFromFunction(reflectMetadataType);
            }
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // check if there is no type in column options then set type from first function argument, or guessed one
            if (!options.type && type)
                options = Object.assign({ type: type }, options);
            // if we still don't have a type then we need to give error to user that type is required
            if (!options.type)
                throw new ColumnTypeUndefinedError_1.ColumnTypeUndefinedError(object, propertyName);
            // check if column is not nullable, because we cannot allow a primary key to be nullable
            if (options.nullable)
                throw new PrimaryColumnCannotBeNullableError_2.PrimaryColumnCannotBeNullableError(object, propertyName);
            // implicitly set a primary to column options
            options = Object.assign({ primary: true }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "regular",
                options: options
            };
            index_8.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_181("PrimaryColumn", PrimaryColumn);
    var ColumnTypes_12, ColumnTypeUndefinedError_1, index_8, PrimaryColumnCannotBeNullableError_2;
    return {
        setters: [
            function (ColumnTypes_12_1) {
                ColumnTypes_12 = ColumnTypes_12_1;
            },
            function (ColumnTypeUndefinedError_1_1) {
                ColumnTypeUndefinedError_1 = ColumnTypeUndefinedError_1_1;
            },
            function (index_8_1) {
                index_8 = index_8_1;
            },
            function (PrimaryColumnCannotBeNullableError_2_1) {
                PrimaryColumnCannotBeNullableError_2 = PrimaryColumnCannotBeNullableError_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/UpdateDateColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_182, context_182) {
    "use strict";
    var __moduleName = context_182 && context_182.id;
    /**
     * This column will store an update date of the updated object.
     * This date is being updated each time you persist the object.
     */
    function UpdateDateColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_13.ColumnTypes.DATETIME }, options);
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "updateDate",
                options: options
            };
            index_9.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_182("UpdateDateColumn", UpdateDateColumn);
    var ColumnTypes_13, index_9;
    return {
        setters: [
            function (ColumnTypes_13_1) {
                ColumnTypes_13 = ColumnTypes_13_1;
            },
            function (index_9_1) {
                index_9 = index_9_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/VersionColumn", ["typeorm/metadata/types/ColumnTypes", "typeorm/index"], function (exports_183, context_183) {
    "use strict";
    var __moduleName = context_183 && context_183.id;
    /**
     * This column will store a number - version of the entity.
     * Every time your entity will be persisted, this number will be increased by one -
     * so you can organize visioning and update strategies of your entity.
     */
    function VersionColumn(options) {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            // implicitly set a type, because this column's type cannot be anything else except date
            options = Object.assign({ type: ColumnTypes_14.ColumnTypes.INTEGER }, options);
            // todo: check if reflectedType is number too
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "version",
                options: options
            };
            index_10.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_183("VersionColumn", VersionColumn);
    var ColumnTypes_14, index_10;
    return {
        setters: [
            function (ColumnTypes_14_1) {
                ColumnTypes_14 = ColumnTypes_14_1;
            },
            function (index_10_1) {
                index_10 = index_10_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/columns/ObjectIdColumn", ["typeorm/index"], function (exports_184, context_184) {
    "use strict";
    var __moduleName = context_184 && context_184.id;
    /**
     * Special type of column that is available only for MongoDB database.
     * Marks your entity's column to be an object id.
     */
    function ObjectIdColumn(options) {
        return function (object, propertyName) {
            // if column options are not given then create a new empty options
            if (!options)
                options = {};
            options = Object.assign(options, {
                primary: true,
                name: options.name ? options.name : "_id"
            });
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                mode: "objectId",
                options: options
            };
            index_11.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_184("ObjectIdColumn", ObjectIdColumn);
    var index_11;
    return {
        setters: [
            function (index_11_1) {
                index_11 = index_11_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_185, context_185) {
    "use strict";
    var __moduleName = context_185 && context_185.id;
    /**
     * Calls a method on which this decorator is applied after this entity insertion.
     */
    function AfterInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_2.EventListenerTypes.AFTER_INSERT
            };
            index_12.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_185("AfterInsert", AfterInsert);
    var index_12, EventListenerTypes_2;
    return {
        setters: [
            function (index_12_1) {
                index_12 = index_12_1;
            },
            function (EventListenerTypes_2_1) {
                EventListenerTypes_2 = EventListenerTypes_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterLoad", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_186, context_186) {
    "use strict";
    var __moduleName = context_186 && context_186.id;
    /**
     * Calls a method on which this decorator is applied after entity is loaded.
     */
    function AfterLoad() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_3.EventListenerTypes.AFTER_LOAD
            };
            index_13.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_186("AfterLoad", AfterLoad);
    var index_13, EventListenerTypes_3;
    return {
        setters: [
            function (index_13_1) {
                index_13 = index_13_1;
            },
            function (EventListenerTypes_3_1) {
                EventListenerTypes_3 = EventListenerTypes_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_187, context_187) {
    "use strict";
    var __moduleName = context_187 && context_187.id;
    /**
     * Calls a method on which this decorator is applied after this entity removal.
     */
    function AfterRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_4.EventListenerTypes.AFTER_REMOVE
            };
            index_14.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_187("AfterRemove", AfterRemove);
    var index_14, EventListenerTypes_4;
    return {
        setters: [
            function (index_14_1) {
                index_14 = index_14_1;
            },
            function (EventListenerTypes_4_1) {
                EventListenerTypes_4 = EventListenerTypes_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/AfterUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_188, context_188) {
    "use strict";
    var __moduleName = context_188 && context_188.id;
    /**
     * Calls a method on which this decorator is applied after this entity update.
     */
    function AfterUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_5.EventListenerTypes.AFTER_UPDATE
            };
            index_15.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_188("AfterUpdate", AfterUpdate);
    var index_15, EventListenerTypes_5;
    return {
        setters: [
            function (index_15_1) {
                index_15 = index_15_1;
            },
            function (EventListenerTypes_5_1) {
                EventListenerTypes_5 = EventListenerTypes_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeInsert", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_189, context_189) {
    "use strict";
    var __moduleName = context_189 && context_189.id;
    /**
     * Calls a method on which this decorator is applied before this entity insertion.
     */
    function BeforeInsert() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_6.EventListenerTypes.BEFORE_INSERT
            };
            index_16.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_189("BeforeInsert", BeforeInsert);
    var index_16, EventListenerTypes_6;
    return {
        setters: [
            function (index_16_1) {
                index_16 = index_16_1;
            },
            function (EventListenerTypes_6_1) {
                EventListenerTypes_6 = EventListenerTypes_6_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeRemove", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_190, context_190) {
    "use strict";
    var __moduleName = context_190 && context_190.id;
    /**
     * Calls a method on which this decorator is applied before this entity removal.
     */
    function BeforeRemove() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_7.EventListenerTypes.BEFORE_REMOVE
            };
            index_17.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_190("BeforeRemove", BeforeRemove);
    var index_17, EventListenerTypes_7;
    return {
        setters: [
            function (index_17_1) {
                index_17 = index_17_1;
            },
            function (EventListenerTypes_7_1) {
                EventListenerTypes_7 = EventListenerTypes_7_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/BeforeUpdate", ["typeorm/index", "typeorm/metadata/types/EventListenerTypes"], function (exports_191, context_191) {
    "use strict";
    var __moduleName = context_191 && context_191.id;
    /**
     * Calls a method on which this decorator is applied before this entity update.
     */
    function BeforeUpdate() {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                type: EventListenerTypes_8.EventListenerTypes.BEFORE_UPDATE
            };
            index_18.getMetadataArgsStorage().entityListeners.push(args);
        };
    }
    exports_191("BeforeUpdate", BeforeUpdate);
    var index_18, EventListenerTypes_8;
    return {
        setters: [
            function (index_18_1) {
                index_18 = index_18_1;
            },
            function (EventListenerTypes_8_1) {
                EventListenerTypes_8 = EventListenerTypes_8_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/listeners/EventSubscriber", ["typeorm/index"], function (exports_192, context_192) {
    "use strict";
    var __moduleName = context_192 && context_192.id;
    /**
     * Classes decorated with this decorator will listen to ORM events and their methods will be triggered when event
     * occurs. Those classes must implement EventSubscriberInterface interface.
     */
    function EventSubscriber() {
        return function (target) {
            var args = {
                target: target
            };
            index_19.getMetadataArgsStorage().entitySubscribers.push(args);
        };
    }
    exports_192("EventSubscriber", EventSubscriber);
    var index_19;
    return {
        setters: [
            function (index_19_1) {
                index_19 = index_19_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/IndexOptions", [], function (exports_193, context_193) {
    "use strict";
    var __moduleName = context_193 && context_193.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/options/EntityOptions", [], function (exports_194, context_194) {
    "use strict";
    var __moduleName = context_194 && context_194.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationCount", ["typeorm/index"], function (exports_195, context_195) {
    "use strict";
    var __moduleName = context_195 && context_195.id;
    /**
     * Holds a number of children in the closure table of the column.
     */
    function RelationCount(relation, alias, queryBuilderFactory) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation,
                alias: alias,
                queryBuilderFactory: queryBuilderFactory
            };
            index_20.getMetadataArgsStorage().relationCounts.push(args);
        };
    }
    exports_195("RelationCount", RelationCount);
    var index_20;
    return {
        setters: [
            function (index_20_1) {
                index_20 = index_20_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinColumn", ["typeorm/index"], function (exports_196, context_196) {
    "use strict";
    var __moduleName = context_196 && context_196.id;
    /**
     * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.
     * It also can be used on both one-to-one and many-to-one relations to specify custom column name
     * or custom referenced column.
     */
    function JoinColumn(optionsOrOptionsArray) {
        return function (object, propertyName) {
            var options = optionsOrOptionsArray instanceof Array ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];
            options.forEach(function (options) {
                var args = {
                    target: object.constructor,
                    propertyName: propertyName,
                    name: options.name,
                    referencedColumnName: options.referencedColumnName
                };
                index_21.getMetadataArgsStorage().joinColumns.push(args);
            });
        };
    }
    exports_196("JoinColumn", JoinColumn);
    var index_21;
    return {
        setters: [
            function (index_21_1) {
                index_21 = index_21_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/JoinTable", ["typeorm/index"], function (exports_197, context_197) {
    "use strict";
    var __moduleName = context_197 && context_197.id;
    /**
     * JoinTable decorator is used in many-to-many relationship to specify owner side of relationship.
     * Its also used to set a custom junction table's name, column names and referenced columns.
     */
    function JoinTable(options) {
        return function (object, propertyName) {
            options = options || {};
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                name: options.name,
                joinColumns: (options && options.joinColumn ? [options.joinColumn] : options.joinColumns),
                inverseJoinColumns: (options && options.inverseJoinColumn ? [options.inverseJoinColumn] : options.inverseJoinColumns),
            };
            index_22.getMetadataArgsStorage().joinTables.push(args);
        };
    }
    exports_197("JoinTable", JoinTable);
    var index_22;
    return {
        setters: [
            function (index_22_1) {
                index_22 = index_22_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToMany", ["typeorm/index"], function (exports_198, context_198) {
    "use strict";
    var __moduleName = context_198 && context_198.id;
    /**
     * Many-to-many is a type of relationship when Entity1 can have multiple instances of Entity2, and Entity2 can have
     * multiple instances of Entity1. To achieve it, this type of relation creates a junction table, where it storage
     * entity1 and entity2 ids. This is owner side of the relationship.
     */
    function ManyToMany(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: "many-to-many",
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_23.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_198("ManyToMany", ManyToMany);
    var index_23;
    return {
        setters: [
            function (index_23_1) {
                index_23 = index_23_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/ManyToOne", ["typeorm/index"], function (exports_199, context_199) {
    "use strict";
    var __moduleName = context_199 && context_199.id;
    /**
     * Many-to-one relation allows to create type of relation when Entity1 can have single instance of Entity2, but
     * Entity2 can have a multiple instances of Entity1. Entity1 is an owner of the relationship, and storages Entity2 id
     * on its own side.
     */
    function ManyToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                relationType: "many-to-one",
                isLazy: isLazy,
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_24.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_199("ManyToOne", ManyToOne);
    var index_24;
    return {
        setters: [
            function (index_24_1) {
                index_24 = index_24_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToMany", ["typeorm/index"], function (exports_200, context_200) {
    "use strict";
    var __moduleName = context_200 && context_200.id;
    // todo: make decorators which use inverse side string separate
    /**
     * One-to-many relation allows to create type of relation when Entity2 can have multiple instances of Entity1.
     * Entity1 have only one Entity2. Entity1 is an owner of the relationship, and storages Entity2 id on its own side.
     */
    function OneToMany(typeFunction, inverseSide, options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-many",
                type: typeFunction,
                inverseSideProperty: inverseSide,
                options: options
            };
            index_25.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_200("OneToMany", OneToMany);
    var index_25;
    return {
        setters: [
            function (index_25_1) {
                index_25 = index_25_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/OneToOne", ["typeorm/index"], function (exports_201, context_201) {
    "use strict";
    var __moduleName = context_201 && context_201.id;
    /**
     * One-to-one relation allows to create direct relation between two entities. Entity1 have only one Entity2.
     * Entity1 is an owner of the relationship, and storages Entity1 id on its own side.
     */
    function OneToOne(typeFunction, inverseSideOrOptions, options) {
        var inverseSideProperty;
        if (typeof inverseSideOrOptions === "object") {
            options = inverseSideOrOptions;
        }
        else {
            inverseSideProperty = inverseSideOrOptions;
        }
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-one",
                type: typeFunction,
                inverseSideProperty: inverseSideProperty,
                options: options
            };
            index_26.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_201("OneToOne", OneToOne);
    var index_26;
    return {
        setters: [
            function (index_26_1) {
                index_26 = index_26_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/relations/RelationId", ["typeorm/index"], function (exports_202, context_202) {
    "use strict";
    var __moduleName = context_202 && context_202.id;
    /**
     * Special decorator used to extract relation id into separate entity property.
     */
    function RelationId(relation, alias, queryBuilderFactory) {
        return function (object, propertyName) {
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                relation: relation,
                alias: alias,
                queryBuilderFactory: queryBuilderFactory
            };
            index_27.getMetadataArgsStorage().relationIds.push(args);
        };
    }
    exports_202("RelationId", RelationId);
    var index_27;
    return {
        setters: [
            function (index_27_1) {
                index_27 = index_27_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/Entity", ["typeorm/index"], function (exports_203, context_203) {
    "use strict";
    var __moduleName = context_203 && context_203.id;
    /**
     * This decorator is used to mark classes that will be an entity (table or document depend on database type).
     * Database schema will be created for all classes decorated with it, and Repository can be retrieved and used for it.
     */
    function Entity(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "regular",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                engine: options && options.engine ? options.engine : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_28.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_203("Entity", Entity);
    var index_28;
    return {
        setters: [
            function (index_28_1) {
                index_28 = index_28_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/AbstractEntity", ["typeorm/index"], function (exports_204, context_204) {
    "use strict";
    var __moduleName = context_204 && context_204.id;
    /**
     * Abstract entity is a class that contains columns and relations for all entities that will inherit this entity.
     * Database table for the abstract entity is not created.
     *
     * @deprecated don't use it anymore. Now entity can extend any class with columns, no need to mark it with this decorator
     */
    function AbstractEntity() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "abstract"
            };
            index_29.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_204("AbstractEntity", AbstractEntity);
    var index_29;
    return {
        setters: [
            function (index_29_1) {
                index_29 = index_29_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClassEntityChild", ["typeorm/index"], function (exports_205, context_205) {
    "use strict";
    var __moduleName = context_205 && context_205.id;
    /**
     * Special type of the entity used in the class-table inherited tables.
     */
    function ClassEntityChild(tableName, options) {
        return function (target) {
            var args = {
                target: target,
                name: tableName,
                type: "class-table-child",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_30.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_205("ClassEntityChild", ClassEntityChild);
    var index_30;
    return {
        setters: [
            function (index_30_1) {
                index_30 = index_30_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/ClosureEntity", ["typeorm/index"], function (exports_206, context_206) {
    "use strict";
    var __moduleName = context_206 && context_206.id;
    /**
     * Used on a entities that stores its children in a tree using closure design pattern.
     */
    function ClosureEntity(name, options) {
        return function (target) {
            var args = {
                target: target,
                name: name,
                type: "closure",
                orderBy: options && options.orderBy ? options.orderBy : undefined,
                skipSchemaSync: !!(options && options.skipSchemaSync === true)
            };
            index_31.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_206("ClosureEntity", ClosureEntity);
    var index_31;
    return {
        setters: [
            function (index_31_1) {
                index_31 = index_31_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/EmbeddableEntity", ["typeorm/index"], function (exports_207, context_207) {
    "use strict";
    var __moduleName = context_207 && context_207.id;
    /**
     * This decorator is used on the entities that must be embedded into another entities.
     *
     * @deprecated don't use it anymore. Now entity can embed any class with columns, no need to mark it with this decorator
     */
    function EmbeddableEntity() {
        return function (target) {
            var args = {
                target: target,
                type: "embeddable",
                orderBy: undefined
            };
            index_32.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_207("EmbeddableEntity", EmbeddableEntity);
    var index_32;
    return {
        setters: [
            function (index_32_1) {
                index_32 = index_32_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/SingleEntityChild", ["typeorm/index"], function (exports_208, context_208) {
    "use strict";
    var __moduleName = context_208 && context_208.id;
    /**
     * Special type of the table used in the single-table inherited tables.
     */
    function SingleEntityChild() {
        return function (target) {
            var args = {
                target: target,
                name: undefined,
                type: "single-table-child",
                orderBy: undefined
            };
            index_33.getMetadataArgsStorage().tables.push(args);
        };
    }
    exports_208("SingleEntityChild", SingleEntityChild);
    var index_33;
    return {
        setters: [
            function (index_33_1) {
                index_33 = index_33_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/entity/TableInheritance", ["typeorm/index"], function (exports_209, context_209) {
    "use strict";
    var __moduleName = context_209 && context_209.id;
    /**
     * Sets what kind of table-inheritance table will use.
     */
    function TableInheritance(type) {
        return function (target) {
            var args = {
                target: target,
                type: type
            };
            index_34.getMetadataArgsStorage().inheritances.push(args);
        };
    }
    exports_209("TableInheritance", TableInheritance);
    var index_34;
    return {
        setters: [
            function (index_34_1) {
                index_34 = index_34_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/Transaction", ["typeorm/index"], function (exports_210, context_210) {
    "use strict";
    var __moduleName = context_210 && context_210.id;
    /**
     * Wraps some method into the transaction.
     * Note, method result will return a promise if this decorator applied.
     * Note, all database operations in the wrapped method should be executed using entity managed passed as a first parameter
     * into the wrapped method.
     * If you want to control at what position in your method parameters entity manager should be injected,
     * then use @TransactionEntityManager() decorator.
     */
    function Transaction(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return function (target, methodName, descriptor) {
            // save original method - we gonna need it
            var originalMethod = descriptor.value;
            // override method descriptor with proxy method
            descriptor.value = function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return index_35.getConnection(connectionName)
                    .manager
                    .transaction(function (entityManager) {
                    // gets all @TransactionEntityManager() decorator usages for this method
                    var indices = index_35.getMetadataArgsStorage()
                        .filterTransactionEntityManagers(target.constructor)
                        .filter(function (transactionEntityManager) { return transactionEntityManager.methodName === methodName; })
                        .map(function (transactionEntityManager) { return transactionEntityManager.index; });
                    var argsWithInjectedEntityManager;
                    if (indices.length) {
                        argsWithInjectedEntityManager = args.slice();
                        indices.forEach(function (index) { return argsWithInjectedEntityManager.splice(index, 0, entityManager); });
                    }
                    else {
                        argsWithInjectedEntityManager = [entityManager].concat(args);
                    }
                    return originalMethod.apply(_this, argsWithInjectedEntityManager);
                });
            };
        };
    }
    exports_210("Transaction", Transaction);
    var index_35;
    return {
        setters: [
            function (index_35_1) {
                index_35 = index_35_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/transaction/TransactionEntityManager", ["typeorm/index"], function (exports_211, context_211) {
    "use strict";
    var __moduleName = context_211 && context_211.id;
    /**
     * Injects transaction's entity manager into the method wrapped with @Transaction decorator.
     */
    function TransactionEntityManager() {
        return function (object, methodName, index) {
            var args = {
                target: object.constructor,
                methodName: methodName,
                index: index,
            };
            index_36.getMetadataArgsStorage().transactionEntityManagers.push(args);
        };
    }
    exports_211("TransactionEntityManager", TransactionEntityManager);
    var index_36;
    return {
        setters: [
            function (index_36_1) {
                index_36 = index_36_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeLevelColumn", ["typeorm/index", "typeorm/metadata/types/ColumnTypes"], function (exports_212, context_212) {
    "use strict";
    var __moduleName = context_212 && context_212.id;
    /**
     * Creates a "level"/"length" column to the table that holds a closure table.
     */
    function TreeLevelColumn() {
        return function (object, propertyName) {
            // const reflectedType = ColumnTypes.typeToString((Reflect as any).getMetadata("design:type", object, propertyName));
            // implicitly set a type, because this column's type cannot be anything else except number
            var options = { type: ColumnTypes_15.ColumnTypes.INTEGER };
            // create and register a new column metadata
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                mode: "treeLevel",
                options: options
            };
            index_37.getMetadataArgsStorage().columns.push(args);
        };
    }
    exports_212("TreeLevelColumn", TreeLevelColumn);
    var index_37, ColumnTypes_15;
    return {
        setters: [
            function (index_37_1) {
                index_37 = index_37_1;
            },
            function (ColumnTypes_15_1) {
                ColumnTypes_15 = ColumnTypes_15_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeParent", ["typeorm/index"], function (exports_213, context_213) {
    "use strict";
    var __moduleName = context_213 && context_213.id;
    /**
     * Marks a specific property of the class as a parent of the tree.
     */
    function TreeParent(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            var args = {
                isTreeParent: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "many-to-one",
                type: function () { return object.constructor; },
                options: options
            };
            index_38.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_213("TreeParent", TreeParent);
    var index_38;
    return {
        setters: [
            function (index_38_1) {
                index_38 = index_38_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/tree/TreeChildren", ["typeorm/index"], function (exports_214, context_214) {
    "use strict";
    var __moduleName = context_214 && context_214.id;
    /**
     * Marks a specific property of the class as a children of the tree.
     */
    function TreeChildren(options) {
        return function (object, propertyName) {
            if (!options)
                options = {};
            // now try to determine it its lazy relation
            var isLazy = options && options.lazy === true ? true : false;
            if (!isLazy && Reflect && Reflect.getMetadata) {
                var reflectedType = Reflect.getMetadata("design:type", object, propertyName);
                if (reflectedType && typeof reflectedType.name === "string" && reflectedType.name.toLowerCase() === "promise")
                    isLazy = true;
            }
            // add one-to-many relation for this 
            var args = {
                isTreeChildren: true,
                target: object.constructor,
                propertyName: propertyName,
                // propertyType: reflectedType,
                isLazy: isLazy,
                relationType: "one-to-many",
                type: function () { return object.constructor; },
                options: options
            };
            index_39.getMetadataArgsStorage().relations.push(args);
        };
    }
    exports_214("TreeChildren", TreeChildren);
    var index_39;
    return {
        setters: [
            function (index_39_1) {
                index_39 = index_39_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Index", ["typeorm/index"], function (exports_215, context_215) {
    "use strict";
    var __moduleName = context_215 && context_215.id;
    /**
     * Composite index must be set on entity classes and must specify entity's fields to be indexed.
     */
    function Index(nameOrFieldsOrOptions, maybeFieldsOrOptions, maybeOptions) {
        var name = typeof nameOrFieldsOrOptions === "string" ? nameOrFieldsOrOptions : undefined;
        var fields = typeof nameOrFieldsOrOptions === "string" ? maybeFieldsOrOptions : nameOrFieldsOrOptions;
        var options = (typeof nameOrFieldsOrOptions === "object" && !Array.isArray(nameOrFieldsOrOptions)) ? nameOrFieldsOrOptions : maybeOptions;
        if (!options)
            options = (typeof maybeFieldsOrOptions === "object" && !Array.isArray(maybeFieldsOrOptions)) ? maybeFieldsOrOptions : maybeOptions;
        return function (clsOrObject, propertyName) {
            var args = {
                target: propertyName ? clsOrObject.constructor : clsOrObject,
                name: name,
                columns: propertyName ? [propertyName] : fields,
                unique: options && options.unique ? true : false
            };
            index_40.getMetadataArgsStorage().indices.push(args);
        };
    }
    exports_215("Index", Index);
    var index_40;
    return {
        setters: [
            function (index_40_1) {
                index_40 = index_40_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/NamingStrategy", ["typeorm/index"], function (exports_216, context_216) {
    "use strict";
    var __moduleName = context_216 && context_216.id;
    /**
     * Decorator registers a new naming strategy to be used in naming things.
     *
     * todo: deprecate using naming strategies this way. use it without decorators
     * todo: but add multiple default naming strategies for use
     */
    function NamingStrategy(name) {
        return function (target) {
            var strategyName = name ? name : target.name;
            var args = {
                target: target,
                name: strategyName
            };
            index_41.getMetadataArgsStorage().namingStrategies.push(args);
        };
    }
    exports_216("NamingStrategy", NamingStrategy);
    var index_41;
    return {
        setters: [
            function (index_41_1) {
                index_41 = index_41_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/Embedded", ["typeorm/index"], function (exports_217, context_217) {
    "use strict";
    var __moduleName = context_217 && context_217.id;
    /**
     * Property in entity can be marked as Embedded, and on persist all columns from the embedded are mapped to the
     * single table of the entity where Embedded is used. And on hydration all columns which supposed to be in the
     * embedded will be mapped to it from the single table.
     *
     * Array option works only in monogodb.
     */
    function Embedded(typeFunction, options) {
        return function (object, propertyName) {
            var reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata("design:type", object, propertyName) : undefined;
            var isArray = reflectMetadataType === Array || (options && options.array === true) ? true : false;
            var args = {
                target: object.constructor,
                propertyName: propertyName,
                isArray: isArray,
                prefix: options && options.prefix !== undefined ? options.prefix : undefined,
                type: typeFunction
            };
            index_42.getMetadataArgsStorage().embeddeds.push(args);
        };
    }
    exports_217("Embedded", Embedded);
    var index_42;
    return {
        setters: [
            function (index_42_1) {
                index_42 = index_42_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/DiscriminatorValue", ["typeorm/index"], function (exports_218, context_218) {
    "use strict";
    var __moduleName = context_218 && context_218.id;
    /**
     * If entity is a child table of some table, it should have a discriminator value.
     * This decorator sets custom discriminator value for the entity.
     */
    function DiscriminatorValue(value) {
        return function (target) {
            var args = {
                target: target,
                value: value
            };
            index_43.getMetadataArgsStorage().discriminatorValues.push(args);
        };
    }
    exports_218("DiscriminatorValue", DiscriminatorValue);
    var index_43;
    return {
        setters: [
            function (index_43_1) {
                index_43 = index_43_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/decorator/EntityRepository", ["typeorm/index"], function (exports_219, context_219) {
    "use strict";
    var __moduleName = context_219 && context_219.id;
    /**
     * Used to declare a class as a custom repository.
     * Custom repository can either manage some specific entity, either just be generic.
     * Custom repository can extend AbstractRepository or regular Repository or TreeRepository.
     */
    function EntityRepository(entity) {
        return function (target) {
            var args = {
                target: target,
                entity: entity,
            };
            index_44.getMetadataArgsStorage().entityRepositories.push(args);
        };
    }
    exports_219("EntityRepository", EntityRepository);
    var index_44;
    return {
        setters: [
            function (index_44_1) {
                index_44 = index_44_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/repository/EntityModel", ["typeorm/index"], function (exports_220, context_220) {
    "use strict";
    var __moduleName = context_220 && context_220.id;
    var index_45, EntityModel;
    return {
        setters: [
            function (index_45_1) {
                index_45 = index_45_1;
            }
        ],
        execute: function () {
            /**
             * Base abstract entity for all entities, used in ActiveRecord patterns.
             */
            EntityModel = (function () {
                function EntityModel() {
                }
                // -------------------------------------------------------------------------
                // Public Methods
                // -------------------------------------------------------------------------
                /**
                 * Checks if entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                EntityModel.prototype.hasId = function () {
                    return this.constructor.getRepository().hasId(this);
                };
                /**
                 * Saves current entity in the database.
                 * If entity does not exist in the database then inserts, otherwise updates.
                 */
                EntityModel.prototype.save = function () {
                    return this.constructor.getRepository().save(this);
                };
                /**
                 * Removes current entity from the database.
                 */
                EntityModel.prototype.remove = function () {
                    return this.constructor.getRepository().remove(this);
                };
                // -------------------------------------------------------------------------
                // Public Static Methods
                // -------------------------------------------------------------------------
                /**
                 * Sets connection to be used by entity.
                 */
                EntityModel.useConnection = function (connection) {
                    this.usedConnection = connection;
                };
                /**
                 * Gets current entity's Repository.
                 */
                EntityModel.getRepository = function () {
                    var connection = this.usedConnection || index_45.getConnection();
                    return connection.getRepository(this);
                };
                Object.defineProperty(EntityModel, "target", {
                    /**
                     * Returns object that is managed by this repository.
                     * If this repository manages entity from schema,
                     * then it returns a name of that schema instead.
                     */
                    get: function () {
                        return this.getRepository().target;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Checks entity has an id.
                 * If entity composite compose ids, it will check them all.
                 */
                EntityModel.hasId = function (entity) {
                    return this.getRepository().hasId(entity);
                };
                /**
                 * Gets entity mixed id.
                 */
                EntityModel.getId = function (entity) {
                    return this.getRepository().getId(entity);
                };
                /**
                 * Creates a new query builder that can be used to build a sql query.
                 */
                EntityModel.createQueryBuilder = function (alias) {
                    return this.getRepository().createQueryBuilder(alias);
                };
                /**
                 * Creates a new entity instance.
                 */
                EntityModel.create = function () {
                    return this.getRepository().create();
                };
                /**
                 * Merges multiple entities (or entity-like objects) into a given entity.
                 */
                EntityModel.merge = function (mergeIntoEntity) {
                    var entityLikes = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        entityLikes[_i - 1] = arguments[_i];
                    }
                    return (_a = this.getRepository()).merge.apply(_a, [mergeIntoEntity].concat(entityLikes));
                    var _a;
                };
                /**
                 * Creates a new entity from the given plan javascript object. If entity already exist in the database, then
                 * it loads it (and everything related to it), replaces all values with the new ones from the given object
                 * and returns this new entity. This new entity is actually a loaded from the db entity with all properties
                 * replaced from the new object.
                 *
                 * Note that given entity-like object must have an entity id / primary key to find entity by.
                 * Returns undefined if entity with given id was not found.
                 */
                EntityModel.preload = function (entityLike) {
                    return this.getRepository().preload(entityLike);
                };
                /**
                 * Saves one or many given entities.
                 */
                EntityModel.save = function (entityOrEntities, options) {
                    return this.getRepository().save(entityOrEntities, options);
                };
                /**
                 * Updates entity partially. Entity can be found by a given conditions.
                 */
                EntityModel.update = function (conditionsOrFindOptions, partialEntity, options) {
                    return this.getRepository().update(conditionsOrFindOptions, partialEntity, options);
                };
                /**
                 * Updates entity partially. Entity will be found by a given id.
                 */
                EntityModel.updateById = function (id, partialEntity, options) {
                    return this.getRepository().updateById(id, partialEntity, options);
                };
                /**
                 * Removes one or many given entities.
                 */
                EntityModel.remove = function (entityOrEntities, options) {
                    return this.getRepository().remove(entityOrEntities, options);
                };
                /**
                 * Removes entity by a given entity id.
                 */
                EntityModel.removeById = function (id, options) {
                    return this.getRepository().removeById(id, options);
                };
                /**
                 * Counts entities that match given find options or conditions.
                 */
                EntityModel.count = function (optionsOrConditions) {
                    return this.getRepository().count(optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 */
                EntityModel.find = function (optionsOrConditions) {
                    return this.getRepository().find(optionsOrConditions);
                };
                /**
                 * Finds entities that match given find options or conditions.
                 * Also counts all entities that match given conditions,
                 * but ignores pagination settings (from and take options).
                 */
                EntityModel.findAndCount = function (optionsOrConditions) {
                    return this.getRepository().findAndCount(optionsOrConditions);
                };
                /**
                 * Finds entities by ids.
                 * Optionally find options can be applied.
                 */
                EntityModel.findByIds = function (ids, optionsOrConditions) {
                    return this.getRepository().findByIds(ids, optionsOrConditions);
                };
                /**
                 * Finds first entity that matches given conditions.
                 */
                EntityModel.findOne = function (optionsOrConditions) {
                    return this.getRepository().findOne(optionsOrConditions);
                };
                /**
                 * Finds entity by given id.
                 * Optionally find options or conditions can be applied.
                 */
                EntityModel.findOneById = function (id, optionsOrConditions) {
                    return this.getRepository().findOneById(id, optionsOrConditions);
                };
                /**
                 * Executes a raw SQL query and returns a raw database results.
                 * Raw query execution is supported only by relational databases (MongoDB is not supported).
                 */
                EntityModel.query = function (query, parameters) {
                    return this.getRepository().query(query, parameters);
                };
                /**
                 * Clears all the data from the given table/collection (truncates/drops it).
                 */
                EntityModel.clear = function () {
                    return this.getRepository().clear();
                };
                return EntityModel;
            }());
            exports_220("EntityModel", EntityModel);
        }
    };
});
System.register("typeorm/index", ["typeorm/connection/ConnectionManager", "typeorm/metadata-args/MetadataArgsStorage", "typeorm/container", "typeorm/platform/PlatformTools", "typeorm/decorator/columns/Column", "typeorm/decorator/columns/CreateDateColumn", "typeorm/decorator/columns/DiscriminatorColumn", "typeorm/decorator/columns/PrimaryGeneratedColumn", "typeorm/decorator/columns/PrimaryColumn", "typeorm/decorator/columns/UpdateDateColumn", "typeorm/decorator/columns/VersionColumn", "typeorm/decorator/columns/ObjectIdColumn", "typeorm/decorator/listeners/AfterInsert", "typeorm/decorator/listeners/AfterLoad", "typeorm/decorator/listeners/AfterRemove", "typeorm/decorator/listeners/AfterUpdate", "typeorm/decorator/listeners/BeforeInsert", "typeorm/decorator/listeners/BeforeRemove", "typeorm/decorator/listeners/BeforeUpdate", "typeorm/decorator/listeners/EventSubscriber", "typeorm/decorator/relations/RelationCount", "typeorm/decorator/relations/JoinColumn", "typeorm/decorator/relations/JoinTable", "typeorm/decorator/relations/ManyToMany", "typeorm/decorator/relations/ManyToOne", "typeorm/decorator/relations/OneToMany", "typeorm/decorator/relations/OneToOne", "typeorm/decorator/relations/RelationId", "typeorm/decorator/entity/Entity", "typeorm/decorator/entity/AbstractEntity", "typeorm/decorator/entity/ClassEntityChild", "typeorm/decorator/entity/ClosureEntity", "typeorm/decorator/entity/EmbeddableEntity", "typeorm/decorator/entity/SingleEntityChild", "typeorm/decorator/entity/TableInheritance", "typeorm/decorator/transaction/Transaction", "typeorm/decorator/transaction/TransactionEntityManager", "typeorm/decorator/tree/TreeLevelColumn", "typeorm/decorator/tree/TreeParent", "typeorm/decorator/tree/TreeChildren", "typeorm/decorator/Index", "typeorm/decorator/NamingStrategy", "typeorm/decorator/Embedded", "typeorm/decorator/DiscriminatorValue", "typeorm/decorator/EntityRepository", "typeorm/schema-builder/schema/ColumnSchema", "typeorm/schema-builder/schema/ForeignKeySchema", "typeorm/schema-builder/schema/IndexSchema", "typeorm/schema-builder/schema/PrimaryKeySchema", "typeorm/schema-builder/schema/TableSchema", "typeorm/driver/mongodb/typings", "typeorm/connection/Connection", "typeorm/query-builder/QueryBuilder", "typeorm/entity-manager/EntityManager", "typeorm/entity-manager/MongoEntityManager", "typeorm/naming-strategy/DefaultNamingStrategy", "typeorm/repository/Repository", "typeorm/repository/TreeRepository", "typeorm/repository/SpecificRepository", "typeorm/repository/MongoRepository", "typeorm/repository/EntityModel"], function (exports_221, context_221) {
    "use strict";
    var __moduleName = context_221 && context_221.id;
    // -------------------------------------------------------------------------
    // Deprecated
    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------
    // Commonly used functionality
    // -------------------------------------------------------------------------
    /**
     * Gets metadata args storage.
     */
    function getMetadataArgsStorage() {
        // we should store metadata storage in a global variable otherwise it brings too much problems
        // one of the problem is that if any entity (or any other) will be imported before consumer will call
        // useContainer method with his own container implementation, that entity will be registered in the
        // old old container (default one post probably) and consumer will his entity.
        // calling useContainer before he imports any entity (or any other) is not always convenient.
        // another reason is that when we run migrations typeorm is being called from a global package
        // and it may load entities which register decorators in typeorm of local package
        // this leads to impossibility of usage of entities in migrations and cli related operations
        var globalScope = PlatformTools_11.PlatformTools.getGlobalVariable();
        if (!globalScope.typeormMetadataArgsStorage)
            globalScope.typeormMetadataArgsStorage = new MetadataArgsStorage_2.MetadataArgsStorage();
        return globalScope.typeormMetadataArgsStorage;
    }
    exports_221("getMetadataArgsStorage", getMetadataArgsStorage);
    /**
     * Gets a ConnectionManager which creates connections.
     */
    function getConnectionManager() {
        return container_2.getFromContainer(ConnectionManager_1.ConnectionManager);
    }
    exports_221("getConnectionManager", getConnectionManager);
    /**
     * Creates connection and and registers it in the manager.
     */
    function createConnection(optionsOrConnectionNameFromConfig, ormConfigPath) {
        return getConnectionManager().createAndConnect(optionsOrConnectionNameFromConfig, ormConfigPath);
    }
    exports_221("createConnection", createConnection);
    /**
     * Creates connections and and registers them in the manager.
     */
    function createConnections(optionsOrOrmConfigFilePath) {
        return getConnectionManager().createAndConnectToAll(optionsOrOrmConfigFilePath);
    }
    exports_221("createConnections", createConnections);
    /**
     * Gets connection from the connection manager.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getConnection(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName);
    }
    exports_221("getConnection", getConnection);
    /**
     * Gets entity manager from the connection.
     * If connection name wasn't specified, then "default" connection will be retrieved.
     */
    function getEntityManager(connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).manager;
    }
    exports_221("getEntityManager", getEntityManager);
    /**
     * Gets repository for the given entity class or name.
     */
    function getRepository(entityClassOrName, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getRepository(entityClassOrName);
    }
    exports_221("getRepository", getRepository);
    /**
     * Gets tree repository for the given entity class or name.
     */
    function getTreeRepository(entityClassOrName, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getTreeRepository(entityClassOrName);
    }
    exports_221("getTreeRepository", getTreeRepository);
    /**
     * Gets mongodb repository for the given entity class or name.
     */
    function getMongoRepository(entityClassOrName, connectionName) {
        if (connectionName === void 0) { connectionName = "default"; }
        return getConnectionManager().get(connectionName).getMongoRepository(entityClassOrName);
    }
    exports_221("getMongoRepository", getMongoRepository);
    var ConnectionManager_1, MetadataArgsStorage_2, container_2, PlatformTools_11;
    var exportedNames_1 = {
        "getMetadataArgsStorage": true,
        "getConnectionManager": true,
        "createConnection": true,
        "createConnections": true,
        "getConnection": true,
        "getEntityManager": true,
        "getRepository": true,
        "getTreeRepository": true,
        "getMongoRepository": true,
        "Connection": true,
        "ConnectionManager": true,
        "QueryBuilder": true,
        "EntityManager": true,
        "MongoEntityManager": true,
        "DefaultNamingStrategy": true,
        "Repository": true,
        "TreeRepository": true,
        "SpecificRepository": true,
        "MongoRepository": true,
        "EntityModel": true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_221(exports);
    }
    return {
        setters: [
            function (ConnectionManager_1_1) {
                ConnectionManager_1 = ConnectionManager_1_1;
                exports_221({
                    "ConnectionManager": ConnectionManager_1_1["ConnectionManager"]
                });
            },
            function (MetadataArgsStorage_2_1) {
                MetadataArgsStorage_2 = MetadataArgsStorage_2_1;
            },
            function (container_2_1) {
                container_2 = container_2_1;
                exportStar_1(container_2_1);
            },
            function (PlatformTools_11_1) {
                PlatformTools_11 = PlatformTools_11_1;
            },
            function (Column_1_1) {
                exportStar_1(Column_1_1);
            },
            function (CreateDateColumn_1_1) {
                exportStar_1(CreateDateColumn_1_1);
            },
            function (DiscriminatorColumn_1_1) {
                exportStar_1(DiscriminatorColumn_1_1);
            },
            function (PrimaryGeneratedColumn_1_1) {
                exportStar_1(PrimaryGeneratedColumn_1_1);
            },
            function (PrimaryColumn_1_1) {
                exportStar_1(PrimaryColumn_1_1);
            },
            function (UpdateDateColumn_1_1) {
                exportStar_1(UpdateDateColumn_1_1);
            },
            function (VersionColumn_1_1) {
                exportStar_1(VersionColumn_1_1);
            },
            function (ObjectIdColumn_1_1) {
                exportStar_1(ObjectIdColumn_1_1);
            },
            function (AfterInsert_1_1) {
                exportStar_1(AfterInsert_1_1);
            },
            function (AfterLoad_1_1) {
                exportStar_1(AfterLoad_1_1);
            },
            function (AfterRemove_1_1) {
                exportStar_1(AfterRemove_1_1);
            },
            function (AfterUpdate_1_1) {
                exportStar_1(AfterUpdate_1_1);
            },
            function (BeforeInsert_1_1) {
                exportStar_1(BeforeInsert_1_1);
            },
            function (BeforeRemove_1_1) {
                exportStar_1(BeforeRemove_1_1);
            },
            function (BeforeUpdate_1_1) {
                exportStar_1(BeforeUpdate_1_1);
            },
            function (EventSubscriber_1_1) {
                exportStar_1(EventSubscriber_1_1);
            },
            function (RelationCount_1_1) {
                exportStar_1(RelationCount_1_1);
                exportStar_1(RelationCount_1_1);
            },
            function (JoinColumn_1_1) {
                exportStar_1(JoinColumn_1_1);
            },
            function (JoinTable_1_1) {
                exportStar_1(JoinTable_1_1);
            },
            function (ManyToMany_1_1) {
                exportStar_1(ManyToMany_1_1);
            },
            function (ManyToOne_1_1) {
                exportStar_1(ManyToOne_1_1);
            },
            function (OneToMany_1_1) {
                exportStar_1(OneToMany_1_1);
            },
            function (OneToOne_1_1) {
                exportStar_1(OneToOne_1_1);
            },
            function (RelationId_1_1) {
                exportStar_1(RelationId_1_1);
            },
            function (Entity_1_1) {
                exportStar_1(Entity_1_1);
                exportStar_1(Entity_1_1);
            },
            function (AbstractEntity_1_1) {
                exportStar_1(AbstractEntity_1_1);
            },
            function (ClassEntityChild_1_1) {
                exportStar_1(ClassEntityChild_1_1);
            },
            function (ClosureEntity_1_1) {
                exportStar_1(ClosureEntity_1_1);
            },
            function (EmbeddableEntity_1_1) {
                exportStar_1(EmbeddableEntity_1_1);
            },
            function (SingleEntityChild_1_1) {
                exportStar_1(SingleEntityChild_1_1);
            },
            function (TableInheritance_1_1) {
                exportStar_1(TableInheritance_1_1);
            },
            function (Transaction_1_1) {
                exportStar_1(Transaction_1_1);
            },
            function (TransactionEntityManager_1_1) {
                exportStar_1(TransactionEntityManager_1_1);
            },
            function (TreeLevelColumn_1_1) {
                exportStar_1(TreeLevelColumn_1_1);
            },
            function (TreeParent_1_1) {
                exportStar_1(TreeParent_1_1);
            },
            function (TreeChildren_1_1) {
                exportStar_1(TreeChildren_1_1);
            },
            function (Index_1_1) {
                exportStar_1(Index_1_1);
            },
            function (NamingStrategy_1_1) {
                exportStar_1(NamingStrategy_1_1);
            },
            function (Embedded_1_1) {
                exportStar_1(Embedded_1_1);
            },
            function (DiscriminatorValue_1_1) {
                exportStar_1(DiscriminatorValue_1_1);
            },
            function (EntityRepository_1_1) {
                exportStar_1(EntityRepository_1_1);
            },
            function (ColumnSchema_10_1) {
                exportStar_1(ColumnSchema_10_1);
            },
            function (ForeignKeySchema_7_1) {
                exportStar_1(ForeignKeySchema_7_1);
            },
            function (IndexSchema_6_1) {
                exportStar_1(IndexSchema_6_1);
            },
            function (PrimaryKeySchema_7_1) {
                exportStar_1(PrimaryKeySchema_7_1);
            },
            function (TableSchema_9_1) {
                exportStar_1(TableSchema_9_1);
            },
            function (typings_1_1) {
                exportStar_1(typings_1_1);
            },
            function (Connection_2_1) {
                exports_221({
                    "Connection": Connection_2_1["Connection"]
                });
            },
            function (QueryBuilder_7_1) {
                exports_221({
                    "QueryBuilder": QueryBuilder_7_1["QueryBuilder"]
                });
            },
            function (EntityManager_3_1) {
                exports_221({
                    "EntityManager": EntityManager_3_1["EntityManager"]
                });
            },
            function (MongoEntityManager_2_1) {
                exports_221({
                    "MongoEntityManager": MongoEntityManager_2_1["MongoEntityManager"]
                });
            },
            function (DefaultNamingStrategy_2_1) {
                exports_221({
                    "DefaultNamingStrategy": DefaultNamingStrategy_2_1["DefaultNamingStrategy"]
                });
            },
            function (Repository_5_1) {
                exports_221({
                    "Repository": Repository_5_1["Repository"]
                });
            },
            function (TreeRepository_2_1) {
                exports_221({
                    "TreeRepository": TreeRepository_2_1["TreeRepository"]
                });
            },
            function (SpecificRepository_2_1) {
                exports_221({
                    "SpecificRepository": SpecificRepository_2_1["SpecificRepository"]
                });
            },
            function (MongoRepository_2_1) {
                exports_221({
                    "MongoRepository": MongoRepository_2_1["MongoRepository"]
                });
            },
            function (EntityModel_1_1) {
                exports_221({
                    "EntityModel": EntityModel_1_1["EntityModel"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm", ["typeorm/index"], function (exports_222, context_222) {
    "use strict";
    var __moduleName = context_222 && context_222.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_222(exports);
    }
    return {
        setters: [
            function (index_46_1) {
                exportStar_2(index_46_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("typeorm/metadata-args/EntityMetadataArgs", [], function (exports_223, context_223) {
    "use strict";
    var __moduleName = context_223 && context_223.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("typeorm/connection/error/CannotGetEntityManagerNotConnectedError", [], function (exports_224, context_224) {
    "use strict";
    var __moduleName = context_224 && context_224.id;
    var CannotGetEntityManagerNotConnectedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access entity manager before connection is established.
             */
            CannotGetEntityManagerNotConnectedError = (function (_super) {
                __extends(CannotGetEntityManagerNotConnectedError, _super);
                function CannotGetEntityManagerNotConnectedError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "CannotGetEntityManagerNotConnectedError";
                    _this.message = "Cannot get entity manager for \"" + connectionName + "\" connection because connection is not yet established.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return CannotGetEntityManagerNotConnectedError;
            }(Error));
            exports_224("CannotGetEntityManagerNotConnectedError", CannotGetEntityManagerNotConnectedError);
        }
    };
});
System.register("typeorm/connection/error/NoConnectionForRepositoryError", [], function (exports_225, context_225) {
    "use strict";
    var __moduleName = context_225 && context_225.id;
    var NoConnectionForRepositoryError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when consumer tries to access repository before connection is established.
             */
            NoConnectionForRepositoryError = (function (_super) {
                __extends(NoConnectionForRepositoryError, _super);
                function NoConnectionForRepositoryError(connectionName) {
                    var _this = _super.call(this) || this;
                    _this.name = "NoConnectionForRepositoryError";
                    _this.message = "Cannot get a Repository for \"" + connectionName + " connection, because connection with the database " +
                        "is not established yet. Call connection#connect method to establish connection.";
                    _this.stack = new Error().stack;
                    return _this;
                }
                return NoConnectionForRepositoryError;
            }(Error));
            exports_225("NoConnectionForRepositoryError", NoConnectionForRepositoryError);
        }
    };
});
System.register("typeorm/driver/error/DriverPackageLoadError", [], function (exports_226, context_226) {
    "use strict";
    var __moduleName = context_226 && context_226.id;
    var DriverPackageLoadError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown when some unexpected error occur on driver packages load.
             */
            DriverPackageLoadError = (function (_super) {
                __extends(DriverPackageLoadError, _super);
                function DriverPackageLoadError() {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPackageLoadError";
                    _this.message = "Cannot load driver dependencies. Try to install all required dependencies.";
                    return _this;
                }
                return DriverPackageLoadError;
            }(Error));
            exports_226("DriverPackageLoadError", DriverPackageLoadError);
        }
    };
});
System.register("typeorm/driver/error/DriverPoolingNotSupportedError", [], function (exports_227, context_227) {
    "use strict";
    var __moduleName = context_227 && context_227.id;
    var DriverPoolingNotSupportedError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown if database driver does not support pooling.
             */
            DriverPoolingNotSupportedError = (function (_super) {
                __extends(DriverPoolingNotSupportedError, _super);
                function DriverPoolingNotSupportedError(driverName) {
                    var _this = _super.call(this) || this;
                    _this.name = "DriverPoolingNotSupportedError";
                    _this.message = "Connection pooling is not supported by (" + driverName + ") driver.";
                    return _this;
                }
                return DriverPoolingNotSupportedError;
            }(Error));
            exports_227("DriverPoolingNotSupportedError", DriverPoolingNotSupportedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MetadataAlreadyExistsError", [], function (exports_228, context_228) {
    "use strict";
    var __moduleName = context_228 && context_228.id;
    var MetadataAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataAlreadyExistsError = (function (_super) {
                __extends(MetadataAlreadyExistsError, _super);
                function MetadataAlreadyExistsError(metadataType, constructor, propertyName) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataAlreadyExistsError";
                    _this.message = metadataType + " metadata already exists for the class constructor " + JSON.stringify(constructor) +
                        (propertyName ? " on property " + propertyName : ". If you previously renamed or moved entity class, make sure" +
                            " that compiled version of old entity class source wasn't left in the compiler output directory.");
                    return _this;
                }
                return MetadataAlreadyExistsError;
            }(Error));
            exports_228("MetadataAlreadyExistsError", MetadataAlreadyExistsError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MetadataWithSuchNameAlreadyExistsError", [], function (exports_229, context_229) {
    "use strict";
    var __moduleName = context_229 && context_229.id;
    var MetadataWithSuchNameAlreadyExistsError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MetadataWithSuchNameAlreadyExistsError = (function (_super) {
                __extends(MetadataWithSuchNameAlreadyExistsError, _super);
                function MetadataWithSuchNameAlreadyExistsError(metadataType, name) {
                    var _this = _super.call(this) || this;
                    _this.name = "MetadataWithSuchNameAlreadyExistsError";
                    _this.message = metadataType + " metadata with such name " + name + " already exists. " +
                        "Do you apply decorator twice? Or maybe try to change a name?";
                    return _this;
                }
                return MetadataWithSuchNameAlreadyExistsError;
            }(Error));
            exports_229("MetadataWithSuchNameAlreadyExistsError", MetadataWithSuchNameAlreadyExistsError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingJoinColumnError", [], function (exports_230, context_230) {
    "use strict";
    var __moduleName = context_230 && context_230.id;
    var MissingJoinColumnError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinColumnError = (function (_super) {
                __extends(MissingJoinColumnError, _super);
                function MissingJoinColumnError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinColumnError";
                    if (relation.inverseRelation) {
                        _this.message = "JoinColumn is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " one-to-one relationship. ") +
                            "You need to put JoinColumn decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinColumn is missing on " + entityMetadata.name + "#" + relation.propertyName + " one-to-one relationship. " +
                            "You need to put JoinColumn decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinColumnError;
            }(Error));
            exports_230("MissingJoinColumnError", MissingJoinColumnError);
        }
    };
});
System.register("typeorm/metadata-builder/error/MissingJoinTableError", [], function (exports_231, context_231) {
    "use strict";
    var __moduleName = context_231 && context_231.id;
    var MissingJoinTableError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            MissingJoinTableError = (function (_super) {
                __extends(MissingJoinTableError, _super);
                function MissingJoinTableError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "MissingJoinTableError";
                    if (relation.inverseRelation) {
                        _this.message = "JoinTable is missing on both sides of " + entityMetadata.name + "#" + relation.propertyName + " and " +
                            (relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " many-to-many relationship. ") +
                            "You need to put decorator decorator on one of the sides.";
                    }
                    else {
                        _this.message = "JoinTable is missing on " + entityMetadata.name + "#" + relation.propertyName + " many-to-many relationship. " +
                            "You need to put JoinTable decorator on it.";
                    }
                    return _this;
                }
                return MissingJoinTableError;
            }(Error));
            exports_231("MissingJoinTableError", MissingJoinTableError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinColumnIsNotAllowedError", [], function (exports_232, context_232) {
    "use strict";
    var __moduleName = context_232 && context_232.id;
    var UsingJoinColumnIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnIsNotAllowedError = (function (_super) {
                __extends(UsingJoinColumnIsNotAllowedError, _super);
                function UsingJoinColumnIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnIsNotAllowedError";
                    _this.message = "Using JoinColumn on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        "You can use JoinColumn only on one-to-one and many-to-one relations.";
                    return _this;
                }
                return UsingJoinColumnIsNotAllowedError;
            }(Error));
            exports_232("UsingJoinColumnIsNotAllowedError", UsingJoinColumnIsNotAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinColumnOnlyOnOneSideAllowedError", [], function (exports_233, context_233) {
    "use strict";
    var __moduleName = context_233 && context_233.id;
    var UsingJoinColumnOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinColumnOnlyOnOneSideAllowedError = (function (_super) {
                __extends(UsingJoinColumnOnlyOnOneSideAllowedError, _super);
                function UsingJoinColumnOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinColumnOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinColumn is allowed only on one side of the one-to-one relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinTable decorator only on it.";
                    return _this;
                }
                return UsingJoinColumnOnlyOnOneSideAllowedError;
            }(Error));
            exports_233("UsingJoinColumnOnlyOnOneSideAllowedError", UsingJoinColumnOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinTableIsNotAllowedError", [], function (exports_234, context_234) {
    "use strict";
    var __moduleName = context_234 && context_234.id;
    var UsingJoinTableIsNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableIsNotAllowedError = (function (_super) {
                __extends(UsingJoinTableIsNotAllowedError, _super);
                function UsingJoinTableIsNotAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableIsNotAllowedError";
                    _this.message = "Using JoinTable on " + entityMetadata.name + "#" + relation.propertyName + " is wrong. " +
                        (entityMetadata.name + "#" + relation.propertyName + " has " + relation.relationType + " relation, ") +
                        "however you can use JoinTable only on many-to-many relations.";
                    return _this;
                }
                return UsingJoinTableIsNotAllowedError;
            }(Error));
            exports_234("UsingJoinTableIsNotAllowedError", UsingJoinTableIsNotAllowedError);
        }
    };
});
System.register("typeorm/metadata-builder/error/UsingJoinTableOnlyOnOneSideAllowedError", [], function (exports_235, context_235) {
    "use strict";
    var __moduleName = context_235 && context_235.id;
    var UsingJoinTableOnlyOnOneSideAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            UsingJoinTableOnlyOnOneSideAllowedError = (function (_super) {
                __extends(UsingJoinTableOnlyOnOneSideAllowedError, _super);
                function UsingJoinTableOnlyOnOneSideAllowedError(entityMetadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "UsingJoinTableOnlyOnOneSideAllowedError";
                    _this.message = "Using JoinTable is allowed only on one side of the many-to-many relationship. " +
                        ("Both " + entityMetadata.name + "#" + relation.propertyName + " and " + relation.inverseEntityMetadata.name + "#" + relation.inverseRelation.propertyName + " ") +
                        "has JoinTable decorators. Choose one of them and left JoinColumn decorator only on it.";
                    return _this;
                }
                return UsingJoinTableOnlyOnOneSideAllowedError;
            }(Error));
            exports_235("UsingJoinTableOnlyOnOneSideAllowedError", UsingJoinTableOnlyOnOneSideAllowedError);
        }
    };
});
System.register("typeorm/persistence/error/CascadesNotAllowedError", [], function (exports_236, context_236) {
    "use strict";
    var __moduleName = context_236 && context_236.id;
    var CascadesNotAllowedError;
    return {
        setters: [],
        execute: function () {
            /**
             */
            CascadesNotAllowedError = (function (_super) {
                __extends(CascadesNotAllowedError, _super);
                // todo: remove metadata attribute since its present in relation attribute
                function CascadesNotAllowedError(type, metadata, relation) {
                    var _this = _super.call(this) || this;
                    _this.name = "CascadesNotAllowedError";
                    _this.message = "Cascades (" + type + ") are not allowed for the given relation " + metadata.name + "#" + relation.joinColumns[0].referencedColumn.databaseName;
                    return _this;
                }
                return CascadesNotAllowedError;
            }(Error));
            exports_236("CascadesNotAllowedError", CascadesNotAllowedError);
        }
    };
});
System.register("typeorm/persistence/error/PersistedEntityNotFoundError", [], function (exports_237, context_237) {
    "use strict";
    var __moduleName = context_237 && context_237.id;
    var PersistedEntityNotFoundError;
    return {
        setters: [],
        execute: function () {
            /**
             * Thrown . Theoretically can't be thrown.
             */
            PersistedEntityNotFoundError = (function (_super) {
                __extends(PersistedEntityNotFoundError, _super);
                function PersistedEntityNotFoundError() {
                    var _this = _super.call(this) || this;
                    _this.name = "PersistedEntityNotFoundError";
                    _this.message = "Internal error. Persisted entity was not found in the list of prepared operated entities.";
                    return _this;
                }
                return PersistedEntityNotFoundError;
            }(Error));
            exports_237("PersistedEntityNotFoundError", PersistedEntityNotFoundError);
        }
    };
});

//# sourceMappingURL=typeorm-browser.js.map
