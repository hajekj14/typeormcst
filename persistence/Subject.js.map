{"version":3,"sources":["../../src/persistence/Subject.ts"],"names":[],"mappings":"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","file":"Subject.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {ColumnTypes} from \"../metadata/types/ColumnTypes\";\r\nimport {DataTransformationUtils} from \"../util/DataTransformationUtils\";\r\n\r\n/**\r\n * Holds information about insert operation into junction table.\r\n */\r\nexport interface JunctionInsert {\r\n\r\n    /**\r\n     * Relation of the junction table.\r\n     */\r\n    relation: RelationMetadata;\r\n\r\n    /**\r\n     * Entities that needs to be \"bind\" to the subject.\r\n     */\r\n    junctionEntities: ObjectLiteral[];\r\n}\r\n\r\n/**\r\n * Holds information about remove operation from the junction table.\r\n */\r\nexport interface JunctionRemove {\r\n\r\n    /**\r\n     * Relation of the junction table.\r\n     */\r\n    relation: RelationMetadata;\r\n\r\n    /**\r\n     * Entity ids that needs to be removed from the junction table.\r\n     */\r\n    junctionRelationIds: any[];\r\n}\r\n\r\n/**\r\n * Holds information about relation update in some subject.\r\n */\r\nexport interface RelationUpdate {\r\n\r\n    /**\r\n     * Relation that needs to be updated.\r\n     */\r\n    relation: RelationMetadata;\r\n\r\n    /**\r\n     * New value that needs to be set into into new relation.\r\n     */\r\n    value: any;\r\n}\r\n\r\n/**\r\n * Subject is a subject of persistence.\r\n * It holds information about each entity that needs to be persisted:\r\n * - what entity should be persisted\r\n * - what is database representation of the persisted entity\r\n * - what entity metadata of the persisted entity\r\n * - what is allowed to with persisted entity (insert/update/remove)\r\n *\r\n * Having this collection of subjects we can perform database queries.\r\n */\r\nexport class Subject {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Persist entity (changed entity).\r\n     */\r\n    private _persistEntity?: ObjectLiteral;\r\n\r\n    /**\r\n     * Database entity.\r\n     */\r\n    private _databaseEntity?: ObjectLiteral;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Readonly Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Entity metadata of the subject entity.\r\n     */\r\n    readonly metadata: EntityMetadata;\r\n\r\n    /**\r\n     * Date when this entity is persisted.\r\n     */\r\n    readonly date: Date = new Date();\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Indicates if this subject can be inserted into the database.\r\n     * This means that this subject either is newly persisted, either can be inserted by cascades.\r\n     */\r\n    canBeInserted: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this subject can be updated in the database.\r\n     * This means that this subject either was persisted, either can be updated by cascades.\r\n     */\r\n    canBeUpdated: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this subject MUST be removed from the database.\r\n     * This means that this subject either was removed, either was removed by cascades.\r\n     */\r\n    mustBeRemoved: boolean = false;\r\n\r\n    /**\r\n     * Differentiated columns between persisted and database entities.\r\n     */\r\n    diffColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Differentiated relations between persisted and database entities.\r\n     */\r\n    diffRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * List of relations which need to be unset.\r\n     * This is used to update relation from inverse side.\r\n     */\r\n    relationUpdates: RelationUpdate[] = [];\r\n\r\n    /**\r\n     * Records that needs to be inserted into the junction tables of this subject.\r\n     */\r\n    junctionInserts: JunctionInsert[] = [];\r\n\r\n    /**\r\n     * Records that needs to be removed from the junction tables of this subject.\r\n     */\r\n    junctionRemoves: JunctionRemove[] = [];\r\n\r\n    /**\r\n     * When subject is newly persisted it may have a generated entity id.\r\n     * In this case it should be written here.\r\n     */\r\n    newlyGeneratedId?: any;\r\n\r\n    /**\r\n     * When subject is newly persisted it may have a generated object id.\r\n     * This value will be stored here. This is actual only for mongodb database.\r\n     */\r\n    generatedObjectId?: any;\r\n\r\n    /**\r\n     * Generated id of the parent entity. Used in the class-table-inheritance.\r\n     */\r\n    parentGeneratedId?: any;\r\n\r\n    /**\r\n     * Used in newly persisted entities which are tree tables.\r\n     */\r\n    treeLevel?: number;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral) {\r\n        this.metadata = metadata;\r\n        this._persistEntity = entity;\r\n        this._databaseEntity = databaseEntity;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Accessors\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets entity sent to the persistence (e.g. changed entity).\r\n     * Throws error if persisted entity was not set.\r\n     */\r\n    get entity(): ObjectLiteral {\r\n        if (!this._persistEntity)\r\n            throw new Error(`Persistence entity is not set for the given subject.`);\r\n\r\n        return this._persistEntity;\r\n    }\r\n\r\n    /**\r\n     * Checks if subject has a persisted entity.\r\n     */\r\n    get hasEntity(): boolean {\r\n        return !!this._persistEntity;\r\n    }\r\n\r\n    /**\r\n     * Gets entity from the database (e.g. original entity).\r\n     * THIS IS NOT RAW ENTITY DATA.\r\n     * Throws error if database entity was not set.\r\n     */\r\n    get databaseEntity(): ObjectLiteral {\r\n        if (!this._databaseEntity)\r\n            throw new Error(`Database entity is not set for the given subject.`);\r\n\r\n        return this._databaseEntity;\r\n    }\r\n\r\n    /**\r\n     * Checks if subject has a database entity.\r\n     */\r\n    get hasDatabaseEntity(): boolean {\r\n        return !!this._databaseEntity;\r\n    }\r\n\r\n    /**\r\n     * Sets entity from the database (e.g. original entity).\r\n     * Once database entity set it calculates differentiated columns and relations\r\n     * between persistent entity and database entity.\r\n     */\r\n    set databaseEntity(databaseEntity: ObjectLiteral) {\r\n        this._databaseEntity = databaseEntity;\r\n        this.recompute();\r\n    }\r\n\r\n    /**\r\n     * Gets entity target from the entity metadata of this subject.\r\n     */\r\n    get entityTarget(): Function|string {\r\n        return this.metadata.target;\r\n    }\r\n\r\n    /**\r\n     * Checks if this subject must be inserted into the database.\r\n     * Subject can be inserted into the database if it is allowed to be inserted (explicitly persisted or by cascades)\r\n     * and if it does not have database entity set.\r\n     */\r\n    get mustBeInserted() {\r\n        return this.canBeInserted && !this.hasDatabaseEntity;\r\n    }\r\n\r\n    /**\r\n     * Checks if this subject must be updated into the database.\r\n     * Subject can be updated in the database if it is allowed to be updated (explicitly persisted or by cascades)\r\n     * and if it does have differentiated columns or relations.\r\n     */\r\n    get mustBeUpdated() {\r\n        return this.canBeUpdated && (this.diffColumns.length > 0 || this.diffRelations.length > 0);\r\n    }\r\n\r\n    /**\r\n     * Checks if this subject has relations to be updated.\r\n     */\r\n    get hasRelationUpdates(): boolean {\r\n        return this.relationUpdates.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets id of the persisted entity.\r\n     * If entity is not set then it returns undefined.\r\n     * If entity itself has an id then it simply returns it.\r\n     * If entity does not have an id then it returns newly generated id.\r\n\r\n    get getPersistedEntityIdMap(): any|undefined {\r\n        if (!this.hasEntity)\r\n            return undefined;\r\n\r\n        const entityIdMap = this.metadata.getDatabaseEntityIdMap(this.entity);\r\n        if (entityIdMap)\r\n            return entityIdMap;\r\n\r\n        if (this.newlyGeneratedId)\r\n            return this.metadata.createSimpleDatabaseIdMap(this.newlyGeneratedId);\r\n\r\n        return undefined;\r\n    }*/\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Validates this subject for errors.\r\n     * Subject cannot be at the same time inserted and updated, removed and inserted, removed and updated.\r\n     */\r\n    validate() {\r\n\r\n        if (this.mustBeInserted && this.mustBeRemoved)\r\n            throw new Error(`Removed entity ${this.metadata.name} is also scheduled for insert operation. This looks like ORM problem. Please report a github issue.`);\r\n\r\n        if (this.mustBeUpdated && this.mustBeRemoved)\r\n            throw new Error(`Removed entity \"${this.metadata.name}\" is also scheduled for update operation. ` +\r\n                `Make sure you are not updating and removing same object (note that update or remove may be executed by cascade operations).`);\r\n\r\n        if (this.mustBeInserted && this.mustBeUpdated)\r\n            throw new Error(`Inserted entity ${this.metadata.name} is also scheduled for updated operation. This looks like ORM problem. Please report a github issue.`);\r\n\r\n    }\r\n\r\n    /**\r\n     * Performs entity re-computations.\r\n     */\r\n    recompute() {\r\n        if (this.hasEntity && this._databaseEntity) {\r\n            this.computeDiffColumns();\r\n            this.computeDiffRelationalColumns();\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Differentiate columns from the updated entity and entity stored in the database.\r\n     */\r\n    protected computeDiffColumns(): void {\r\n        this.diffColumns = this.metadata.columns.filter(column => {\r\n\r\n            // prepare both entity and database values to make comparision\r\n            let entityValue = column.getEntityValue(this.entity);\r\n            let databaseValue = column.getEntityValue(this.databaseEntity);\r\n            if (entityValue === undefined)\r\n                return false;\r\n\r\n            // normalize special values to make proper comparision\r\n            if (entityValue !== null && entityValue !== undefined) {\r\n                if (column.type === ColumnTypes.DATE) {\r\n                    entityValue = DataTransformationUtils.mixedDateToDateString(entityValue);\r\n\r\n                } else if (column.type === ColumnTypes.TIME) {\r\n                    entityValue = DataTransformationUtils.mixedDateToTimeString(entityValue);\r\n\r\n                } else if (column.type === ColumnTypes.DATETIME) {\r\n                    // if (column.loadInLocalTimezone) {\r\n                    //     entityValue = DataTransformationUtils.mixedDateToDatetimeString(entityValue);\r\n                    //     databaseValue = DataTransformationUtils.mixedDateToDatetimeString(databaseValue);\r\n                    // } else {\r\n                        entityValue = DataTransformationUtils.mixedDateToUtcDatetimeString(entityValue);\r\n                        databaseValue = DataTransformationUtils.mixedDateToUtcDatetimeString(databaseValue);\r\n                    // }\r\n\r\n                } else if (column.type === ColumnTypes.JSON) {\r\n                    entityValue = JSON.stringify(entityValue);\r\n                    if (databaseValue !== null && databaseValue !== undefined)\r\n                        databaseValue = JSON.stringify(databaseValue);\r\n\r\n                } else if (column.type === ColumnTypes.SIMPLE_ARRAY) {\r\n                    entityValue = DataTransformationUtils.simpleArrayToString(entityValue);\r\n                    databaseValue = DataTransformationUtils.simpleArrayToString(databaseValue);\r\n                }\r\n            }\r\n            // todo: this mechanism does not get in count embeddeds in embeddeds\r\n\r\n            // if value is not defined then no need to update it\r\n            // if (!column.isInEmbedded && this.entity[column.propertyName] === undefined)\r\n            //     return false;\r\n            //\r\n            // if value is in embedded and is not defined then no need to update it\r\n            // if (column.isInEmbedded && (this.entity[column.embeddedProperty] === undefined || this.entity[column.embeddedProperty][column.propertyName] === undefined))\r\n            //     return false;\r\n\r\n            // if its a special column or value is not changed - then do nothing\r\n            if (column.isVirtual ||\r\n                column.isParentId ||\r\n                column.isDiscriminator ||\r\n                column.isUpdateDate ||\r\n                column.isVersion ||\r\n                column.isCreateDate ||\r\n                entityValue === databaseValue)\r\n                return false;\r\n\r\n            // filter out \"relational columns\" only in the case if there is a relation object in entity\r\n            const relation = this.metadata.findRelationWithDbName(column.databaseName);\r\n            if (relation) {\r\n                const value = relation.getEntityValue(this.entity);\r\n                if (value !== null && value !== undefined)\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Difference columns of the owning one-to-one and many-to-one columns.\r\n     */\r\n    protected computeDiffRelationalColumns(/*todo: updatesByRelations: UpdateByRelationOperation[], */): void {\r\n        this.diffRelations = this.metadata.relations.filter(relation => {\r\n            if (!relation.isManyToOne && !(relation.isOneToOne && relation.isOwning))\r\n                return false;\r\n\r\n            // here we cover two scenarios:\r\n            // 1. related entity can be another entity which is natural way\r\n            // 2. related entity can be entity id which is hacked way of updating entity\r\n            // todo: what to do if there is a column with relationId? (cover this too?)\r\n            const entityValue = relation.getEntityValue(this.entity);\r\n            const updatedEntityRelationId: any = entityValue instanceof Object\r\n                    ? relation.inverseEntityMetadata.getEntityIdMixedMap(entityValue)\r\n                    : entityValue;\r\n\r\n            const dbEntityRelationId = relation.getEntityValue(this.databaseEntity);\r\n\r\n            // todo: try to find if there is update by relation operation - we dont need to generate update relation operation for this\r\n            // todo: if (updatesByRelations.find(operation => operation.targetEntity === this && operation.updatedRelation === relation))\r\n            // todo:     return false;\r\n\r\n            // we don't perform operation over undefined properties\r\n            if (updatedEntityRelationId === undefined)\r\n                return false;\r\n\r\n            // if both are empty totally no need to do anything\r\n            if ((updatedEntityRelationId === undefined || updatedEntityRelationId === null) &&\r\n                (dbEntityRelationId === undefined || dbEntityRelationId === null))\r\n                return false;\r\n\r\n            // if relation ids aren't equal then we need to update them\r\n            return updatedEntityRelationId !== dbEntityRelationId;\r\n        });\r\n    }\r\n\r\n}"],"sourceRoot":".."}