{"version":3,"sources":["../../src/persistence/SubjectBuilder.ts"],"names":[],"mappings":"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","file":"SubjectBuilder.js","sourcesContent":["import {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {Subject} from \"./Subject\";\r\nimport {QueryRunnerProvider} from \"../query-runner/QueryRunnerProvider\";\r\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\n\r\n/**\r\n * To be able to execute persistence operations we need to load all entities from the database we need.\r\n * Loading should be efficient - we need to load entities in as few queries as possible + load as less data as we can.\r\n * This is how we determine which entities needs to be loaded from db:\r\n *\r\n * 1. example with cascade updates and inserts:\r\n *\r\n * [Y] - means \"yes, we load\"\r\n * [N] - means \"no, we don't load\"\r\n * in {} braces we specify what cascade options are set between relations\r\n *\r\n * if Post is new, author is not set in the post\r\n *\r\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\r\n *   [Y] Author -> {all} // no because author is not set\r\n *     [Y] Photo -> {all} // no because author and its photo are not set\r\n *       [Y] Tag -> {all} // no because author and its photo and its tag are not set\r\n *\r\n * if Post is new, author is new (or anything else is new)\r\n * if Post is updated\r\n * if Post and/or Author are updated\r\n *\r\n * [Y] Post -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\r\n *   [Y] Author -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\r\n *     [Y] Photo -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\r\n *       [Y] Tag -> {all} // yes because of \"update\" and \"insert\" cascades, no because of \"remove\"\r\n *\r\n * Here we load post, author, photo, tag to check if they are new or not to persist insert or update operation.\r\n * We load post, author, photo, tag only if they exist in the relation.\r\n * From these examples we can see that we always load entity relations when it has \"update\" or \"insert\" cascades.\r\n *\r\n * 2. example with cascade removes\r\n *\r\n * if entity is new its remove operations by cascades should not be executed\r\n * if entity is updated then values that are null or missing in array (not undefined!, undefined means skip - don't do anything) are treated as removed\r\n * if entity is removed then all its downside relations which has cascade remove should be removed\r\n *\r\n * Once we find removed entity - we load it, and every downside entity which has \"remove\" cascade set.\r\n *\r\n * At the end we have all entities we need to operate with.\r\n * Next step is to store all loaded entities to manipulate them efficiently.\r\n *\r\n * Rules of updating by cascades.\r\n * Insert operation can lead to:\r\n *  - insert operations\r\n *  - update operations\r\n * Update operation can lead to:\r\n *  - insert operations\r\n *  - update operations\r\n *  - remove operations\r\n * Remove operation can lead to:\r\n *  - remove operation\r\n */\r\nexport class SubjectBuilder<Entity extends ObjectLiteral> {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * If this gonna be reused then what to do with marked flags?\r\n     * One of solution can be clone this object and reset all marked states for this persistence.\r\n     * Or from reused just extract databaseEntities from their subjects? (looks better)\r\n     */\r\n    operateSubjects: Subject[] = [];\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected connection: Connection,\r\n                protected queryRunnerProvider: QueryRunnerProvider) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds operations for entity that is being inserted/updated.\r\n     */\r\n    async persist(entity: Entity, metadata: EntityMetadata): Promise<void> {\r\n\r\n        // create subject for currently persisted entity and mark that it can be inserted and updated\r\n        const mainPersistedSubject = new Subject(metadata, entity);\r\n        mainPersistedSubject.canBeInserted = true;\r\n        mainPersistedSubject.canBeUpdated = true;\r\n        this.operateSubjects.push(mainPersistedSubject);\r\n\r\n        // next step we build list of subjects we will operate with\r\n        // these subjects are subjects that we need to insert or update alongside with main persisted entity\r\n        this.buildCascadeUpdateAndInsertOperateSubjects(mainPersistedSubject);\r\n\r\n        // next step is to load database entities of all operate subjects\r\n        await this.loadOperateSubjectsDatabaseEntities();\r\n\r\n        // next step - we filter subjects with database entities (only for non-new entities)\r\n        // and find operate subjects that needs to be removed\r\n        // here we also find operate subjects which relations should be updated\r\n        // these relations usually are \"update from inverse side\" operations\r\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\r\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\r\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\r\n        }));\r\n\r\n        // finally find which operate subjects have insert and remove operations in their junction tables\r\n        await this.buildJunctionOperations({ insert: true, remove: true });\r\n    }\r\n\r\n    /**\r\n     * Builds only remove operations for entity that is being removed.\r\n     */\r\n    async remove(entity: Entity, metadata: EntityMetadata): Promise<void> {\r\n\r\n        // create subject for currently removed entity and mark that it must be removed\r\n        const mainRemovedSubject = new Subject(metadata, entity);\r\n        mainRemovedSubject.mustBeRemoved = true;\r\n        this.operateSubjects.push(mainRemovedSubject);\r\n\r\n        // next step we build list of subjects we will operate with\r\n        // these subjects are subjects that we need to remove alongside with main removed entity\r\n        this.buildCascadeRemoveOperateSubjects(mainRemovedSubject);\r\n\r\n        // next step is to load database entities for all operate subjects\r\n        await this.loadOperateSubjectsDatabaseEntities();\r\n\r\n        // next step - we filter subjects with database entities (only for non-new entities)\r\n        // and find operate subjects that needs to be removed\r\n        // todo(this should not be in remove?) // here we also find operate subjects which relations should be updated\r\n        // todo(this should not be in remove?) // these relations usually are \"update from inverse side\" operations\r\n        const operateSubjectsWithDatabaseEntities = this.operateSubjects.filter(subject => subject.hasDatabaseEntity);\r\n        await Promise.all(operateSubjectsWithDatabaseEntities.map(subject => {\r\n            return this.buildCascadeRemovedAndRelationUpdateOperateSubjects(subject);\r\n        }));\r\n\r\n        // finally find which operate subjects have remove operations in their junction tables\r\n        await this.buildJunctionOperations({ insert: false, remove: true });\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds and pushes to array of operate entities all entities that we will work with.\r\n     * These are only relational entities which has insert and update cascades.\r\n     * All such entities will be loaded from the database, because they can be inserted or updated.\r\n     * That's why we load them - to understand if they should be inserted or updated, or which columns we need to update.\r\n     * We can't add removed entities here, because to know which entity was removed we need first to\r\n     * load original entity (particularly its id) from the database.\r\n     * That's why we first need to load all changed entities, then extract ids of the removed entities from them,\r\n     * and only then load removed entities by extracted ids.\r\n     */\r\n    protected buildCascadeUpdateAndInsertOperateSubjects(subject: Subject): void {\r\n        subject.metadata\r\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\r\n            .filter(([relation, value, valueMetadata]) => {\r\n\r\n                // we need only defined values and insert or update cascades of the relation should be set\r\n                return value !== undefined && value !== null && (relation.isCascadeInsert || relation.isCascadeUpdate);\r\n            })\r\n            .forEach(([relation, value, valueMetadata]) => {\r\n\r\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\r\n                const alreadyExistValueSubject = this.findByEntityLike(valueMetadata.target, value);\r\n                if (alreadyExistValueSubject) {\r\n                    if (alreadyExistValueSubject.canBeInserted === false)\r\n                        alreadyExistValueSubject.canBeInserted = relation.isCascadeInsert === true;\r\n                    if (alreadyExistValueSubject.canBeUpdated === false)\r\n                        alreadyExistValueSubject.canBeUpdated = relation.isCascadeUpdate === true;\r\n                    return;\r\n                }\r\n\r\n                // mark subject with what we can do with it\r\n                // and add to the array of subjects to load only if there is no same entity there already\r\n                const valueSubject = new Subject(valueMetadata, value);\r\n                valueSubject.canBeInserted = relation.isCascadeInsert === true;\r\n                valueSubject.canBeUpdated = relation.isCascadeUpdate === true;\r\n                this.operateSubjects.push(valueSubject);\r\n\r\n                // go recursively and find other entities we need to operate with\r\n                this.buildCascadeUpdateAndInsertOperateSubjects(valueSubject);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Builds and pushes to array of operate entities all entities that must be removed.\r\n     */\r\n    protected buildCascadeRemoveOperateSubjects(subject: Subject): void {\r\n        subject.metadata\r\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations)\r\n            .filter(([relation, value, valueMetadata]) => {\r\n\r\n                // we need only defined values and insert cascades of the relation should be set\r\n                return value !== undefined && value !== null && relation.isCascadeRemove;\r\n            })\r\n            .forEach(([relation, value, valueMetadata]) => {\r\n\r\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\r\n                const alreadyExistValueSubject = this.findByEntityLike(valueMetadata.target, value);\r\n                if (alreadyExistValueSubject) {\r\n                    alreadyExistValueSubject.mustBeRemoved = true;\r\n                    return;\r\n                }\r\n\r\n                // add to the array of subjects to load only if there is no same entity there already\r\n                const valueSubject = new Subject(valueMetadata, value);\r\n                valueSubject.mustBeRemoved = true;\r\n                this.operateSubjects.push(valueSubject);\r\n\r\n                // go recursively and find other entities to load by cascades in currently inserted entities\r\n                this.buildCascadeRemoveOperateSubjects(valueSubject);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Loads database entities for all operate subjects which do not have database entity set.\r\n     * All entities that we load database entities for are marked as updated or inserted.\r\n     * To understand which of them really needs to be inserted or updated we need to load\r\n     * their original representations from the database.\r\n     */\r\n    protected async loadOperateSubjectsDatabaseEntities(): Promise<void> {\r\n\r\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\r\n        // go throw the groups and perform loading of database entities of each subject in the group\r\n        const promises = this.groupByEntityTargets().map(async subjectGroup => {\r\n\r\n            // prepare entity ids of the subjects we need to load\r\n            const allIds = subjectGroup.subjects\r\n                .filter(subject => !subject.hasDatabaseEntity) // we don't load if subject already has a database entity loaded\r\n                .filter(subject => {\r\n                    return !subject.metadata.isEntityMapEmpty(subject.entity);\r\n                }) // we only need entity id\r\n                .map(subject => { // we don't need empty ids\r\n                    // console.log(subject.entity);\r\n                    return subject.metadata.getEntityIdMap(subject.entity);\r\n                    // if (mixedId instanceof Object)\r\n                    //     return Object.keys(mixedId).every(key => mixedId[key] !== undefined && mixedId[key] !== null && mixedId[key] !== \"\");\r\n                    //\r\n                    // return mixedId !== undefined && mixedId !== null && mixedId !== \"\";\r\n                });\r\n\r\n            // if there no ids found (which means all entities are new and have generated ids) - then nothing to load there\r\n            // console.log(\"allIds: \", allIds);\r\n            // console.log(\"subject.entity: \", subjectGroup.subjects);\r\n            // console.log(\"allIds: \", allIds);\r\n            if (!allIds.length)\r\n                return;\r\n            // console.log(\"Y\");\r\n\r\n            // load database entities for all given ids\r\n            // todo: such implementation is temporary, need to create a good abstraction there\r\n            // todo: its already possible to do that with repository.findByIds method however setting \"RELATION_ID_VALUES\" option is an issue\r\n            // todo: also custom queryRunnerProvider is an issue\r\n            let entities: any[];\r\n            if (this.connection.driver instanceof MongoDriver) {\r\n\r\n                entities = await this.connection\r\n                    .getMongoRepository<ObjectLiteral>(subjectGroup.target)\r\n                    .findByIds(allIds);\r\n\r\n            } else {\r\n                entities = await this.connection\r\n                    .getRepository<ObjectLiteral>(subjectGroup.target)\r\n                    .createQueryBuilder(\"operateSubject\", this.queryRunnerProvider)\r\n                    .andWhereInIds(allIds)\r\n                    .enableAutoRelationIdsLoad()\r\n                    .getMany();\r\n            }\r\n\r\n            // now when we have entities we need to find subject of each entity\r\n            // and insert that entity into database entity of the found subject\r\n            entities.forEach(entity => {\r\n                // console.log(1);\r\n                const subject = this.findByEntityLike(subjectGroup.target, entity);\r\n                if (subject)\r\n                    subject.databaseEntity = entity;\r\n            });\r\n\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * We need to load removed entity when:\r\n     *  - entity with relations is not new (this can be determined only after entity is loaded from db)\r\n     *      (note: simple \"id\" check will not work because id can be not generated)\r\n     *  - entity missing relation. When relation is simple\r\n     *      - in the case of one-to-one owner (with join column) relation we need to load owner entity\r\n     *      - in the case of one-to-one (without join column) relation we need to load inverse side entity\r\n     *      - in the case of many-to-one relations we need to load entity itself\r\n     *      - in the case of one-to-many relations we need to load entities by relation from inverse side\r\n     *\r\n     *  Before loading each entity we need to check in the loaded subjects - maybe it was already loaded.\r\n     *\r\n     *  BIG NOTE: objects are being removed by cascades not only when relation is removed, but also when\r\n     *  relation is replaced (e.g. changed with different object).\r\n     */\r\n    protected async buildCascadeRemovedAndRelationUpdateOperateSubjects(subject: Subject): Promise<void> {\r\n\r\n        // note: we can't use extractRelationValuesFromEntity here because it does not handle empty arrays\r\n        const promises = subject.metadata.relations.map(async relation => {\r\n            const valueMetadata = relation.inverseEntityMetadata;\r\n            const qbAlias = valueMetadata.tableName;\r\n\r\n            // added for type-safety, but subject without databaseEntity cant come here anyway because of checks on upper levels\r\n            if (!subject.hasDatabaseEntity) return;\r\n\r\n            // for one-to-one owner and many-to-one relations no need to load entity to check if something removed\r\n            // because join column is in this side of relation and we have a database entity with which we can compare\r\n            // and understand if relation was removed or not\r\n            if (relation.isOneToOneOwner || relation.isManyToOne) {\r\n\r\n                // we only work with cascade removes here\r\n                if (!relation.isCascadeRemove) return;\r\n\r\n                /**\r\n                 * By example (one-to-one owner). Let's say we have a one-to-one relation between Post and Details.\r\n                 * Post contains detailsId. It means he owns relation. Post has cascade remove with details.\r\n                 * Now here we have a post object with removed details.\r\n                 * We need to remove Details if post.details = null\r\n                 * or if post.details != databasePost.details\r\n                 */\r\n\r\n                /**\r\n                 * By example (many-to-one). Let's say we have a many-to-one relation between Post and Details.\r\n                 * Post contains detailsId. It means he owns relation.\r\n                 * It also means that post can have only one details, and details can have multiple posts.\r\n                 * Post has cascade remove with details.\r\n                 * Now here we have a post object with removed details.\r\n                 * We need to remove Details (one) if post.details = null\r\n                 * or if post.details != databasePost.details\r\n                 */\r\n\r\n                // (example) \"relation\" - is a relation in post with details.\r\n                // (example) \"valueMetadata\" - is an entity metadata of the Details object.\r\n                // (example) \"persistValue\" - is a detailsId from the persisted entity\r\n\r\n                // note that if databaseEntity has relation, it can only be a relation id,\r\n                // because of query builder option \"RELATION_ID_VALUES\" we used\r\n                const relationIdInDatabaseEntity = relation.getEntityValue(subject.databaseEntity); // (example) returns post.detailsId\r\n\r\n                // if database relation id does not exist in the database object then nothing to remove\r\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\r\n                    return;\r\n\r\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\r\n                let persistValueRelationId: any = undefined, persistValue: any = undefined;\r\n                if (subject.hasEntity) {\r\n                    persistValue = relation.getEntityValue(subject.entity);\r\n                    if (persistValue === null) persistValueRelationId = null;\r\n                    if (persistValue) persistValueRelationId = relation.joinColumns.reduce((map, column) => column.referencedColumn!.getEntityValueMap(persistValue), {} as ObjectLiteral);\r\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\r\n                }\r\n\r\n                // object is removed only if relation id in the persisted entity is empty or is changed\r\n                // if (persistValueRelationId !== null && persistValueRelationId === relationIdInDatabaseEntity)\r\n                //     return;\r\n                // console.log(\"relationIdInDatabaseEntity:\", relationIdInDatabaseEntity);\r\n                // console.log(\"persistValue:\", persistValue);\r\n                // console.log(\"compareEntities:\", relation.entityMetadata.compareEntities(relationIdInDatabaseEntity, persistValue));\r\n                // console.log(\"compareIds:\", relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue));\r\n                if (persistValueRelationId !== null && relation.entityMetadata.compareIds(relationIdInDatabaseEntity, persistValue))\r\n                    return;\r\n\r\n                // first check if we already loaded this object before load from the database\r\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\r\n\r\n                    // (example) filter only subject that has database entity loaded and its target is Details\r\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\r\n                        return false;\r\n\r\n                    // (example) here we seek a Details loaded from the database in the subjects\r\n                    // (example) here relatedSubject.databaseEntity is a Details\r\n                    // (example) and we need to compare details.id === post.detailsId\r\n                    return relation.entityMetadata.compareIds(relationIdInDatabaseEntity, relation.getEntityValue(relatedSubject.databaseEntity));\r\n                });\r\n\r\n                // if not loaded yet then load it from the database\r\n                if (!alreadyLoadedRelatedDatabaseSubject) {\r\n\r\n                    // (example) we need to load a details where details.id = post.details\r\n                    const qb = this.connection\r\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                        .enableAutoRelationIdsLoad();\r\n\r\n                    const condition = relation.joinColumns.map(joinColumn => {\r\n                        return `${qbAlias}.${joinColumn.referencedColumn!.propertyPath} = :${joinColumn.databaseName}`;\r\n                    }).join(\" AND \");\r\n\r\n                    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\r\n                        parameters[joinColumn.databaseName] = joinColumn.referencedColumn!.getEntityValue(relationIdInDatabaseEntity);\r\n                        return parameters;\r\n                    }, {} as ObjectLiteral);\r\n\r\n                    qb.where(condition)\r\n                        .setParameters(parameters);\r\n\r\n                    const databaseEntity = await qb.getOne();\r\n\r\n                    if (databaseEntity) {\r\n                        alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\r\n                        this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\r\n                    }\r\n                }\r\n\r\n                if (alreadyLoadedRelatedDatabaseSubject) {\r\n\r\n                    // if object is already marked as removed then no need to proceed because it already was proceed\r\n                    // if we remove this it will cause a recursion\r\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\r\n                        return;\r\n\r\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\r\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\r\n                }\r\n            }\r\n\r\n            // for one-to-one not owner we need to load entity to understand that it was really removed or not,\r\n            // since column value that indicates relation is stored on inverse side\r\n            if (relation.isOneToOneNotOwner) {\r\n\r\n                // we only work with cascade removes here\r\n                if (!relation.isCascadeRemove) return; // todo: no\r\n\r\n                /**\r\n                 * By example. Let's say we have a one-to-one relation between Post and Details.\r\n                 * Post contains detailsId. It means he owns relation. Details has cascade remove with post.\r\n                 * Now here we have a details object with removed post.\r\n                 * We need to remove Post if details.post = null and databasePost.detailsId = details.id exist in the db,\r\n                 * or if databasePost.id === details.post.id (we need to load it) and databasePost.detailsId != details.id\r\n                 */\r\n\r\n                // (example) \"relation\" - is a relation in details with post.\r\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\r\n                // (example) \"subject.databaseEntity\" - is a details object\r\n\r\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\r\n                let persistValueRelationId: any = undefined;\r\n                if (subject.hasEntity && !subject.mustBeRemoved) {\r\n                    const persistValue = relation.getEntityValue(subject.entity);\r\n                    if (persistValue) persistValueRelationId = relation.inverseRelation!.getEntityValue(persistValue);\r\n                    if (persistValueRelationId === undefined) return; // skip undefined properties\r\n                }\r\n\r\n                // (example) returns us referenced column (detail's id)\r\n                const relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[0].referencedColumn!.getEntityValue(subject.databaseEntity);\r\n\r\n                // if database relation id does not exist then nothing to remove (but can this be possible?)\r\n                if (relationIdInDatabaseEntity === null || relationIdInDatabaseEntity === undefined)\r\n                    return;\r\n\r\n                // first check if we already have this object loaded before load from the database\r\n                let alreadyLoadedRelatedDatabaseSubject = this.operateSubjects.find(relatedSubject => {\r\n\r\n                    // (example) filter only subject that has database entity loaded and its target is Post\r\n                    if (!relatedSubject.hasDatabaseEntity || relatedSubject.entityTarget !== valueMetadata.target)\r\n                        return false;\r\n\r\n                    // (example) here we seek a Post loaded from the database in the subjects\r\n                    // (example) here relatedSubject.databaseEntity is a Post\r\n                    // (example) and we need to compare post.detailsId === details.id\r\n                    return relation.inverseRelation!.getEntityValue(relatedSubject.databaseEntity) === relationIdInDatabaseEntity;\r\n                });\r\n\r\n                // if not loaded yet then load it from the database\r\n                if (!alreadyLoadedRelatedDatabaseSubject) {\r\n\r\n                    // (example) we need to load a post where post.detailsId = details.id\r\n                    const databaseEntity = await this.connection\r\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                        .where(qbAlias + \".\" + relation.inverseSidePropertyPath + \"=:id\") // TODO relation.inverseRelation.joinColumns\r\n                        .setParameter(\"id\", relationIdInDatabaseEntity) // (example) subject.entity is a details here, and the value is details.id\r\n                        .enableAutoRelationIdsLoad()\r\n                        .getOne();\r\n\r\n                    // add only if database entity exist - because in the case of inverse side of the one-to-one relation\r\n                    // we cannot check if it was removed or not until we query the database\r\n                    // and it can be a situation that relation wasn't exist at all. This is particular that case\r\n                    alreadyLoadedRelatedDatabaseSubject = new Subject(valueMetadata, undefined, databaseEntity);\r\n                    this.operateSubjects.push(alreadyLoadedRelatedDatabaseSubject);\r\n                }\r\n\r\n                // check if we really has a relation between entities. If relation not found then alreadyLoadedRelatedDatabaseSubject will be empty\r\n                if (alreadyLoadedRelatedDatabaseSubject && alreadyLoadedRelatedDatabaseSubject.hasDatabaseEntity) {\r\n\r\n                    // also check if relation value exist then then make sure its changed\r\n                    // (example) persistValue is a postFromPersistedDetails here\r\n                    // (example) alreadyLoadedRelatedDatabaseSubject.databaseEntity is a postFromDatabaseDetails here\r\n                    // (example) postFromPersistedDetails.id === postFromDatabaseDetails - means nothing changed\r\n                    const inverseEntityRelationId = relation.inverseRelation!.getEntityValue(alreadyLoadedRelatedDatabaseSubject.databaseEntity);\r\n                    if (persistValueRelationId && persistValueRelationId === inverseEntityRelationId)\r\n                        return;\r\n\r\n                    // if object is already marked as removed then no need to proceed because it already was proceed\r\n                    // if we remove this it will cause a recursion\r\n                    if (alreadyLoadedRelatedDatabaseSubject.mustBeRemoved)\r\n                        return;\r\n\r\n                    alreadyLoadedRelatedDatabaseSubject.mustBeRemoved = true;\r\n                    await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(alreadyLoadedRelatedDatabaseSubject);\r\n                }\r\n            }\r\n\r\n            // for one-to-many we need to load entities to understand which was really removed\r\n            // since column value that indicates relation is stored on inverse side\r\n            if (relation.isOneToMany || relation.isManyToMany) {\r\n\r\n                // we only work with cascade removes here\r\n                // if (!relation.isCascadeRemove && !relation.isCascadeUpdate) return;\r\n\r\n                /**\r\n                 * By example. Let's say we have a one-to-many relation between Post and Details.\r\n                 * Post contains detailsId. It means he owns relation.\r\n                 * It also means that one details contains multiple post, and one post contain only one details.\r\n                 * Details has cascade remove with post.\r\n                 * Now here we have a details object with removed post.\r\n                 * There can be one or multiple removed posts, because posts is an array in details.\r\n                 * If details.posts is undefined then we skip it as we do with any persisted undefined property.\r\n                 * If details.posts is an empty array it means all its items should be removed.\r\n                 * If details.posts is a null it means same - all its items has been removed.\r\n                 * We need to remove each Post in the databaseDetails where post is missing in details.posts\r\n                 * but databasePost.detailsId = details.id exist in the db.\r\n                 */\r\n\r\n                // (example) \"relation\" - is a relation in details with post.\r\n                // (example) \"valueMetadata\" - is an entity metadata of the Post object.\r\n                // (example) \"subject.databaseEntity\" - is a details object\r\n\r\n                // if this subject is persisted subject then we get its value to check if its not empty or its values changed\r\n                let persistValue: any = undefined;\r\n                if (subject.hasEntity) {\r\n                    persistValue = relation.getEntityValue(subject.entity);\r\n                    if (persistValue === undefined) return; // skip undefined properties\r\n                }\r\n\r\n                // we can't get already loaded objects from loadMap because we don't know exactly how\r\n                // many objects are in database entity, and entities from loadMap may return us not all of them\r\n                // that's why we are forced to load all its entities from the database even if loaded some of them before\r\n                // (example) we need to load a posts where post.detailsId = details.id\r\n                let databaseEntities: ObjectLiteral[] = [];\r\n\r\n                // create shortcuts for better readability\r\n                const ea = (alias: string) => this.connection.driver.escapeAliasName(alias);\r\n                const ec = (column: string) => this.connection.driver.escapeColumnName(column);\r\n\r\n                if (relation.isManyToManyOwner) {\r\n\r\n                    // we only need to load inverse entities if cascade removes are set\r\n                    // because remove by cascades is the only reason we need relational entities here\r\n                    if (!relation.isCascadeRemove) return;\r\n\r\n                    const joinAlias = ea(\"persistenceJoinedRelation\");\r\n\r\n                    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\r\n                        return `${joinAlias}.${joinColumn.propertyName} = :${joinColumn.propertyName}`;\r\n                    });\r\n                    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\r\n                        return `${joinAlias}.${inverseJoinColumn.propertyName} = ${ea(qbAlias)}.${ec(inverseJoinColumn.referencedColumn!.propertyName)}`;\r\n                    });\r\n\r\n                    const conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(\" AND \");\r\n\r\n                    // (example) returns us referenced column (detail's id)\r\n                    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\r\n                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn!.getEntityValue(subject.databaseEntity);\r\n                        return parameters;\r\n                    }, {} as ObjectLiteral);\r\n\r\n                    databaseEntities = await this.connection\r\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                        .innerJoin(relation.junctionEntityMetadata!.tableName, joinAlias, conditions)\r\n                        .setParameters(parameters)\r\n                        .enableAutoRelationIdsLoad()\r\n                        .getMany();\r\n\r\n                } else if (relation.isManyToManyNotOwner) {\r\n\r\n                    // we only need to load inverse entities if cascade removes are set\r\n                    // because remove by cascades is the only reason we need relational entities here\r\n                    if (!relation.isCascadeRemove) return;\r\n\r\n                    const joinAlias = ea(\"persistenceJoinedRelation\");\r\n\r\n                    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\r\n                        return `${joinAlias}.${joinColumn.propertyName} = ${ea(qbAlias)}.${ec(joinColumn.referencedColumn!.propertyName)}`;\r\n                    });\r\n                    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\r\n                        return `${joinAlias}.${inverseJoinColumn.propertyName} = :${inverseJoinColumn.propertyName}`;\r\n                    });\r\n\r\n                    const conditions = joinColumnConditions.concat(inverseJoinColumnConditions).join(\" AND \");\r\n\r\n                    // (example) returns us referenced column (detail's id)\r\n                    const parameters = relation.inverseRelation!.inverseJoinColumns.reduce((parameters, joinColumn) => {\r\n                        parameters[joinColumn.propertyName] = joinColumn.referencedColumn!.getEntityValue(subject.databaseEntity);\r\n                        return parameters;\r\n                    }, {} as ObjectLiteral);\r\n\r\n                    databaseEntities = await this.connection\r\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                        .innerJoin(relation.junctionEntityMetadata!.tableName, joinAlias, conditions)\r\n                        .setParameters(parameters)\r\n                        .enableAutoRelationIdsLoad()\r\n                        .getMany();\r\n\r\n                } else { // this case can only be a oneToMany relation\r\n                    // todo: fix issues with joinColumn[0]\r\n                    // (example) returns us referenced column (detail's id)\r\n                    const relationIdInDatabaseEntity = relation.inverseRelation!.joinColumns[0].referencedColumn!.getEntityValue(subject.databaseEntity);\r\n\r\n                    // in this case we need inverse entities not only because of cascade removes\r\n                    // because we also need inverse entities to be able to perform update of entities\r\n                    // in the inverse side when entities is detached from one-to-many relation\r\n\r\n                    databaseEntities = await this.connection\r\n                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                        .where(qbAlias + \".\" + relation.inverseSidePropertyPath + \"=:id\")\r\n                        .setParameter(\"id\", relationIdInDatabaseEntity)\r\n                        .enableAutoRelationIdsLoad()\r\n                        .getMany();\r\n                }\r\n\r\n                // add to loadMap loaded entities if some of them are missing\r\n                databaseEntities.forEach(databaseEntity => {\r\n                    const subjectInLoadMap = this.findByEntityLike(valueMetadata.target, databaseEntity);\r\n                    if (subjectInLoadMap && !subjectInLoadMap.hasDatabaseEntity) {\r\n                        subjectInLoadMap.databaseEntity = databaseEntity;\r\n\r\n                    } else if (!subjectInLoadMap) {\r\n                        const subject = new Subject(valueMetadata, undefined, databaseEntity);\r\n                        this.operateSubjects.push(subject);\r\n                    }\r\n                });\r\n\r\n\r\n                // add new relations for newly bind entities from the one-to-many relations\r\n                if (relation.isOneToMany && persistValue) { // todo: implement same for one-to-one\r\n                    const promises = (persistValue as ObjectLiteral[]).map(async persistValue => {\r\n\r\n                        // try to find in the database entities persistedValue (entity bind to this relation)\r\n                        const persistedValueInDatabaseEntity = databaseEntities.find(databaseEntity => {\r\n                            return valueMetadata.compareEntities(persistValue, databaseEntity);\r\n                        });\r\n\r\n                        // if it does not exist in the database entity - it means we need to bind it\r\n                        // to bind it we need to update related entity itself\r\n                        // this operation is performed only in one-to-many relations\r\n                        if (!persistedValueInDatabaseEntity) {\r\n\r\n                            // now find subject with\r\n                            let loadedSubject = this.findByDatabaseEntityLike(valueMetadata.target, persistValue);\r\n                            if (!loadedSubject) {\r\n                                const id = valueMetadata.getEntityIdMap(persistValue);\r\n                                if (id) { // if there is no id (for newly inserted) then we cant load\r\n                                    const databaseEntity = await this.connection\r\n                                        .getRepository<ObjectLiteral>(valueMetadata.target)\r\n                                        .createQueryBuilder(qbAlias, this.queryRunnerProvider) // todo: this wont work for mongodb. implement this in some method and call it here instead?\r\n                                        .andWhereInIds([id])\r\n                                        .enableAutoRelationIdsLoad()\r\n                                        .getOne();\r\n\r\n                                    if (databaseEntity) {\r\n                                        loadedSubject = new Subject(valueMetadata, undefined, databaseEntity); // todo: what if entity like object exist in the loaded subjects but without databaseEntity?\r\n                                        this.operateSubjects.push(loadedSubject);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (loadedSubject) {\r\n                                loadedSubject.relationUpdates.push({\r\n                                    relation: relation.inverseRelation!,\r\n                                    value: subject.entity\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    await Promise.all(promises);\r\n                }\r\n\r\n                // iterate throw loaded inverse entities to find out removed entities and inverse updated entities (only for one-to-many relation)\r\n                const promises = databaseEntities.map(async databaseEntity => {\r\n\r\n                    // find a subject object of the related database entity\r\n                    let relatedEntitySubject = this.findByDatabaseEntityLike(valueMetadata.target, databaseEntity);\r\n                    if (!relatedEntitySubject) return; // should not be possible, anyway add it for type-safety\r\n\r\n                    // if object is already marked as removed then no need to proceed because it already was proceed\r\n                    // if we remove this check it will cause a recursion\r\n                    if (relatedEntitySubject.mustBeRemoved) return;  // todo: add another check for entity in unsetRelations?\r\n\r\n                    // check if in persisted value there is a database value to understand if it was removed or not\r\n                    let relatedValue = ((persistValue || []) as ObjectLiteral[]).find(persistValueItem => {\r\n                        return valueMetadata.compareEntities(relatedEntitySubject!.databaseEntity, persistValueItem);\r\n                    });\r\n\r\n                    // if relation value is set to undefined then we don't do anything - simply skip any check and remove\r\n                    // but if relation value is set to null then it means user wants to remove each entity in this relation\r\n                    // OR\r\n                    // value was removed from persisted value - means we need to mark it as removed\r\n                    // and check if mark as removed all underlying entities that has cascade remove\r\n                    if (persistValue === null || !relatedValue) {\r\n\r\n                        // if cascade remove option is set then need to remove related entity\r\n                        if (relation.isCascadeRemove) {\r\n                            relatedEntitySubject.mustBeRemoved = true;\r\n\r\n                            // mark as removed all underlying entities that has cascade remove\r\n                            await this.buildCascadeRemovedAndRelationUpdateOperateSubjects(relatedEntitySubject);\r\n\r\n                        // if cascade remove option is not set then it means we simply need to remove\r\n                        // reference to this entity from inverse side (from loaded database entity)\r\n                        // this applies only on one-to-many relationship\r\n                        } else if (relation.isOneToMany && relation.inverseRelation) {\r\n                            relatedEntitySubject.relationUpdates.push({\r\n                                relation: relation.inverseRelation,\r\n                                value: null\r\n                            }); // todo: implement same for one-to-one\r\n                        }\r\n\r\n                    }\r\n\r\n                });\r\n\r\n                await Promise.all(promises);\r\n            }\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Builds all junction insert and remove operations used to insert new bind data into junction tables,\r\n     * or remove old junction records.\r\n     * Options specifies which junction operations should be built - insert, remove or both.\r\n     */\r\n    private async buildJunctionOperations(options: { insert: boolean, remove: boolean }): Promise<void> {\r\n        const promises = this.operateSubjects.filter(subject => subject.hasEntity).map(subject => {\r\n            const metadata = subject.metadata.parentEntityMetadata ? subject.metadata.parentEntityMetadata : subject.metadata;\r\n            const promises = metadata.manyToManyRelations.map(async relation => {\r\n                // if subject marked to be removed then all its junctions must be removed\r\n                if (subject.mustBeRemoved && options.remove) {\r\n                    // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\r\n                    // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\r\n                    const existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);\r\n\r\n                    // finally create a new junction remove operation and push it to the array of such operations\r\n                    if (existInverseEntityRelationIds.length > 0) {\r\n                        subject.junctionRemoves.push({\r\n                            relation: relation,\r\n                            junctionRelationIds: existInverseEntityRelationIds\r\n                        });\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                // if entity don't have entity then no need to find something that should be inserted or removed\r\n                if (!subject.hasEntity)\r\n                    return;\r\n\r\n                // else check changed junctions in the persisted entity\r\n                // extract entity value - we only need to proceed if value is defined and its an array\r\n                const relatedValue = relation.getEntityValue(subject.entity);\r\n                if (!(relatedValue instanceof Array))\r\n                    return;\r\n\r\n                // load from db all relation ids of inverse entities that are \"bind\" to the currently persisted entity\r\n                // this way we gonna check which relation ids are missing and which are new (e.g. inserted or removed)\r\n                // we could load this relation ids with entity using however this way it may be more efficient, because\r\n                // this way we load only relations that come, e.g. we don't load data for empty relations set with object.\r\n                // this is also useful when object is being saved partial.\r\n                let existInverseEntityRelationIds: any[] = [];\r\n\r\n                // if subject don't have database entity it means its new and we don't need to remove something that is not exist\r\n                if (subject.hasDatabaseEntity) {\r\n                    existInverseEntityRelationIds = relation.getEntityValue(subject.databaseEntity);\r\n                    // console.log(\"existInverseEntityRelationIds:\", existInverseEntityRelationIds[0]);\r\n                }\r\n\r\n                // get all inverse entities relation ids that are \"bind\" to the currently persisted entity\r\n                const changedInverseEntityRelationIds = relatedValue\r\n                    .map(subRelationValue => {\r\n                        const joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\r\n                        return joinColumns.reduce((ids, joinColumn) => {\r\n                            return OrmUtils.mergeDeep(ids, joinColumn.referencedColumn!.createValueMap(joinColumn.referencedColumn!.getEntityValue(subRelationValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?\r\n                        }, {} as ObjectLiteral);\r\n                    })\r\n                    .filter(subRelationValue => subRelationValue !== undefined && subRelationValue !== null);\r\n                // console.log(\"changedInverseEntityRelationIds:\", changedInverseEntityRelationIds);\r\n\r\n                // now from all entities in the persisted entity find only those which aren't found in the db\r\n                const removedJunctionEntityIds = existInverseEntityRelationIds.filter(existRelationId => {\r\n                    return !changedInverseEntityRelationIds.find(changedRelationId => {\r\n                        return relation.inverseEntityMetadata.compareIds(changedRelationId, existRelationId);\r\n                    });\r\n                });\r\n                // console.log(\"removedJunctionEntityIds:\", removedJunctionEntityIds);\r\n\r\n                // now from all entities in the persisted entity find only those which aren't found in the db\r\n                const newJunctionEntities = relatedValue.filter(subRelatedValue => {\r\n                    // console.log(subRelatedValue);\r\n\r\n                    const joinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\r\n                    const ids = joinColumns.reduce((ids, joinColumn) => {\r\n                        return OrmUtils.mergeDeep(ids, joinColumn.referencedColumn!.createValueMap(joinColumn.referencedColumn!.getEntityValue(subRelatedValue))); // todo: duplicate. relation.createJoinColumnsIdMap(entity) ?\r\n                    }, {} as ObjectLiteral);\r\n                    // console.log(\"ids:\", ids);\r\n                    return !existInverseEntityRelationIds.find(relationId => {\r\n                        return relation.inverseEntityMetadata.compareIds(relationId, ids);\r\n                    });\r\n                });\r\n\r\n                // console.log(\"newJunctionEntities: \", newJunctionEntities);\r\n\r\n                // finally create a new junction insert operation and push it to the array of such operations\r\n                if (newJunctionEntities.length > 0 && options.insert) {\r\n                    subject.junctionInserts.push({\r\n                        relation: relation,\r\n                        junctionEntities: newJunctionEntities\r\n                    });\r\n                }\r\n\r\n                // finally create a new junction remove operation and push it to the array of such operations\r\n                if (removedJunctionEntityIds.length > 0 && options.remove) {\r\n                    subject.junctionRemoves.push({\r\n                        relation: relation,\r\n                        junctionRelationIds: removedJunctionEntityIds\r\n                    });\r\n                }\r\n            });\r\n\r\n            return Promise.all(promises);\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Finds subject where entity like given subject's entity.\r\n     * Comparision made by entity id.\r\n     */\r\n    protected findByEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\r\n        return this.operateSubjects.find(subject => {\r\n            if (!subject.hasEntity)\r\n                return false;\r\n\r\n            if (subject.entity === entity)\r\n                return true;\r\n\r\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.entity, entity);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Finds subject where entity like given subject's database entity.\r\n     * Comparision made by entity id.\r\n     */\r\n    protected findByDatabaseEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\r\n        return this.operateSubjects.find(subject => {\r\n            if (!subject.hasDatabaseEntity)\r\n                return false;\r\n\r\n            return subject.entityTarget === entityTarget && subject.metadata.compareEntities(subject.databaseEntity, entity);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Groups given Subject objects into groups separated by entity targets.\r\n     */\r\n    protected groupByEntityTargets(): { target: Function|string, subjects: Subject[] }[] {\r\n        return this.operateSubjects.reduce((groups, operatedEntity) => {\r\n            let group = groups.find(group => group.target === operatedEntity.entityTarget);\r\n            if (!group) {\r\n                group = { target: operatedEntity.entityTarget, subjects: [] };\r\n                groups.push(group);\r\n            }\r\n            group.subjects.push(operatedEntity);\r\n            return groups;\r\n        }, [] as { target: Function|string, subjects: Subject[] }[]);\r\n    }\r\n\r\n}"],"sourceRoot":".."}