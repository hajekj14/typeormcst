{"version":3,"sources":["../../src/query-builder/transformer/PlainObjectToNewEntityTransformer.ts"],"names":[],"mappings":"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","file":"PlainObjectToNewEntityTransformer.js","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\r\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\r\n\r\n/**\r\n * Transforms plain old javascript object\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class PlainObjectToNewEntityTransformer {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    transform<T>(newEntity: T, object: ObjectLiteral, metadata: EntityMetadata): T {\r\n        this.groupAndTransform(newEntity, object, metadata);\r\n        return newEntity;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\r\n     * we need to group our result and we must have some unique id (primary key in our case)\r\n     */\r\n    private groupAndTransform(entity: any, object: ObjectLiteral, metadata: EntityMetadata): void {\r\n\r\n        // copy regular column properties from the given object\r\n        metadata.columns\r\n            .filter(column => object.hasOwnProperty(column.propertyName))\r\n            .forEach(column => entity[column.propertyName] = object[column.propertyName]); // todo: also need to be sure that type is correct\r\n\r\n        // if relation is loaded then go into it recursively and transform its values too\r\n        metadata.relations\r\n            .filter(relation => object.hasOwnProperty(relation.propertyName))\r\n            .forEach(relation => {\r\n                const relationMetadata = relation.inverseEntityMetadata;\r\n                if (!relationMetadata)\r\n                    throw new Error(\"Relation metadata for the relation \" + metadata.name + \"#\" + relation.propertyName + \" is missing\");\r\n\r\n                if (relation.isManyToMany || relation.isOneToMany) {\r\n                    if (object[relation.propertyName] instanceof Array) {\r\n                        entity[relation.propertyName] = object[relation.propertyName].map((subObject: any) => {\r\n                            let subEntity = relationMetadata.create();\r\n                            // todo: support custom initial fields here\r\n                            if (entity[relation.propertyName] instanceof Array) {\r\n                                const existRelation = entity[relation.propertyName].find((subEntity: any) => {\r\n                                    return subEntity[relation.propertyName] === subObject[relation.propertyName];\r\n                                });\r\n                                if (existRelation)\r\n                                    this.groupAndTransform(subEntity, existRelation, relationMetadata);\r\n                            }\r\n\r\n                            this.groupAndTransform(subEntity, subObject, relationMetadata);\r\n                            return subEntity;\r\n                        });\r\n                    } else {\r\n                        entity[relation.propertyName] = object[relation.propertyName];\r\n                    }\r\n                } else {\r\n                    if (object[relation.propertyName]) {\r\n                        const subEntity = relationMetadata.create();\r\n                        if (entity[relation.propertyName])\r\n                            this.groupAndTransform(subEntity, entity[relation.propertyName], relationMetadata);\r\n\r\n                        this.groupAndTransform(subEntity, object[relation.propertyName], relationMetadata);\r\n                        entity[relation.propertyName] = subEntity;\r\n                    } else {\r\n                        entity[relation.propertyName] = object[relation.propertyName];\r\n                    }\r\n                }\r\n            });\r\n    }\r\n\r\n}"],"sourceRoot":"../.."}