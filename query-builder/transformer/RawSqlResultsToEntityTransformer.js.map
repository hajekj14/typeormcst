{"version":3,"sources":["../../src/query-builder/transformer/RawSqlResultsToEntityTransformer.ts"],"names":[],"mappings":"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","file":"RawSqlResultsToEntityTransformer.js","sourcesContent":["import {AliasMap} from \"../alias/AliasMap\";\r\nimport {Alias} from \"../alias/Alias\";\r\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\r\nimport {OrmUtils} from \"../../util/OrmUtils\";\r\nimport {Driver} from \"../../driver/Driver\";\r\nimport {JoinMapping, RelationCountMeta} from \"../QueryBuilder\";\r\nimport {EmbeddedMetadata} from \"../../metadata/EmbeddedMetadata\";\r\n\r\n/**\r\n * Transforms raw sql results returned from the database into entity object.\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class RawSqlResultsToEntityTransformer {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private driver: Driver,\r\n                private aliasMap: AliasMap,\r\n                private joinMappings: JoinMapping[],\r\n                private relationCountMetas: RelationCountMeta[],\r\n                private enableRelationIdValues: boolean) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    transform(rawSqlResults: any[]): any[] {\r\n        // console.log(\"rawSqlResults: \", rawSqlResults);\r\n        return this.groupAndTransform(rawSqlResults, this.aliasMap.mainAlias);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\r\n     * we need to group our result and we must have some unique id (primary key in our case)\r\n     */\r\n    private groupAndTransform(rawSqlResults: any[], alias: Alias) {\r\n\r\n        const metadata = this.aliasMap.getEntityMetadataByAlias(alias);\r\n        if (!metadata)\r\n            throw new Error(\"Cannot get entity metadata for the given alias \" + alias.name);\r\n\r\n        const groupedResults = OrmUtils.groupBy(rawSqlResults, result => {\r\n            if (!metadata) return;\r\n            return metadata.primaryColumnsWithParentIdColumns.map(column => result[alias.name + \"_\" + column.fullName]).join(\"_\"); // todo: check it\r\n        });\r\n        // console.log(\"groupedResults: \", groupedResults);\r\n        return groupedResults\r\n            .map(group => {\r\n                if (!metadata) return;\r\n                return this.transformIntoSingleResult(group.items, alias, metadata);\r\n            })\r\n            .filter(res => !!res);\r\n    }\r\n\r\n\r\n    /**\r\n     * Transforms set of data results into single entity.\r\n     */\r\n    private transformIntoSingleResult(rawSqlResults: any[], alias: Alias, metadata: EntityMetadata) {\r\n        const entity: any = metadata.create();\r\n        let hasData = false;\r\n\r\n        // console.log(rawSqlResults);\r\n\r\n        // add special columns that contains relation ids\r\n        if (this.enableRelationIdValues) {\r\n            metadata.columns\r\n                .filter(column => !!column.relationMetadata)\r\n                .forEach(column => {\r\n                    const valueInObject = rawSqlResults[0][alias.name + \"_\" + column.fullName]; // we use zero index since its grouped data\r\n                    if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {\r\n                        const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n                        entity[column.propertyName] = value;\r\n                        hasData = true;\r\n                    }\r\n                });\r\n        } // */\r\n\r\n        this.joinMappings\r\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.parentAliasName && joinMapping.alias.target)\r\n            .map(joinMapping => {\r\n                const relatedEntities = this.groupAndTransform(rawSqlResults, joinMapping.alias);\r\n                const isResultArray = joinMapping.isMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result && (!isResultArray || result.length > 0)) {\r\n                    entity[joinMapping.propertyName] = result;\r\n                    hasData = true;\r\n                }\r\n            });\r\n\r\n        // get value from columns selections and put them into object\r\n        metadata.columnsWithoutEmbeddeds.forEach(column => {\r\n            const columnName = column.fullName;\r\n            const valueInObject = rawSqlResults[0][alias.name + \"_\" + columnName]; // we use zero index since its grouped data\r\n            if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {\r\n                const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n\r\n                // if (column.isInEmbedded) {\r\n                //     if (!entity[column.embeddedProperty])\r\n                //         entity[column.embeddedProperty] = column.embeddedMetadata.create();\r\n                //\r\n                //     entity[column.embeddedProperty][column.propertyName] = value;\r\n                // } else {\r\n                entity[column.propertyName] = value;\r\n                // }\r\n                hasData = true;\r\n            }\r\n        });\r\n\r\n        const addEmbeddedValuesRecursively = (entity: any, embeddeds: EmbeddedMetadata[]) => {\r\n            embeddeds.forEach(embedded => {\r\n                embedded.columns.forEach(column => {\r\n                    const value = rawSqlResults[0][alias.name + \"_\" + column.fullName];\r\n                    if (!value) return;\r\n\r\n                    if (!entity[embedded.propertyName])\r\n                        entity[embedded.propertyName] = embedded.create();\r\n\r\n                    entity[embedded.propertyName][column.propertyName] = value;\r\n                    hasData = true;\r\n                });\r\n                addEmbeddedValuesRecursively(entity[embedded.propertyName], embedded.embeddeds);\r\n            });\r\n        };\r\n\r\n        addEmbeddedValuesRecursively(entity, metadata.embeddeds);\r\n\r\n        // add parent tables metadata\r\n        // console.log(rawSqlResults);\r\n        // todo: duplication\r\n        if (metadata.parentEntityMetadata) {\r\n            metadata.parentEntityMetadata.columnsWithoutEmbeddeds.forEach(column => {\r\n                const columnName = column.fullName;\r\n                const valueInObject = rawSqlResults[0][\"parentIdColumn_\" + metadata.parentEntityMetadata.table.name + \"_\" + columnName]; // we use zero index since its grouped data\r\n                if (valueInObject !== undefined && valueInObject !== null && column.propertyName && !column.isVirtual && !column.isParentId && !column.isDiscriminator) {\r\n                    const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n\r\n                    // if (column.isInEmbedded) {\r\n                    //     if (!entity[column.embeddedProperty])\r\n                    //         entity[column.embeddedProperty] = column.embeddedMetadata.create();\r\n                    //\r\n                    //     entity[column.embeddedProperty][column.propertyName] = value;\r\n                    // } else {\r\n                    entity[column.propertyName] = value;\r\n                    // }\r\n                    hasData = true;\r\n                }\r\n            });\r\n\r\n            addEmbeddedValuesRecursively(entity, metadata.parentEntityMetadata.embeddeds);\r\n        }\r\n\r\n        // if relation is loaded then go into it recursively and transform its values too\r\n        metadata.relations.forEach(relation => {\r\n            const relationAlias = this.aliasMap.findAliasByParent(alias.name, relation.propertyName);\r\n            if (relationAlias) {\r\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\r\n                const relatedEntities = this.groupAndTransform(rawSqlResults, relationAlias);\r\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result) {\r\n                    let propertyName = relation.propertyName;\r\n                    if (joinMapping) {\r\n                        propertyName = joinMapping.propertyName;\r\n                    }\r\n\r\n                    if (relation.isLazy) {\r\n                        entity[\"__\" + propertyName + \"__\"] = result;\r\n                    } else {\r\n                        entity[propertyName] = result;\r\n                    }\r\n\r\n                    if (!isResultArray || result.length > 0)\r\n                        hasData = true;\r\n                }\r\n            }\r\n\r\n            // if relation has id field then relation id/ids to that field.\r\n            if (relation.isManyToMany) {\r\n                if (relationAlias) {\r\n                    const ids: any[] = [];\r\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\r\n\r\n                    if (relation.idField || joinMapping) {\r\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\r\n                        const junctionMetadata = relation.junctionEntityMetadata;\r\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].fullName : junctionMetadata.columns[0].fullName;\r\n\r\n                        rawSqlResults.forEach(results => {\r\n                            if (relationAlias) {\r\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\r\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\r\n                                if (value !== undefined && value !== null)\r\n                                    ids.push(value);\r\n                            }\r\n                        });\r\n\r\n                        if (ids && ids.length)\r\n                            entity[propertyName] = ids;\r\n                    }\r\n                }\r\n            } else if (relation.idField) {\r\n                const relationName = relation.name;\r\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\r\n            }\r\n\r\n            // if relation counter\r\n            this.relationCountMetas.forEach(joinMeta => {\r\n                if (joinMeta.alias === relationAlias) {\r\n                    // console.log(\"relation count was found for relation: \", relation);\r\n                    // joinMeta.entity = entity;\r\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\r\n                    // console.log(joinMeta);\r\n                    // console.log(\"---------------------\");\r\n                }\r\n            });\r\n        });\r\n\r\n        return hasData ? entity : null;\r\n    }\r\n\r\n}"],"sourceRoot":"../.."}